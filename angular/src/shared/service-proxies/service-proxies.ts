/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from "rxjs/operators";
import {
  Observable,
  throwError as _observableThrow,
  of as _observableOf,
} from "rxjs";
import { Injectable, Inject, Optional, InjectionToken } from "@angular/core";
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from "@angular/common/http";

import * as moment from "moment";

export const API_BASE_URL = new InjectionToken<string>("API_BASE_URL");

@Injectable()
export class AccountServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  isTenantAvailable(
    body: IsTenantAvailableInput | undefined
  ): Observable<IsTenantAvailableOutput> {
    let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIsTenantAvailable(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIsTenantAvailable(<any>response_);
            } catch (e) {
              return <Observable<IsTenantAvailableOutput>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<IsTenantAvailableOutput>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processIsTenantAvailable(
    response: HttpResponseBase
  ): Observable<IsTenantAvailableOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = IsTenantAvailableOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IsTenantAvailableOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  register(body: RegisterInput | undefined): Observable<RegisterOutput> {
    let url_ = this.baseUrl + "/api/services/app/Account/Register";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(<any>response_);
            } catch (e) {
              return <Observable<RegisterOutput>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<RegisterOutput>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processRegister(
    response: HttpResponseBase
  ): Observable<RegisterOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RegisterOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RegisterOutput>(<any>null);
  }
}

@Injectable()
export class AdditionalDetailServicesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<AdditionalDetailsDto> {
    let url_ = this.baseUrl + "/api/services/app/AdditionalDetailServices/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<AdditionalDetailsDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalDetailsDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<AdditionalDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalDetailsDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<AdditionalDetailsDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalDetailServices/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<AdditionalDetailsDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalDetailsDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<AdditionalDetailsDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalDetailsDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalDetailsDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: AdditionalDetailsDto | undefined
  ): Observable<AdditionalDetailsDto> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalDetailServices/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<AdditionalDetailsDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalDetailsDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<AdditionalDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalDetailsDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: AdditionalDetailsDto | undefined
  ): Observable<AdditionalDetailsDto> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalDetailServices/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<AdditionalDetailsDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalDetailsDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<AdditionalDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalDetailsDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalDetailServices/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class AdditionalIncomeServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: AdditionalIncomeDto | undefined
  ): Observable<AdditionalIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalIncomeService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<AdditionalIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<AdditionalIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalIncomeDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalIncomeService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<AdditionalIncomeDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalIncomeService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<AdditionalIncomeDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalIncomeDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<AdditionalIncomeDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalIncomeDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalIncomeDtoPagedResultDto>(<any>null);
  }

  /**
   * @param loanApplicationId (optional)
   * @return Success
   */
  getAllByLoanApplicationId(
    loanApplicationId: number | undefined
  ): Observable<AdditionalIncome[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/AdditionalIncomeService/GetAllByLoanApplicationId?";
    if (loanApplicationId === null)
      throw new Error("The parameter 'loanApplicationId' cannot be null.");
    else if (loanApplicationId !== undefined)
      url_ +=
        "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllByLoanApplicationId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllByLoanApplicationId(<any>response_);
            } catch (e) {
              return <Observable<AdditionalIncome[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<AdditionalIncome[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllByLoanApplicationId(
    response: HttpResponseBase
  ): Observable<AdditionalIncome[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(AdditionalIncome.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalIncome[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<AdditionalIncomeDto> {
    let url_ = this.baseUrl + "/api/services/app/AdditionalIncomeService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<AdditionalIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<AdditionalIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalIncomeDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: AdditionalIncomeDto | undefined
  ): Observable<AdditionalIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalIncomeService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<AdditionalIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<AdditionalIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalIncomeDto>(<any>null);
  }
}

@Injectable()
export class AdminDisclosuresServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminDisclosure | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminDisclosures/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminDisclosure | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminDisclosures/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminDisclosures/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminDisclosures/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminDisclosures/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class AdminLoanApplicationDocumentServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminLoanApplicationDocument | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanApplicationDocument/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param loanId (optional)
   * @param disclosureId (optional)
   * @param userId (optional)
   * @param formFile (optional)
   * @return Success
   */
  upload(
    loanId: number | undefined,
    disclosureId: number | undefined,
    userId: number | undefined,
    formFile: FileParameter | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanApplicationDocument/Upload";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (loanId === null || loanId === undefined)
      throw new Error("The parameter 'loanId' cannot be null.");
    else content_.append("LoanId", loanId.toString());
    if (disclosureId === null || disclosureId === undefined)
      throw new Error("The parameter 'disclosureId' cannot be null.");
    else content_.append("DisclosureId", disclosureId.toString());
    if (userId === null || userId === undefined)
      throw new Error("The parameter 'userId' cannot be null.");
    else content_.append("UserId", userId.toString());
    if (formFile === null || formFile === undefined)
      throw new Error("The parameter 'formFile' cannot be null.");
    else
      content_.append(
        "formFile",
        formFile.data,
        formFile.fileName ? formFile.fileName : "formFile"
      );

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpload(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpload(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpload(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateAdminLoanApplicationDocument | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanApplicationDocument/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanApplicationDocument/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminLoanApplicationDocument/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminLoanApplicationDocument/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class AdminLoanDetailServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminLoanDetail | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanDetail/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminLoanDetail | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanDetail/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanDetail/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminLoanDetail/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminLoanDetail/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class AdminLoanProgramServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminLoanProgram | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanProgram/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminLoanProgram | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanProgram/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanProgram/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminLoanProgram/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminLoanProgram/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class AdminLoanStatusServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminLoanStatus | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanStatus/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminLoanStatus | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanStatus/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanStatus/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminLoanStatus/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminLoanStatus/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class AdminLoanSummaryStatusServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminLoanSummaryStatus | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanSummaryStatus/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminLoanSummaryStatus | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanSummaryStatus/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminLoanSummaryStatus/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminLoanSummaryStatus/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminLoanSummaryStatus/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class AdminNotificationTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminNotificationType | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminNotificationType/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminNotificationType | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminNotificationType/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminNotificationType/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminNotificationType/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminNotificationType/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class AdminUserServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminUser | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminUser/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminUser | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminUser/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @param oldPassword (optional)
   * @param newPassword (optional)
   * @return Success
   */
  changePassword(
    id: number | undefined,
    oldPassword: string | undefined,
    newPassword: string | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminUser/ChangePassword?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    if (oldPassword === null)
      throw new Error("The parameter 'oldPassword' cannot be null.");
    else if (oldPassword !== undefined)
      url_ += "oldPassword=" + encodeURIComponent("" + oldPassword) + "&";
    if (newPassword === null)
      throw new Error("The parameter 'newPassword' cannot be null.");
    else if (newPassword !== undefined)
      url_ += "newPassword=" + encodeURIComponent("" + newPassword) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePassword(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangePassword(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @param userName (optional)
   * @return Success
   */
  changeUsername(
    id: number | undefined,
    userName: string | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminUser/ChangeUsername?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    if (userName === null)
      throw new Error("The parameter 'userName' cannot be null.");
    else if (userName !== undefined)
      url_ += "userName=" + encodeURIComponent("" + userName) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeUsername(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeUsername(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangeUsername(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @param email (optional)
   * @return Success
   */
  changeEmail(
    id: number | undefined,
    email: string | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminUser/ChangeEmail?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    if (email === null)
      throw new Error("The parameter 'email' cannot be null.");
    else if (email !== undefined)
      url_ += "email=" + encodeURIComponent("" + email) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeEmail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeEmail(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangeEmail(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminUser/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminUser/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminUser/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class AdminUserEnabledDeviceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminUserEnabledDevice | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminUserEnabledDevice/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminUserEnabledDevice | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminUserEnabledDevice/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminUserEnabledDevice/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminUserEnabledDevice/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminUserEnabledDevice/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class AdminUserNotificationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminUserNotification | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminUserNotification/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminUserNotification | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminUserNotification/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/AdminUserNotification/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminUserNotification/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/AdminUserNotification/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ApplicationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: InsertApplicationRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateApplicationRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  applications(): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/applications";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processApplications(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processApplications(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processApplications(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  application(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/application?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processApplication(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processApplication(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processApplication(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  additioanlEmploymentDetails(): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/additioanl-employment-details";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdditioanlEmploymentDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdditioanlEmploymentDetails(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdditioanlEmploymentDetails(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  additioanlEmploymentDetail(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/additioanl-employment-detail?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdditioanlEmploymentDetail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdditioanlEmploymentDetail(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdditioanlEmploymentDetail(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  applicationDeclarationQuestions(): Observable<void> {
    let url_ =
      this.baseUrl + "/api/Application/application-declaration-questions";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processApplicationDeclarationQuestions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processApplicationDeclarationQuestions(
                <any>response_
              );
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processApplicationDeclarationQuestions(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  applicationDeclarationQuestion(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/Application/application-declaration-question?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processApplicationDeclarationQuestion(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processApplicationDeclarationQuestion(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processApplicationDeclarationQuestion(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  employmentDetails(): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/employment-details";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEmploymentDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEmploymentDetails(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processEmploymentDetails(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  employmentDetail(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/employment-detail?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEmploymentDetail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEmploymentDetail(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processEmploymentDetail(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  employmentIncomeDetails(): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/employment-income-details";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEmploymentIncomeDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEmploymentIncomeDetails(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processEmploymentIncomeDetails(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  employmentIncomeDetail(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/employment-income-detail?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEmploymentIncomeDetail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEmploymentIncomeDetail(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processEmploymentIncomeDetail(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  previousEmploymentDetails(): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/previous-employment-details";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPreviousEmploymentDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPreviousEmploymentDetails(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPreviousEmploymentDetails(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  previousEmploymentDetail(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/previous-employment-detail?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPreviousEmploymentDetail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPreviousEmploymentDetail(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPreviousEmploymentDetail(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  financialRealStates(): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/financial-real-states";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processFinancialRealStates(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processFinancialRealStates(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processFinancialRealStates(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  financialRealState(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/financial-real-state?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processFinancialRealState(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processFinancialRealState(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processFinancialRealState(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  financialAssets(): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/financial-assets";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processFinancialAssets(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processFinancialAssets(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processFinancialAssets(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  financialAsset(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/financial-asset?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processFinancialAsset(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processFinancialAsset(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processFinancialAsset(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  financialLiabilities(): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/financial-Liabilities";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processFinancialLiabilities(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processFinancialLiabilities(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processFinancialLiabilities(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  financialLiability(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/financial-Liability?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processFinancialLiability(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processFinancialLiability(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processFinancialLiability(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  incomeSources(): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/income-sources";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIncomeSources(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIncomeSources(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIncomeSources(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  incomeSource(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/income-source?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIncomeSource(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIncomeSource(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIncomeSource(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  otherFinancialAssets(): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/other-financial-assets";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOtherFinancialAssets(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOtherFinancialAssets(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOtherFinancialAssets(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  otherFinancialAsset(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/other-financial-asset?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOtherFinancialAsset(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOtherFinancialAsset(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOtherFinancialAsset(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  otherFinancialLiabilityUpdate(
    body: UpdateApplicationFinancialOtherLaibilityRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Application/other-financial-liabilityUpdate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOtherFinancialLiabilityUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOtherFinancialLiabilityUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOtherFinancialLiabilityUpdate(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  otherFinancialLiabilityDelete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Application/other-financial-liabilityDelete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOtherFinancialLiabilityDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOtherFinancialLiabilityDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOtherFinancialLiabilityDelete(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  otherFinancialLiabilities(): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/other-financial-liabilities";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOtherFinancialLiabilities(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOtherFinancialLiabilities(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOtherFinancialLiabilities(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  otherFinancialLiability(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/other-financial-liability?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOtherFinancialLiability(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOtherFinancialLiability(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOtherFinancialLiability(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  militaryServices(): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/military-services";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMilitaryServices(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMilitaryServices(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMilitaryServices(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  militaryService(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/military-service?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMilitaryService(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMilitaryService(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMilitaryService(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class AdditioanlEmploymentDetailServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddAdditionalEmploymentDetailRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Application/additioanl-employment-detail/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateAdditionalEmploymentDetailRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Application/additioanl-employment-detail/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Application/additioanl-employment-detail/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class IncomeDetailServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddAdditionalEmployementIncomeDetailRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Application/additioanl-employment/income-detail/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateAdditionalEmployementIncomeDetailRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/Application/additioanl-employment/income-detail/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/Application/additioanl-employment/income-detail/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class AdditioanlEmploymentServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  incomeDetails(): Observable<void> {
    let url_ =
      this.baseUrl + "/api/Application/additioanl-employment/income-details";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIncomeDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIncomeDetails(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIncomeDetails(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  incomeDetail(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/Application/additioanl-employment/income-detail?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIncomeDetail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIncomeDetail(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIncomeDetail(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ApplicationDeclarationQuestionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddApplicationDeclarationQuestionRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Application/application-declaration-question/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateApplicationDeclarationQuestionRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Application/application-declaration-question/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/Application/application-declaration-question/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class EmploymentDetailServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddEmploymentDetailRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/employment-detail/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateEmploymentDetailRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/employment-detail/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/employment-detail/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class EmploymentIncomeDetailServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddEmployementIncomeDetailRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/employment-income-detail/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateEmployementIncomeDetailRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Application/employment-income-detail/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Application/employment-income-detail/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class PreviousEmploymentDetailServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddPreviousEmployementDetailRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/previous-employment-detail/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdatePreviousEmployementDetailRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Application/previous-employment-detail/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Application/previous-employment-detail/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class FinancialRealStateServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddFinancialRealEstateRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/financial-real-state/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateFinancialRealEstateRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/financial-real-state/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/financial-real-state/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class PersonalInformationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddPersonalInformationRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/personal-information/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdatePersonalInformationRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/personal-information/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/personal-information/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  details(): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/personal-information/details";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDetails(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDetails(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  detail(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Application/personal-information/detail?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDetail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDetail(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDetail(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class FinancialAssetServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddApplicationFinancialAssetRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/financial-asset/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateApplicationFinancialAssetRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/financial-asset/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/financial-asset/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class FinancialLiabilityServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddApplicationFinancialLiabilityRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/financial-Liability/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateApplicationFinancialLiabilityRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/financial-Liability/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/financial-Liability/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class IncomeSourceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddApplicationIncomeSourceRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/income-source/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateApplicationIncomeSourceRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/income-source/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/income-source/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class OtherFinancialAssetServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddApplicationFinancialOtherAssetRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/other-financial-asset/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateApplicationFinancialOtherAssetRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/other-financial-asset/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/other-financial-asset/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class OtherFinancialLiabilityServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddApplicationFinancialOtherLaibilityRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/other-financial-liability/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class MilitaryServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddMilitaryServiceRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/military-service/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateMilitaryServiceRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/military-service/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Application/military-service/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class BorrowerEmploymentInformationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<BorrowerEmploymentInformationDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerEmploymentInformation/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<BorrowerEmploymentInformationDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerEmploymentInformationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<BorrowerEmploymentInformationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerEmploymentInformationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerEmploymentInformationDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<BorrowerEmploymentInformationDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerEmploymentInformation/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <
                Observable<BorrowerEmploymentInformationDtoPagedResultDto>
              >(<any>_observableThrow(e));
            }
          } else
            return <Observable<BorrowerEmploymentInformationDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<BorrowerEmploymentInformationDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerEmploymentInformationDtoPagedResultDto.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerEmploymentInformationDtoPagedResultDto>(
      <any>null
    );
  }

  /**
   * @param loanApplicationId (optional)
   * @return Success
   */
  getAllByLoanApplicationId(
    loanApplicationId: number | undefined
  ): Observable<BorrowerEmploymentInformation[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/BorrowerEmploymentInformation/GetAllByLoanApplicationId?";
    if (loanApplicationId === null)
      throw new Error("The parameter 'loanApplicationId' cannot be null.");
    else if (loanApplicationId !== undefined)
      url_ +=
        "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllByLoanApplicationId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllByLoanApplicationId(<any>response_);
            } catch (e) {
              return <Observable<BorrowerEmploymentInformation[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerEmploymentInformation[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllByLoanApplicationId(
    response: HttpResponseBase
  ): Observable<BorrowerEmploymentInformation[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(BorrowerEmploymentInformation.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerEmploymentInformation[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: BorrowerEmploymentInformationDto | undefined
  ): Observable<BorrowerEmploymentInformationDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerEmploymentInformation/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<BorrowerEmploymentInformationDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerEmploymentInformationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<BorrowerEmploymentInformationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerEmploymentInformationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerEmploymentInformationDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: BorrowerEmploymentInformationDto | undefined
  ): Observable<BorrowerEmploymentInformationDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerEmploymentInformation/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<BorrowerEmploymentInformationDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerEmploymentInformationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<BorrowerEmploymentInformationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerEmploymentInformationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerEmploymentInformationDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerEmploymentInformation/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class BorrowerMonthlyIncomeServicesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<BorrowerMonthlyIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerMonthlyIncomeServices/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<BorrowerMonthlyIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerMonthlyIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<BorrowerMonthlyIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerMonthlyIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerMonthlyIncomeDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<BorrowerMonthlyIncomeDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerMonthlyIncomeServices/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<BorrowerMonthlyIncomeDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerMonthlyIncomeDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<BorrowerMonthlyIncomeDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerMonthlyIncomeDtoPagedResultDto.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerMonthlyIncomeDtoPagedResultDto>(<any>null);
  }

  /**
   * @param loanApplicationId (optional)
   * @return Success
   */
  getAllByLoanApplicationId(
    loanApplicationId: number | undefined
  ): Observable<BorrowerMonthlyIncome[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/BorrowerMonthlyIncomeServices/GetAllByLoanApplicationId?";
    if (loanApplicationId === null)
      throw new Error("The parameter 'loanApplicationId' cannot be null.");
    else if (loanApplicationId !== undefined)
      url_ +=
        "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllByLoanApplicationId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllByLoanApplicationId(<any>response_);
            } catch (e) {
              return <Observable<BorrowerMonthlyIncome[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerMonthlyIncome[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllByLoanApplicationId(
    response: HttpResponseBase
  ): Observable<BorrowerMonthlyIncome[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(BorrowerMonthlyIncome.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerMonthlyIncome[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: BorrowerMonthlyIncomeDto | undefined
  ): Observable<BorrowerMonthlyIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerMonthlyIncomeServices/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<BorrowerMonthlyIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerMonthlyIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<BorrowerMonthlyIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerMonthlyIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerMonthlyIncomeDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: BorrowerMonthlyIncomeDto | undefined
  ): Observable<BorrowerMonthlyIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerMonthlyIncomeServices/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<BorrowerMonthlyIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerMonthlyIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<BorrowerMonthlyIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerMonthlyIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerMonthlyIncomeDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerMonthlyIncomeServices/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class CitizenshipTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddCitizenshipTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/CitizenshipType/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateCitizenshipTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/CitizenshipType/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/CitizenshipType/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  citizenshipTypes(): Observable<void> {
    let url_ = this.baseUrl + "/api/CitizenshipType/citizenship-types";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCitizenshipTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCitizenshipTypes(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCitizenshipTypes(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  citizenshipType(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/CitizenshipType/citizenship-type?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCitizenshipType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCitizenshipType(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCitizenshipType(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class CityServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddCityRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/City/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateCityRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/City/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/City/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  cities(): Observable<void> {
    let url_ = this.baseUrl + "/api/City/cities";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCities(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCities(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCities(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  city(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/City/city?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCity(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCity(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCity(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ConfigurationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeUiTheme(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeUiTheme(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

// @Injectable()
// export class CountryServiceProxy {
//     private http: HttpClient;
//     private baseUrl: string;
//     protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

//     constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
//         this.http = http;
//         this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
//     }

//     /**
//      * @param body (optional)
//      * @return Success
//      */
//     add(body: AddCountryRequest | undefined): Observable<string> {
//         let url_ = this.baseUrl + "/api/Country/Country/add";
//         url_ = url_.replace(/[?&]$/, "");

//         const content_ = JSON.stringify(body);

//         let options_ : any = {
//             body: content_,
//             observe: "response",
//             responseType: "blob",
//             headers: new HttpHeaders({
//                 "Content-Type": "application/json-patch+json",
//                 "Accept": "text/plain"
//             })
//         };

//         return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
//             return this.processAdd(response_);
//         })).pipe(_observableCatch((response_: any) => {
//             if (response_ instanceof HttpResponseBase) {
//                 try {
//                     return this.processAdd(<any>response_);
//                 } catch (e) {
//                     return <Observable<string>><any>_observableThrow(e);
//                 }
//             } else
//                 return <Observable<string>><any>_observableThrow(response_);
//         }));
//     }

//     protected processAdd(response: HttpResponseBase): Observable<string> {
//         const status = response.status;
//         const responseBlob =
//             response instanceof HttpResponse ? response.body :
//             (<any>response).error instanceof Blob ? (<any>response).error : undefined;

//         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
//         if (status === 200) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             let result200: any = null;
//             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
//             result200 = resultData200 !== undefined ? resultData200 : <any>null;
//             return _observableOf(result200);
//             }));
//         } else if (status !== 200 && status !== 204) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//             }));
//         }
//         return _observableOf<string>(<any>null);
//     }

//     /**
//      * @param body (optional)
//      * @return Success
//      */
//     update(body: UpdateCountryRequest | undefined): Observable<string> {
//         let url_ = this.baseUrl + "/api/Country/Country/Update";
//         url_ = url_.replace(/[?&]$/, "");

//         const content_ = JSON.stringify(body);

//         let options_ : any = {
//             body: content_,
//             observe: "response",
//             responseType: "blob",
//             headers: new HttpHeaders({
//                 "Content-Type": "application/json-patch+json",
//                 "Accept": "text/plain"
//             })
//         };

//         return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
//             return this.processUpdate(response_);
//         })).pipe(_observableCatch((response_: any) => {
//             if (response_ instanceof HttpResponseBase) {
//                 try {
//                     return this.processUpdate(<any>response_);
//                 } catch (e) {
//                     return <Observable<string>><any>_observableThrow(e);
//                 }
//             } else
//                 return <Observable<string>><any>_observableThrow(response_);
//         }));
//     }

//     protected processUpdate(response: HttpResponseBase): Observable<string> {
//         const status = response.status;
//         const responseBlob =
//             response instanceof HttpResponse ? response.body :
//             (<any>response).error instanceof Blob ? (<any>response).error : undefined;

//         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
//         if (status === 200) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             let result200: any = null;
//             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
//             result200 = resultData200 !== undefined ? resultData200 : <any>null;
//             return _observableOf(result200);
//             }));
//         } else if (status !== 200 && status !== 204) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//             }));
//         }
//         return _observableOf<string>(<any>null);
//     }

//     /**
//      * @param id (optional)
//      * @return Success
//      */
//     delete(id: number | undefined): Observable<string> {
//         let url_ = this.baseUrl + "/api/Country/Country/Delete?";
//         if (id === null)
//             throw new Error("The parameter 'id' cannot be null.");
//         else if (id !== undefined)
//             url_ += "id=" + encodeURIComponent("" + id) + "&";
//         url_ = url_.replace(/[?&]$/, "");

//         let options_ : any = {
//             observe: "response",
//             responseType: "blob",
//             headers: new HttpHeaders({
//                 "Accept": "text/plain"
//             })
//         };

//         return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
//             return this.processDelete(response_);
//         })).pipe(_observableCatch((response_: any) => {
//             if (response_ instanceof HttpResponseBase) {
//                 try {
//                     return this.processDelete(<any>response_);
//                 } catch (e) {
//                     return <Observable<string>><any>_observableThrow(e);
//                 }
//             } else
//                 return <Observable<string>><any>_observableThrow(response_);
//         }));
//     }

//     protected processDelete(response: HttpResponseBase): Observable<string> {
//         const status = response.status;
//         const responseBlob =
//             response instanceof HttpResponse ? response.body :
//             (<any>response).error instanceof Blob ? (<any>response).error : undefined;

//         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
//         if (status === 200) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             let result200: any = null;
//             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
//             result200 = resultData200 !== undefined ? resultData200 : <any>null;
//             return _observableOf(result200);
//             }));
//         } else if (status !== 200 && status !== 204) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//             }));
//         }
//         return _observableOf<string>(<any>null);
//     }

//     /**
//      * @return Success
//      */
//     countries(): Observable<void> {
//         let url_ = this.baseUrl + "/api/Country/Country/countries";
//         url_ = url_.replace(/[?&]$/, "");

//         let options_ : any = {
//             observe: "response",
//             responseType: "blob",
//             headers: new HttpHeaders({
//             })
//         };

//         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
//             return this.processCountries(response_);
//         })).pipe(_observableCatch((response_: any) => {
//             if (response_ instanceof HttpResponseBase) {
//                 try {
//                     return this.processCountries(<any>response_);
//                 } catch (e) {
//                     return <Observable<void>><any>_observableThrow(e);
//                 }
//             } else
//                 return <Observable<void>><any>_observableThrow(response_);
//         }));
//     }

//     protected processCountries(response: HttpResponseBase): Observable<void> {
//         const status = response.status;
//         const responseBlob =
//             response instanceof HttpResponse ? response.body :
//             (<any>response).error instanceof Blob ? (<any>response).error : undefined;

//         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
//         if (status === 200) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             return _observableOf<void>(<any>null);
//             }));
//         } else if (status !== 200 && status !== 204) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//             }));
//         }
//         return _observableOf<void>(<any>null);
//     }
// }

@Injectable()
export class CountryServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  country(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Country/country/Country?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCountry(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCountry(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCountry(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class CreditAuthAgreementServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<CreditAuthAgreementDto> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditAuthAgreementService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<CreditAuthAgreementDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<CreditAuthAgreementDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<CreditAuthAgreementDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreditAuthAgreementDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CreditAuthAgreementDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<CreditAuthAgreementDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditAuthAgreementService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<CreditAuthAgreementDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<CreditAuthAgreementDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<CreditAuthAgreementDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreditAuthAgreementDtoPagedResultDto.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CreditAuthAgreementDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: CreditAuthAgreementDto | undefined
  ): Observable<CreditAuthAgreementDto> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditAuthAgreementService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<CreditAuthAgreementDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<CreditAuthAgreementDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<CreditAuthAgreementDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreditAuthAgreementDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CreditAuthAgreementDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: CreditAuthAgreementDto | undefined
  ): Observable<CreditAuthAgreementDto> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditAuthAgreementService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<CreditAuthAgreementDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<CreditAuthAgreementDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<CreditAuthAgreementDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreditAuthAgreementDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CreditAuthAgreementDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditAuthAgreementService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class CreditTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddCreditTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/CreditType/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateCreditTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/CreditType/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/CreditType/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  creditTypes(): Observable<void> {
    let url_ = this.baseUrl + "/api/CreditType/credit-types";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreditTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreditTypes(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreditTypes(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  creditType(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/CreditType/credit-type?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreditType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreditType(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreditType(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class CategoryServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddDeclarationCategoryRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Declaration/category/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateDeclarationCategoryRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Declaration/category/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Declaration/category/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class DeclarationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  categories(): Observable<void> {
    let url_ = this.baseUrl + "/api/Declaration/categories";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategories(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategories(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCategories(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  category(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Declaration/category?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCategory(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCategory(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCategory(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  questions(): Observable<void> {
    let url_ = this.baseUrl + "/api/Declaration/questions";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processQuestions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processQuestions(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processQuestions(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  question(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Declaration/question?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processQuestion(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processQuestion(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processQuestion(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class QuestionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddDeclarationQuestionRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Declaration/question/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateDeclarationQuestionRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Declaration/question/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Declaration/question/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class DeclarationServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<DeclarationDto> {
    let url_ = this.baseUrl + "/api/services/app/DeclarationService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<DeclarationDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<DeclarationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<DeclarationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DeclarationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DeclarationDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<DeclarationDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/DeclarationService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<DeclarationDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<DeclarationDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<DeclarationDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DeclarationDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DeclarationDtoPagedResultDto>(<any>null);
  }

  /**
   * @param loanApplicationId (optional)
   * @return Success
   */
  getAllDeclrationByLoanApplicationId(
    loanApplicationId: number | undefined
  ): Observable<Declaration[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/GetAllDeclrationByLoanApplicationId?";
    if (loanApplicationId === null)
      throw new Error("The parameter 'loanApplicationId' cannot be null.");
    else if (loanApplicationId !== undefined)
      url_ +=
        "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllDeclrationByLoanApplicationId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllDeclrationByLoanApplicationId(
                <any>response_
              );
            } catch (e) {
              return <Observable<Declaration[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<Declaration[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllDeclrationByLoanApplicationId(
    response: HttpResponseBase
  ): Observable<Declaration[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(Declaration.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<Declaration[]>(<any>null);
  }

  /**
   * @param loanApplicationId (optional)
   * @return Success
   */
  getAllDemographicInformationByLoanApplicationId(
    loanApplicationId: number | undefined
  ): Observable<DeclarationBorrowereDemographicsInformation[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/GetAllDemographicInformationByLoanApplicationId?";
    if (loanApplicationId === null)
      throw new Error("The parameter 'loanApplicationId' cannot be null.");
    else if (loanApplicationId !== undefined)
      url_ +=
        "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllDemographicInformationByLoanApplicationId(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllDemographicInformationByLoanApplicationId(
                <any>response_
              );
            } catch (e) {
              return <
                Observable<DeclarationBorrowereDemographicsInformation[]>
              >(<any>_observableThrow(e));
            }
          } else
            return <Observable<DeclarationBorrowereDemographicsInformation[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllDemographicInformationByLoanApplicationId(
    response: HttpResponseBase
  ): Observable<DeclarationBorrowereDemographicsInformation[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(
                DeclarationBorrowereDemographicsInformation.fromJS(item)
              );
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DeclarationBorrowereDemographicsInformation[]>(
      <any>null
    );
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: DeclarationDto | undefined): Observable<DeclarationDto> {
    let url_ = this.baseUrl + "/api/services/app/DeclarationService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<DeclarationDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<DeclarationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<DeclarationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DeclarationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DeclarationDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: DeclarationDto | undefined): Observable<DeclarationDto> {
    let url_ = this.baseUrl + "/api/services/app/DeclarationService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<DeclarationDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<DeclarationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<DeclarationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DeclarationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DeclarationDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/DeclarationService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class SourceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddDemographicInfoSourceRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/DemographicInfo/source/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateDemographicInfoSourceRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/DemographicInfo/source/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/DemographicInfo/source/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class DemographicInfoServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  sources(): Observable<void> {
    let url_ = this.baseUrl + "/api/DemographicInfo/sources";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSources(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSources(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSources(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  source(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/DemographicInfo/source?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSource(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSource(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSource(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddDemographicInformationRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/DemographicInfo/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateDemographicInformationRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/DemographicInfo/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/DemographicInfo/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  informations(): Observable<void> {
    let url_ = this.baseUrl + "/api/DemographicInfo/informations";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInformations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInformations(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processInformations(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  information(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/DemographicInfo/information?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInformation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInformation(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processInformation(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class EConsentServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<EConsentDto> {
    let url_ = this.baseUrl + "/api/services/app/EConsentService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<EConsentDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<EConsentDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<EConsentDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EConsentDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EConsentDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<EConsentDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/EConsentService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<EConsentDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<EConsentDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<EConsentDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EConsentDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EConsentDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: EConsentDto | undefined): Observable<EConsentDto> {
    let url_ = this.baseUrl + "/api/services/app/EConsentService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<EConsentDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<EConsentDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<EConsentDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EConsentDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EConsentDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: EConsentDto | undefined): Observable<EConsentDto> {
    let url_ = this.baseUrl + "/api/services/app/EConsentService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<EConsentDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<EConsentDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<EConsentDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EConsentDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EConsentDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/EConsentService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class EmploymentIncomeServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<EmploymentIncomeDto> {
    let url_ = this.baseUrl + "/api/services/app/EmploymentIncomeService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<EmploymentIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<EmploymentIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<EmploymentIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EmploymentIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EmploymentIncomeDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<EmploymentIncomeDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/EmploymentIncomeService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<EmploymentIncomeDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<EmploymentIncomeDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<EmploymentIncomeDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EmploymentIncomeDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EmploymentIncomeDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: EmploymentIncomeDto | undefined
  ): Observable<EmploymentIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/EmploymentIncomeService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<EmploymentIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<EmploymentIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<EmploymentIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EmploymentIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EmploymentIncomeDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: EmploymentIncomeDto | undefined
  ): Observable<EmploymentIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/EmploymentIncomeService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<EmploymentIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<EmploymentIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<EmploymentIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EmploymentIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EmploymentIncomeDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/EmploymentIncomeService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ExpenseServicesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<ExpensesDto> {
    let url_ = this.baseUrl + "/api/services/app/ExpenseServices/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<ExpensesDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ExpensesDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<ExpensesDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExpensesDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExpensesDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<ExpensesDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/ExpenseServices/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ExpensesDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ExpensesDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<ExpensesDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExpensesDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExpensesDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: ExpensesDto | undefined): Observable<ExpensesDto> {
    let url_ = this.baseUrl + "/api/services/app/ExpenseServices/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<ExpensesDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ExpensesDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<ExpensesDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExpensesDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExpensesDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: ExpensesDto | undefined): Observable<ExpensesDto> {
    let url_ = this.baseUrl + "/api/services/app/ExpenseServices/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<ExpensesDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ExpensesDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<ExpensesDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExpensesDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExpensesDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/ExpenseServices/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class StatusServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddPropertyStatusRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Financial/property/status/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdatePropertyStatusRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Financial/property/status/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Financial/property/status/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class PropertyServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  statuses(): Observable<void> {
    let url_ = this.baseUrl + "/api/Financial/property/statuses";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processStatuses(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processStatuses(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processStatuses(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  status(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Financial/property/status?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processStatus(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processStatus(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  intendedOccupancies(): Observable<void> {
    let url_ = this.baseUrl + "/api/Financial/property/intended-occupancies";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIntendedOccupancies(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIntendedOccupancies(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIntendedOccupancies(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  intendedOccupancy(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Financial/property/intended-occupancy?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIntendedOccupancy(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIntendedOccupancy(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIntendedOccupancy(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class IntendedOccupancyServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddPropertyIntendedOccupancyRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Financial/property/intended-occupancy/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdatePropertyIntendedOccupancyRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Financial/property/intended-occupancy/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/Financial/property/intended-occupancy/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class OtherLaibilitiesTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddOtherLaibilitiesTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Financial/other-laibilities-type/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateOtherLaibilitiesTypeRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/Financial/other-laibilities-type/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Financial/other-laibilities-type/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class FinancialServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  otherLaibilitiesTypes(): Observable<void> {
    let url_ = this.baseUrl + "/api/Financial/other-laibilities-types";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOtherLaibilitiesTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOtherLaibilitiesTypes(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOtherLaibilitiesTypes(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  otherLaibilitiesType(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Financial/other-laibilities-type?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOtherLaibilitiesType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOtherLaibilitiesType(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOtherLaibilitiesType(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  laibilitiesTypes(): Observable<void> {
    let url_ = this.baseUrl + "/api/Financial/laibilities-types";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLaibilitiesTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLaibilitiesTypes(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processLaibilitiesTypes(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  laibilitiesType(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Financial/laibilities-type?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLaibilitiesType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLaibilitiesType(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processLaibilitiesType(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  accountTypes(): Observable<void> {
    let url_ = this.baseUrl + "/api/Financial/account-types";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAccountTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAccountTypes(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAccountTypes(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  accountType(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/Financial/account-type?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAccountType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAccountType(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAccountType(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LaibilitiesTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLaibilitiesTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Financial/laibilities-type/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLaibilitiesTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Financial/laibilities-type/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Financial/laibilities-type/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class AccountTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAccountTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Financial/account-type/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAccountTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Financial/account-type/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/Financial/account-type/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class HomeBuyingServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: BuyingHomeDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/HomeBuying/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class HomeBuyingServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: BuyingHomeDto | undefined): Observable<BuyingHomeDto> {
    let url_ = this.baseUrl + "/api/services/app/HomeBuyingService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<BuyingHomeDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<BuyingHomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<BuyingHomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BuyingHomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BuyingHomeDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/HomeBuyingService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<BuyingHomeDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/HomeBuyingService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<BuyingHomeDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BuyingHomeDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<BuyingHomeDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BuyingHomeDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BuyingHomeDtoPagedResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<BuyingHomeDto> {
    let url_ = this.baseUrl + "/api/services/app/HomeBuyingService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<BuyingHomeDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<BuyingHomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<BuyingHomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BuyingHomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BuyingHomeDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: BuyingHomeDto | undefined): Observable<BuyingHomeDto> {
    let url_ = this.baseUrl + "/api/services/app/HomeBuyingService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<BuyingHomeDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<BuyingHomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<BuyingHomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BuyingHomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BuyingHomeDto>(<any>null);
  }
}

@Injectable()
export class HousingTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddHousingTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/HousingType/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateHousingTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/HousingType/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/HousingType/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  housingTypes(): Observable<void> {
    let url_ = this.baseUrl + "/api/HousingType/housing-types";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processHousingTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processHousingTypes(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processHousingTypes(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  housingType(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/HousingType/housing-type?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processHousingType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processHousingType(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processHousingType(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
// export class IncomeSourceServiceProxy {
//     private http: HttpClient;
//     private baseUrl: string;
//     protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

//     constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
//         this.http = http;
//         this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
//     }

//     /**
//      * @param body (optional)
//      * @return Success
//      */
//     add(body: AddIncomeSourceRequest | undefined): Observable<string> {
//         let url_ = this.baseUrl + "/api/IncomeSource/add";
//         url_ = url_.replace(/[?&]$/, "");

//         const content_ = JSON.stringify(body);

//         let options_ : any = {
//             body: content_,
//             observe: "response",
//             responseType: "blob",
//             headers: new HttpHeaders({
//                 "Content-Type": "application/json-patch+json",
//                 "Accept": "text/plain"
//             })
//         };

//         return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
//             return this.processAdd(response_);
//         })).pipe(_observableCatch((response_: any) => {
//             if (response_ instanceof HttpResponseBase) {
//                 try {
//                     return this.processAdd(<any>response_);
//                 } catch (e) {
//                     return <Observable<string>><any>_observableThrow(e);
//                 }
//             } else
//                 return <Observable<string>><any>_observableThrow(response_);
//         }));
//     }

//     protected processAdd(response: HttpResponseBase): Observable<string> {
//         const status = response.status;
//         const responseBlob =
//             response instanceof HttpResponse ? response.body :
//             (<any>response).error instanceof Blob ? (<any>response).error : undefined;

//         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
//         if (status === 200) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             let result200: any = null;
//             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
//             result200 = resultData200 !== undefined ? resultData200 : <any>null;
//             return _observableOf(result200);
//             }));
//         } else if (status !== 200 && status !== 204) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//             }));
//         }
//         return _observableOf<string>(<any>null);
//     }

//     /**
//      * @param body (optional)
//      * @return Success
//      */
//     update(body: UpdateIncomeSourceRequest | undefined): Observable<string> {
//         let url_ = this.baseUrl + "/api/IncomeSource/Update";
//         url_ = url_.replace(/[?&]$/, "");

//         const content_ = JSON.stringify(body);

//         let options_ : any = {
//             body: content_,
//             observe: "response",
//             responseType: "blob",
//             headers: new HttpHeaders({
//                 "Content-Type": "application/json-patch+json",
//                 "Accept": "text/plain"
//             })
//         };

//         return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
//             return this.processUpdate(response_);
//         })).pipe(_observableCatch((response_: any) => {
//             if (response_ instanceof HttpResponseBase) {
//                 try {
//                     return this.processUpdate(<any>response_);
//                 } catch (e) {
//                     return <Observable<string>><any>_observableThrow(e);
//                 }
//             } else
//                 return <Observable<string>><any>_observableThrow(response_);
//         }));
//     }

//     protected processUpdate(response: HttpResponseBase): Observable<string> {
//         const status = response.status;
//         const responseBlob =
//             response instanceof HttpResponse ? response.body :
//             (<any>response).error instanceof Blob ? (<any>response).error : undefined;

//         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
//         if (status === 200) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             let result200: any = null;
//             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
//             result200 = resultData200 !== undefined ? resultData200 : <any>null;
//             return _observableOf(result200);
//             }));
//         } else if (status !== 200 && status !== 204) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//             }));
//         }
//         return _observableOf<string>(<any>null);
//     }

//     /**
//      * @param id (optional)
//      * @return Success
//      */
//     delete(id: number | undefined): Observable<string> {
//         let url_ = this.baseUrl + "/api/IncomeSource/Delete?";
//         if (id === null)
//             throw new Error("The parameter 'id' cannot be null.");
//         else if (id !== undefined)
//             url_ += "id=" + encodeURIComponent("" + id) + "&";
//         url_ = url_.replace(/[?&]$/, "");

//         let options_ : any = {
//             observe: "response",
//             responseType: "blob",
//             headers: new HttpHeaders({
//                 "Accept": "text/plain"
//             })
//         };

//         return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
//             return this.processDelete(response_);
//         })).pipe(_observableCatch((response_: any) => {
//             if (response_ instanceof HttpResponseBase) {
//                 try {
//                     return this.processDelete(<any>response_);
//                 } catch (e) {
//                     return <Observable<string>><any>_observableThrow(e);
//                 }
//             } else
//                 return <Observable<string>><any>_observableThrow(response_);
//         }));
//     }

//     protected processDelete(response: HttpResponseBase): Observable<string> {
//         const status = response.status;
//         const responseBlob =
//             response instanceof HttpResponse ? response.body :
//             (<any>response).error instanceof Blob ? (<any>response).error : undefined;

//         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
//         if (status === 200) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             let result200: any = null;
//             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
//             result200 = resultData200 !== undefined ? resultData200 : <any>null;
//             return _observableOf(result200);
//             }));
//         } else if (status !== 200 && status !== 204) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//             }));
//         }
//         return _observableOf<string>(<any>null);
//     }

//     /**
//      * @return Success
//      */
//     incomeSources(): Observable<void> {
//         let url_ = this.baseUrl + "/api/IncomeSource/income-sources";
//         url_ = url_.replace(/[?&]$/, "");

//         let options_ : any = {
//             observe: "response",
//             responseType: "blob",
//             headers: new HttpHeaders({
//             })
//         };

//         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
//             return this.processIncomeSources(response_);
//         })).pipe(_observableCatch((response_: any) => {
//             if (response_ instanceof HttpResponseBase) {
//                 try {
//                     return this.processIncomeSources(<any>response_);
//                 } catch (e) {
//                     return <Observable<void>><any>_observableThrow(e);
//                 }
//             } else
//                 return <Observable<void>><any>_observableThrow(response_);
//         }));
//     }

//     protected processIncomeSources(response: HttpResponseBase): Observable<void> {
//         const status = response.status;
//         const responseBlob =
//             response instanceof HttpResponse ? response.body :
//             (<any>response).error instanceof Blob ? (<any>response).error : undefined;

//         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
//         if (status === 200) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             return _observableOf<void>(<any>null);
//             }));
//         } else if (status !== 200 && status !== 204) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//             }));
//         }
//         return _observableOf<void>(<any>null);
//     }

//     /**
//      * @param id (optional)
//      * @return Success
//      */
//     incomeSource(id: number | undefined): Observable<void> {
//         let url_ = this.baseUrl + "/api/IncomeSource/income-source?";
//         if (id === null)
//             throw new Error("The parameter 'id' cannot be null.");
//         else if (id !== undefined)
//             url_ += "id=" + encodeURIComponent("" + id) + "&";
//         url_ = url_.replace(/[?&]$/, "");

//         let options_ : any = {
//             observe: "response",
//             responseType: "blob",
//             headers: new HttpHeaders({
//             })
//         };

//         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
//             return this.processIncomeSource(response_);
//         })).pipe(_observableCatch((response_: any) => {
//             if (response_ instanceof HttpResponseBase) {
//                 try {
//                     return this.processIncomeSource(<any>response_);
//                 } catch (e) {
//                     return <Observable<void>><any>_observableThrow(e);
//                 }
//             } else
//                 return <Observable<void>><any>_observableThrow(response_);
//         }));
//     }

//     protected processIncomeSource(response: HttpResponseBase): Observable<void> {
//         const status = response.status;
//         const responseBlob =
//             response instanceof HttpResponse ? response.body :
//             (<any>response).error instanceof Blob ? (<any>response).error : undefined;

//         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
//         if (status === 200) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             return _observableOf<void>(<any>null);
//             }));
//         } else if (status !== 200 && status !== 204) {
//             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
//             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
//             }));
//         }
//         return _observableOf<void>(<any>null);
//     }
// }

@Injectable()
export class IncomeTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddIncomeTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/IncomeType/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateIncomeTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/IncomeType/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/IncomeType/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  incomeTypes(): Observable<void> {
    let url_ = this.baseUrl + "/api/IncomeType/Income-types";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIncomeTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIncomeTypes(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIncomeTypes(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  incomeType(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/IncomeType/Income-type?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIncomeType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIncomeType(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processIncomeType(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LeadApplicationQuestionsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadApplicationQuestions | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadApplicationQuestions/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadApplicationQuestions | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadApplicationQuestions/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadApplicationQuestions/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadApplicationQuestions/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadApplicationQuestions/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LeadApplicationTypesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadApplicationType | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadApplicationTypes/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadApplicationType | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadApplicationTypes/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadApplicationTypes/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadApplicationTypes/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadApplicationTypes/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LeadAssetsDetailsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadAssetDetails | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadAssetsDetails/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadAssetDetails | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadAssetsDetails/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadAssetsDetails/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadAssetsDetails/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadAssetsDetails/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LeadAssetTypesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadAssetTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadAssetTypes/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadAssetTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadAssetTypes/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadAssetTypes/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadAssetTypes/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadAssetTypes/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LeadEmploymentDetailServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadEmploymentDetails | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadEmploymentDetail/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadEmploymentDetails | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadEmploymentDetail/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadEmploymentDetail/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadEmploymentDetail/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadEmploymentDetail/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LeadEmploymentTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadEmploymentTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadEmploymentType/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadEmploymentTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadEmploymentType/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadEmploymentType/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadEmploymentType/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadEmploymentType/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LeadIncomeTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadIncomeTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadIncomeType/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadIncomeTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadIncomeType/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadIncomeType/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadIncomeType/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadIncomeType/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LeadOwnerTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadOwnerTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadOwnerType/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadOwnerTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadOwnerType/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadOwnerType/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadOwnerType/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadOwnerType/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LeadPurchasingDetailsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadPurchasingDetail | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadPurchasingDetails/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadPurchasingDetail | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadPurchasingDetails/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadPurchasingDetails/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadPurchasingDetails/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadPurchasingDetails/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LeadQuestionAnswersServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadQuestionAnswers | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadQuestionAnswers/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadQuestionAnswers | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadQuestionAnswers/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadQuestionAnswers/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadQuestionAnswers/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadQuestionAnswers/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LeadRefinancingDetailsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadRefinancingDetails | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadRefinancingDetails/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadRefinancingDetails | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadRefinancingDetails/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadRefinancingDetails/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadRefinancingDetails/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadRefinancingDetails/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LeadRefinancingIncomeDetailsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadRefinancingIncomeDetails | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadRefinancingIncomeDetails/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateLeadRefinancingIncomeDetails | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadRefinancingIncomeDetails/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadRefinancingIncomeDetails/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadRefinancingIncomeDetails/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadRefinancingIncomeDetails/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LeadTaxTypesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadTaxTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadTaxTypes/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadTaxTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadTaxTypes/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/LeadTaxTypes/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadTaxTypes/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LeadTaxTypes/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LoanServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<LoanApplicationDto> {
    let url_ = this.baseUrl + "/api/services/app/Loan/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<LoanApplicationDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LoanApplicationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<LoanApplicationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanApplicationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanApplicationDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<LoanApplicationDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Loan/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<LoanApplicationDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<LoanApplicationDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<LoanApplicationDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanApplicationDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanApplicationDtoPagedResultDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAllCustom(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<LoanListDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Loan/GetAllCustom?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCustom(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCustom(<any>response_);
            } catch (e) {
              return <Observable<LoanListDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<LoanListDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllCustom(
    response: HttpResponseBase
  ): Observable<LoanListDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanListDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanListDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: LoanApplicationDto | undefined): Observable<LoanApplicationDto> {
    let url_ = this.baseUrl + "/api/services/app/Loan/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<LoanApplicationDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LoanApplicationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<LoanApplicationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanApplicationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanApplicationDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: LoanApplicationDto | undefined): Observable<LoanApplicationDto> {
    let url_ = this.baseUrl + "/api/services/app/Loan/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<LoanApplicationDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LoanApplicationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<LoanApplicationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanApplicationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanApplicationDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Loan/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LoanDetailServicesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<LoanDetailDto> {
    let url_ = this.baseUrl + "/api/services/app/LoanDetailServices/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<LoanDetailDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LoanDetailDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<LoanDetailDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanDetailDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanDetailDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<LoanDetailDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/LoanDetailServices/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<LoanDetailDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<LoanDetailDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<LoanDetailDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanDetailDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanDetailDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: LoanDetailDto | undefined): Observable<LoanDetailDto> {
    let url_ = this.baseUrl + "/api/services/app/LoanDetailServices/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<LoanDetailDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LoanDetailDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<LoanDetailDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanDetailDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanDetailDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: LoanDetailDto | undefined): Observable<LoanDetailDto> {
    let url_ = this.baseUrl + "/api/services/app/LoanDetailServices/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<LoanDetailDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LoanDetailDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<LoanDetailDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanDetailDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanDetailDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/LoanDetailServices/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LoanOptionHomeBuyingServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addLoanOption(body: LoanOptionHomeBuying | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/LoanOptionHomeBuying/AddLoanOption";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddLoanOption(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddLoanOption(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddLoanOption(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ManualAssetEntryServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: ManualAssetEntryDto | undefined
  ): Observable<ManualAssetEntryDto> {
    let url_ =
      this.baseUrl + "/api/services/app/ManualAssetEntryService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<ManualAssetEntryDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ManualAssetEntryDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<ManualAssetEntryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ManualAssetEntryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ManualAssetEntryDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/ManualAssetEntryService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<ManualAssetEntryDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/ManualAssetEntryService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ManualAssetEntryDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ManualAssetEntryDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<ManualAssetEntryDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ManualAssetEntryDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ManualAssetEntryDtoPagedResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<ManualAssetEntryDto> {
    let url_ = this.baseUrl + "/api/services/app/ManualAssetEntryService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<ManualAssetEntryDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ManualAssetEntryDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<ManualAssetEntryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ManualAssetEntryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ManualAssetEntryDto>(<any>null);
  }

  /**
   * @param loanApplicationId (optional)
   * @return Success
   */
  getAllByLoanApplicationId(
    loanApplicationId: number | undefined
  ): Observable<ManualAssetEntry[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/ManualAssetEntryService/GetAllByLoanApplicationId?";
    if (loanApplicationId === null)
      throw new Error("The parameter 'loanApplicationId' cannot be null.");
    else if (loanApplicationId !== undefined)
      url_ +=
        "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllByLoanApplicationId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllByLoanApplicationId(<any>response_);
            } catch (e) {
              return <Observable<ManualAssetEntry[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ManualAssetEntry[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllByLoanApplicationId(
    response: HttpResponseBase
  ): Observable<ManualAssetEntry[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(ManualAssetEntry.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ManualAssetEntry[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: ManualAssetEntryDto | undefined
  ): Observable<ManualAssetEntryDto> {
    let url_ =
      this.baseUrl + "/api/services/app/ManualAssetEntryService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<ManualAssetEntryDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ManualAssetEntryDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<ManualAssetEntryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ManualAssetEntryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ManualAssetEntryDto>(<any>null);
  }
}

@Injectable()
export class MaritalStatusServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddMaritalStatusRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/MaritalStatus/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateMaritalStatusRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/MaritalStatus/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/MaritalStatus/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  maritalStatuses(): Observable<void> {
    let url_ = this.baseUrl + "/api/MaritalStatus/Marital-Statuses";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMaritalStatuses(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMaritalStatuses(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMaritalStatuses(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  maritalStatus(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/MaritalStatus/Marital-Status?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMaritalStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMaritalStatus(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMaritalStatus(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class PropertyGiftTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLoanPropertyGiftTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-gift-type/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateLoanPropertyGiftTypeRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-gift-type/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-gift-type/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class MortgageLoanServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  propertyGiftTypes(): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-gift-types";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPropertyGiftTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPropertyGiftTypes(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPropertyGiftTypes(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  propertyGiftType(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-gift-type?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPropertyGiftType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPropertyGiftType(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPropertyGiftType(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  propertyOccupancies(): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-occupancies";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPropertyOccupancies(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPropertyOccupancies(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPropertyOccupancies(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  propertyOccupancy(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-occupancy?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPropertyOccupancy(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPropertyOccupancy(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPropertyOccupancy(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  mortgageTypes(): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/mortgage-types";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMortgageTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMortgageTypes(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMortgageTypes(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  mortgageType(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/mortgage-type?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMortgageType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMortgageType(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMortgageType(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  propertyInformationGifts(): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-information-gifts";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPropertyInformationGifts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPropertyInformationGifts(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPropertyInformationGifts(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  propertyInformationGift(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-information-gift?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPropertyInformationGift(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPropertyInformationGift(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPropertyInformationGift(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  propertyInformations(): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-informations";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPropertyInformations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPropertyInformations(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPropertyInformations(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  propertyInformation(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-information?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPropertyInformation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPropertyInformation(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPropertyInformation(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  originatorInformations(): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/originator-informations";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOriginatorInformations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOriginatorInformations(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOriginatorInformations(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  originatorInformation(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/originator-information?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOriginatorInformation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOriginatorInformation(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOriginatorInformation(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  propertyMortgageLoans(): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-mortgage-loans";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPropertyMortgageLoans(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPropertyMortgageLoans(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPropertyMortgageLoans(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  propertyMortgageLoan(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-mortgage-loan?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPropertyMortgageLoan(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPropertyMortgageLoan(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPropertyMortgageLoan(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  loanDetails(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/MortgageLoan/loan-details?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLoanDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLoanDetails(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processLoanDetails(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class PropertyOccupancyServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLoanPropertyOccupancyRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-occupancy/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateLoanPropertyOccupancyRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-occupancy/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-occupancy/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class MortgageTypeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddMortageLoanTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/mortgage-type/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateMortageLoanTypeRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/mortgage-type/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/mortgage-type/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class PropertyInformationGiftServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddLoanAndPropertyInformationGiftRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-information-gift/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateLoanAndPropertyInformationGiftRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/MortgageLoan/property-information-gift/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/MortgageLoan/property-information-gift/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class PropertyInformationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddLoanAndPropertyInformationRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-information/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateLoanAndPropertyInformationRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-information/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-information/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  otherMortgageLoans(): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/MortgageLoan/property-information/other-mortgage-loans";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOtherMortgageLoans(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOtherMortgageLoans(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOtherMortgageLoans(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  otherMortgageLoan(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/MortgageLoan/property-information/other-mortgage-loan?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOtherMortgageLoan(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOtherMortgageLoan(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processOtherMortgageLoan(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  rentalIncomes(): Observable<void> {
    let url_ =
      this.baseUrl + "/api/MortgageLoan/property-information/rental-incomes";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRentalIncomes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRentalIncomes(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRentalIncomes(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  rentalIncome(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/MortgageLoan/property-information/rental-income?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRentalIncome(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRentalIncome(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRentalIncome(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class OriginatorInformationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddLoanOriginatorInformationRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/originator-information/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateLoanOriginatorInformationRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/originator-information/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/MortgageLoan/originator-information/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class OtherMortgageLoanServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddLoanAndPropertyInformationOtherMortageLoanRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/MortgageLoan/property-information/other-mortgage-loan/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateLoanAndPropertyInformationOtherMortageLoanRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/MortgageLoan/property-information/other-mortgage-loan/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/MortgageLoan/property-information/other-mortgage-loan/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class RentalIncomeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(
    body: AddLoanAndPropertyInformationRentalIncomeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/MortgageLoan/property-information/rental-income/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateLoanAndPropertyInformationRentalIncomeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/MortgageLoan/property-information/rental-income/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/MortgageLoan/property-information/rental-income/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class PropertyMortgageLoanServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddMortageLoanOnPropertyRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-mortgage-loan/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateMortageLoanOnPropertyRequest | undefined
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/MortgageLoan/property-mortgage-loan/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/MortgageLoan/property-mortgage-loan/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class PersonalDetailServicesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<PersonalInformationDto> {
    let url_ = this.baseUrl + "/api/services/app/PersonalDetailServices/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<PersonalInformationDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PersonalInformationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<PersonalInformationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PersonalInformationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PersonalInformationDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PersonalInformationDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/PersonalDetailServices/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PersonalInformationDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PersonalInformationDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<PersonalInformationDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PersonalInformationDtoPagedResultDto.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PersonalInformationDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: PersonalInformationDto | undefined
  ): Observable<PersonalInformationDto> {
    let url_ = this.baseUrl + "/api/services/app/PersonalDetailServices/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<PersonalInformationDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PersonalInformationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<PersonalInformationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PersonalInformationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PersonalInformationDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: PersonalInformationDto | undefined
  ): Observable<PersonalInformationDto> {
    let url_ = this.baseUrl + "/api/services/app/PersonalDetailServices/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<PersonalInformationDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PersonalInformationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<PersonalInformationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PersonalInformationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PersonalInformationDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/PersonalDetailServices/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class RefinanceHomeBuyingServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addRefinance(body: RefinanceHomeBuyingDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/RefinanceHomeBuying/AddRefinance";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddRefinance(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddRefinance(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddRefinance(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class RefinanceHomeBuyingServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: RefinanceHomeBuyingDto | undefined
  ): Observable<RefinanceHomeBuyingDto> {
    let url_ =
      this.baseUrl + "/api/services/app/RefinanceHomeBuyingService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<RefinanceHomeBuyingDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RefinanceHomeBuyingDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<RefinanceHomeBuyingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RefinanceHomeBuyingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RefinanceHomeBuyingDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/RefinanceHomeBuyingService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<RefinanceHomeBuyingDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/RefinanceHomeBuyingService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<RefinanceHomeBuyingDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RefinanceHomeBuyingDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<RefinanceHomeBuyingDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RefinanceHomeBuyingDtoPagedResultDto.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RefinanceHomeBuyingDtoPagedResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<RefinanceHomeBuyingDto> {
    let url_ =
      this.baseUrl + "/api/services/app/RefinanceHomeBuyingService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<RefinanceHomeBuyingDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RefinanceHomeBuyingDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<RefinanceHomeBuyingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RefinanceHomeBuyingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RefinanceHomeBuyingDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: RefinanceHomeBuyingDto | undefined
  ): Observable<RefinanceHomeBuyingDto> {
    let url_ =
      this.baseUrl + "/api/services/app/RefinanceHomeBuyingService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<RefinanceHomeBuyingDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RefinanceHomeBuyingDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<RefinanceHomeBuyingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RefinanceHomeBuyingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RefinanceHomeBuyingDto>(<any>null);
  }
}

@Injectable()
export class RefinanceLoanOptionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addRefinanceLoanOption(
    body: RefinanceLoanOption | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/RefinanceLoanOption/AddRefinanceLoanOption";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddRefinanceLoanOption(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddRefinanceLoanOption(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddRefinanceLoanOption(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class RoleServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateRoleDto | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<RoleDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoleDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDto>(<any>null);
  }

  /**
   * @param permission (optional)
   * @return Success
   */
  getRoles(
    permission: string | undefined
  ): Observable<RoleListDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
    if (permission === null)
      throw new Error("The parameter 'permission' cannot be null.");
    else if (permission !== undefined)
      url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoles(<any>response_);
            } catch (e) {
              return <Observable<RoleListDtoListResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RoleListDtoListResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetRoles(
    response: HttpResponseBase
  ): Observable<RoleListDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleListDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleListDtoListResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: RoleDto | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<RoleDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoleDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllPermissions(): Observable<PermissionDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllPermissions(<any>response_);
            } catch (e) {
              return <Observable<PermissionDtoListResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PermissionDtoListResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllPermissions(
    response: HttpResponseBase
  ): Observable<PermissionDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PermissionDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PermissionDtoListResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoleForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoleForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetRoleForEditOutput>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<GetRoleForEditOutput>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetRoleForEdit(
    response: HttpResponseBase
  ): Observable<GetRoleForEditOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRoleForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GetRoleForEditOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<RoleDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoleDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<RoleDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<RoleDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RoleDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<RoleDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDtoPagedResultDto>(<any>null);
  }
}

@Injectable()
export class SessionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
    let url_ =
      this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCurrentLoginInformations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCurrentLoginInformations(<any>response_);
            } catch (e) {
              return <Observable<GetCurrentLoginInformationsOutput>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<GetCurrentLoginInformationsOutput>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetCurrentLoginInformations(
    response: HttpResponseBase
  ): Observable<GetCurrentLoginInformationsOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
  }
}

@Injectable()
export class SiteSettingServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  all(
    body: PagedLoanApplicationResultRequestDto | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/SiteSetting/All";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class IndexServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  id(id: number): Observable<void> {
    let url_ = this.baseUrl + "/api/SiteSetting/Index/id/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processId(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processId(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class SiteSettingServicesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: SiteSettingDto | undefined): Observable<SiteSettingDto> {
    let url_ = this.baseUrl + "/api/services/app/SiteSettingServices/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<SiteSettingDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<SiteSettingDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<SiteSettingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SiteSettingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SiteSettingDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/SiteSettingServices/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<SiteSettingDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/SiteSettingServices/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<SiteSettingDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<SiteSettingDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<SiteSettingDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SiteSettingDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SiteSettingDtoPagedResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<SiteSettingDto> {
    let url_ = this.baseUrl + "/api/services/app/SiteSettingServices/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<SiteSettingDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<SiteSettingDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<SiteSettingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SiteSettingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SiteSettingDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: SiteSettingDto | undefined): Observable<SiteSettingDto> {
    let url_ = this.baseUrl + "/api/services/app/SiteSettingServices/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<SiteSettingDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<SiteSettingDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<SiteSettingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SiteSettingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SiteSettingDto>(<any>null);
  }
}

@Injectable()
export class StateServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddStateRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/State/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateStateRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/State/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/State/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  states(): Observable<void> {
    let url_ = this.baseUrl + "/api/State/states";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processStates(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processStates(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processStates(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  state(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/State/State?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processState(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processState(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processState(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class TenantServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateTenantDto | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<TenantDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<TenantDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TenantDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<TenantDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<TenantDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TenantDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param isActive (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    isActive: boolean | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<TenantDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (isActive === null)
      throw new Error("The parameter 'isActive' cannot be null.");
    else if (isActive !== undefined)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<TenantDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<TenantDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<TenantDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TenantDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: TenantDto | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<TenantDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<TenantDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TenantDto>(<any>null);
  }
}

@Injectable()
export class TokenAuthServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  authenticate(
    body: AuthenticateModel | undefined
  ): Observable<AuthenticateResultModel> {
    let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAuthenticate(<any>response_);
            } catch (e) {
              return <Observable<AuthenticateResultModel>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AuthenticateResultModel>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processAuthenticate(
    response: HttpResponseBase
  ): Observable<AuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AuthenticateResultModel>(<any>null);
  }

  /**
   * @return Success
   */
  getExternalAuthenticationProviders(): Observable<
    ExternalLoginProviderInfoModel[]
  > {
    let url_ =
      this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExternalAuthenticationProviders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExternalAuthenticationProviders(
                <any>response_
              );
            } catch (e) {
              return <Observable<ExternalLoginProviderInfoModel[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ExternalLoginProviderInfoModel[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetExternalAuthenticationProviders(
    response: HttpResponseBase
  ): Observable<ExternalLoginProviderInfoModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(ExternalLoginProviderInfoModel.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  externalAuthenticate(
    body: ExternalAuthenticateModel | undefined
  ): Observable<ExternalAuthenticateResultModel> {
    let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExternalAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExternalAuthenticate(<any>response_);
            } catch (e) {
              return <Observable<ExternalAuthenticateResultModel>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ExternalAuthenticateResultModel>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processExternalAuthenticate(
    response: HttpResponseBase
  ): Observable<ExternalAuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExternalAuthenticateResultModel>(<any>null);
  }
}

@Injectable()
export class UniformResidentialLoanServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: LoanApplicationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/UniformResidentialLoan/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/UniformResidentialLoan/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getAll(
    body: PagedLoanApplicationResultRequestDto | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/UniformResidentialLoan/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  createPdfNew(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/UniformResidentialLoan/CreatePdfNew?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreatePdfNew(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreatePdfNew(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreatePdfNew(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  createPdf(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/UniformResidentialLoan/CreatePdf?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreatePdf(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreatePdf(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreatePdf(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  downloadPdf(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/UniformResidentialLoan/DownloadPdf?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDownloadPdf(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDownloadPdf(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDownloadPdf(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  testCredco(body: PersonalInformationDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/UniformResidentialLoan/TestCredco";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTestCredco(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTestCredco(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processTestCredco(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class UserServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateUserDto | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<UserDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<UserDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UserDto | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<UserDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<UserDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getRoles(): Observable<RoleDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoles(<any>response_);
            } catch (e) {
              return <Observable<RoleDtoListResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RoleDtoListResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetRoles(
    response: HttpResponseBase
  ): Observable<RoleDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDtoListResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeLanguage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeLanguage(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangeLanguage(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePassword(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangePassword(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPassword(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processResetPassword(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<UserDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<UserDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param isActive (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    isActive: boolean | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<UserDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (isActive === null)
      throw new Error("The parameter 'isActive' cannot be null.");
    else if (isActive !== undefined)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UserDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UserDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UserDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserDtoPagedResultDto>(<any>null);
  }
}

export class AddAccountTypeRequest implements IAddAccountTypeRequest {
  financialAccountType1: string | undefined;

  constructor(data?: IAddAccountTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialAccountType1 = _data["financialAccountType1"];
    }
  }

  static fromJS(data: any): AddAccountTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddAccountTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialAccountType1"] = this.financialAccountType1;
    return data;
  }

  clone(): AddAccountTypeRequest {
    const json = this.toJSON();
    let result = new AddAccountTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddAccountTypeRequest {
  financialAccountType1: string | undefined;
}

export class AddAdditionalEmployementIncomeDetailRequest
  implements IAddAdditionalEmployementIncomeDetailRequest {
  applicationAdditionalEmployementDetails: number;
  incomeTypeId: number;
  amount: number | undefined;

  constructor(data?: IAddAdditionalEmployementIncomeDetailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationAdditionalEmployementDetails =
        _data["applicationAdditionalEmployementDetails"];
      this.incomeTypeId = _data["incomeTypeId"];
      this.amount = _data["amount"];
    }
  }

  static fromJS(data: any): AddAdditionalEmployementIncomeDetailRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddAdditionalEmployementIncomeDetailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationAdditionalEmployementDetails"
    ] = this.applicationAdditionalEmployementDetails;
    data["incomeTypeId"] = this.incomeTypeId;
    data["amount"] = this.amount;
    return data;
  }

  clone(): AddAdditionalEmployementIncomeDetailRequest {
    const json = this.toJSON();
    let result = new AddAdditionalEmployementIncomeDetailRequest();
    result.init(json);
    return result;
  }
}

export interface IAddAdditionalEmployementIncomeDetailRequest {
  applicationAdditionalEmployementDetails: number;
  incomeTypeId: number;
  amount: number | undefined;
}

export class AddAdditionalEmploymentDetailRequest
  implements IAddAdditionalEmploymentDetailRequest {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName: string | undefined;
  phone: string | undefined;
  street: string | undefined;
  unit: string | undefined;
  zip: string | undefined;
  countryId: number;
  stateId: number;
  cityId: number;
  positionTitle: string | undefined;
  startDate: moment.Moment | undefined;
  workingYears: number | undefined;
  workingMonths: number | undefined;
  isEmployedBySomeone: number | undefined;
  isSelfEmployed: number | undefined;
  isOwnershipLessThan25: number | undefined;
  monthlyIncome: number | undefined;

  constructor(data?: IAddAdditionalEmploymentDetailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.employerBusinessName = _data["employerBusinessName"];
      this.phone = _data["phone"];
      this.street = _data["street"];
      this.unit = _data["unit"];
      this.zip = _data["zip"];
      this.countryId = _data["countryId"];
      this.stateId = _data["stateId"];
      this.cityId = _data["cityId"];
      this.positionTitle = _data["positionTitle"];
      this.startDate = _data["startDate"]
        ? moment(_data["startDate"].toString())
        : <any>undefined;
      this.workingYears = _data["workingYears"];
      this.workingMonths = _data["workingMonths"];
      this.isEmployedBySomeone = _data["isEmployedBySomeone"];
      this.isSelfEmployed = _data["isSelfEmployed"];
      this.isOwnershipLessThan25 = _data["isOwnershipLessThan25"];
      this.monthlyIncome = _data["monthlyIncome"];
    }
  }

  static fromJS(data: any): AddAdditionalEmploymentDetailRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddAdditionalEmploymentDetailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["employerBusinessName"] = this.employerBusinessName;
    data["phone"] = this.phone;
    data["street"] = this.street;
    data["unit"] = this.unit;
    data["zip"] = this.zip;
    data["countryId"] = this.countryId;
    data["stateId"] = this.stateId;
    data["cityId"] = this.cityId;
    data["positionTitle"] = this.positionTitle;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["workingYears"] = this.workingYears;
    data["workingMonths"] = this.workingMonths;
    data["isEmployedBySomeone"] = this.isEmployedBySomeone;
    data["isSelfEmployed"] = this.isSelfEmployed;
    data["isOwnershipLessThan25"] = this.isOwnershipLessThan25;
    data["monthlyIncome"] = this.monthlyIncome;
    return data;
  }

  clone(): AddAdditionalEmploymentDetailRequest {
    const json = this.toJSON();
    let result = new AddAdditionalEmploymentDetailRequest();
    result.init(json);
    return result;
  }
}

export interface IAddAdditionalEmploymentDetailRequest {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName: string | undefined;
  phone: string | undefined;
  street: string | undefined;
  unit: string | undefined;
  zip: string | undefined;
  countryId: number;
  stateId: number;
  cityId: number;
  positionTitle: string | undefined;
  startDate: moment.Moment | undefined;
  workingYears: number | undefined;
  workingMonths: number | undefined;
  isEmployedBySomeone: number | undefined;
  isSelfEmployed: number | undefined;
  isOwnershipLessThan25: number | undefined;
  monthlyIncome: number | undefined;
}

export class AddAdminDisclosure implements IAddAdminDisclosure {
  title: string | undefined;

  constructor(data?: IAddAdminDisclosure) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["title"];
    }
  }

  static fromJS(data: any): AddAdminDisclosure {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminDisclosure();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["title"] = this.title;
    return data;
  }

  clone(): AddAdminDisclosure {
    const json = this.toJSON();
    let result = new AddAdminDisclosure();
    result.init(json);
    return result;
  }
}

export interface IAddAdminDisclosure {
  title: string | undefined;
}

export class AddAdminLoanApplicationDocument
  implements IAddAdminLoanApplicationDocument {
  loanId: number;
  disclosureId: number;
  userId: number;
  updatedOn: moment.Moment | undefined;
  documentPath: string | undefined;

  constructor(data?: IAddAdminLoanApplicationDocument) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanId = _data["loanId"];
      this.disclosureId = _data["disclosureId"];
      this.userId = _data["userId"];
      this.updatedOn = _data["updatedOn"]
        ? moment(_data["updatedOn"].toString())
        : <any>undefined;
      this.documentPath = _data["documentPath"];
    }
  }

  static fromJS(data: any): AddAdminLoanApplicationDocument {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminLoanApplicationDocument();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanId"] = this.loanId;
    data["disclosureId"] = this.disclosureId;
    data["userId"] = this.userId;
    data["updatedOn"] = this.updatedOn
      ? this.updatedOn.toISOString()
      : <any>undefined;
    data["documentPath"] = this.documentPath;
    return data;
  }

  clone(): AddAdminLoanApplicationDocument {
    const json = this.toJSON();
    let result = new AddAdminLoanApplicationDocument();
    result.init(json);
    return result;
  }
}

export interface IAddAdminLoanApplicationDocument {
  loanId: number;
  disclosureId: number;
  userId: number;
  updatedOn: moment.Moment | undefined;
  documentPath: string | undefined;
}

export class AddAdminLoanDetail implements IAddAdminLoanDetail {
  userId: number;
  loanApplicationId: number;
  loanNo: string | undefined;
  mortageConsultant: string | undefined;
  nmlsId: string | undefined;
  borrowerName: string | undefined;
  propertyAddress: string | undefined;
  loanProgramId: number;
  loanAmount: number | undefined;
  loanPurpose: string | undefined;
  interestRate: number | undefined;
  applicationDate: moment.Moment | undefined;
  rateLockDate: moment.Moment | undefined;
  rateLockExpirationDate: moment.Moment | undefined;

  constructor(data?: IAddAdminLoanDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data["userId"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.loanNo = _data["loanNo"];
      this.mortageConsultant = _data["mortageConsultant"];
      this.nmlsId = _data["nmlsId"];
      this.borrowerName = _data["borrowerName"];
      this.propertyAddress = _data["propertyAddress"];
      this.loanProgramId = _data["loanProgramId"];
      this.loanAmount = _data["loanAmount"];
      this.loanPurpose = _data["loanPurpose"];
      this.interestRate = _data["interestRate"];
      this.applicationDate = _data["applicationDate"]
        ? moment(_data["applicationDate"].toString())
        : <any>undefined;
      this.rateLockDate = _data["rateLockDate"]
        ? moment(_data["rateLockDate"].toString())
        : <any>undefined;
      this.rateLockExpirationDate = _data["rateLockExpirationDate"]
        ? moment(_data["rateLockExpirationDate"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddAdminLoanDetail {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminLoanDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userId"] = this.userId;
    data["loanApplicationId"] = this.loanApplicationId;
    data["loanNo"] = this.loanNo;
    data["mortageConsultant"] = this.mortageConsultant;
    data["nmlsId"] = this.nmlsId;
    data["borrowerName"] = this.borrowerName;
    data["propertyAddress"] = this.propertyAddress;
    data["loanProgramId"] = this.loanProgramId;
    data["loanAmount"] = this.loanAmount;
    data["loanPurpose"] = this.loanPurpose;
    data["interestRate"] = this.interestRate;
    data["applicationDate"] = this.applicationDate
      ? this.applicationDate.toISOString()
      : <any>undefined;
    data["rateLockDate"] = this.rateLockDate
      ? this.rateLockDate.toISOString()
      : <any>undefined;
    data["rateLockExpirationDate"] = this.rateLockExpirationDate
      ? this.rateLockExpirationDate.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): AddAdminLoanDetail {
    const json = this.toJSON();
    let result = new AddAdminLoanDetail();
    result.init(json);
    return result;
  }
}

export interface IAddAdminLoanDetail {
  userId: number;
  loanApplicationId: number;
  loanNo: string | undefined;
  mortageConsultant: string | undefined;
  nmlsId: string | undefined;
  borrowerName: string | undefined;
  propertyAddress: string | undefined;
  loanProgramId: number;
  loanAmount: number | undefined;
  loanPurpose: string | undefined;
  interestRate: number | undefined;
  applicationDate: moment.Moment | undefined;
  rateLockDate: moment.Moment | undefined;
  rateLockExpirationDate: moment.Moment | undefined;
}

export class AddAdminLoanProgram implements IAddAdminLoanProgram {
  loanProgram: string | undefined;

  constructor(data?: IAddAdminLoanProgram) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanProgram = _data["loanProgram"];
    }
  }

  static fromJS(data: any): AddAdminLoanProgram {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminLoanProgram();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanProgram"] = this.loanProgram;
    return data;
  }

  clone(): AddAdminLoanProgram {
    const json = this.toJSON();
    let result = new AddAdminLoanProgram();
    result.init(json);
    return result;
  }
}

export interface IAddAdminLoanProgram {
  loanProgram: string | undefined;
}

export class AddAdminLoanStatus implements IAddAdminLoanStatus {
  status: string | undefined;

  constructor(data?: IAddAdminLoanStatus) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.status = _data["status"];
    }
  }

  static fromJS(data: any): AddAdminLoanStatus {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminLoanStatus();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["status"] = this.status;
    return data;
  }

  clone(): AddAdminLoanStatus {
    const json = this.toJSON();
    let result = new AddAdminLoanStatus();
    result.init(json);
    return result;
  }
}

export interface IAddAdminLoanStatus {
  status: string | undefined;
}

export class AddAdminLoanSummaryStatus implements IAddAdminLoanSummaryStatus {
  loanId: number;
  statusId: number;
  updatedOn: moment.Moment | undefined;

  constructor(data?: IAddAdminLoanSummaryStatus) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanId = _data["loanId"];
      this.statusId = _data["statusId"];
      this.updatedOn = _data["updatedOn"]
        ? moment(_data["updatedOn"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddAdminLoanSummaryStatus {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminLoanSummaryStatus();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanId"] = this.loanId;
    data["statusId"] = this.statusId;
    data["updatedOn"] = this.updatedOn
      ? this.updatedOn.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): AddAdminLoanSummaryStatus {
    const json = this.toJSON();
    let result = new AddAdminLoanSummaryStatus();
    result.init(json);
    return result;
  }
}

export interface IAddAdminLoanSummaryStatus {
  loanId: number;
  statusId: number;
  updatedOn: moment.Moment | undefined;
}

export class AddAdminNotificationType implements IAddAdminNotificationType {
  type: string | undefined;

  constructor(data?: IAddAdminNotificationType) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
    }
  }

  static fromJS(data: any): AddAdminNotificationType {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminNotificationType();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["type"] = this.type;
    return data;
  }

  clone(): AddAdminNotificationType {
    const json = this.toJSON();
    let result = new AddAdminNotificationType();
    result.init(json);
    return result;
  }
}

export interface IAddAdminNotificationType {
  type: string | undefined;
}

export class AddAdminUser implements IAddAdminUser {
  userName: string | undefined;
  email: string | undefined;
  password: string | undefined;
  isActive: number | undefined;
  createdOn: moment.Moment | undefined;

  constructor(data?: IAddAdminUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data["userName"];
      this.email = _data["email"];
      this.password = _data["password"];
      this.isActive = _data["isActive"];
      this.createdOn = _data["createdOn"]
        ? moment(_data["createdOn"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddAdminUser {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminUser();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userName"] = this.userName;
    data["email"] = this.email;
    data["password"] = this.password;
    data["isActive"] = this.isActive;
    data["createdOn"] = this.createdOn
      ? this.createdOn.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): AddAdminUser {
    const json = this.toJSON();
    let result = new AddAdminUser();
    result.init(json);
    return result;
  }
}

export interface IAddAdminUser {
  userName: string | undefined;
  email: string | undefined;
  password: string | undefined;
  isActive: number | undefined;
  createdOn: moment.Moment | undefined;
}

export class AddAdminUserEnabledDevice implements IAddAdminUserEnabledDevice {
  userId: number;
  deviceId: string | undefined;
  bioMetricData: string | undefined;
  isEnabled: number | undefined;

  constructor(data?: IAddAdminUserEnabledDevice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data["userId"];
      this.deviceId = _data["deviceId"];
      this.bioMetricData = _data["bioMetricData"];
      this.isEnabled = _data["isEnabled"];
    }
  }

  static fromJS(data: any): AddAdminUserEnabledDevice {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminUserEnabledDevice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userId"] = this.userId;
    data["deviceId"] = this.deviceId;
    data["bioMetricData"] = this.bioMetricData;
    data["isEnabled"] = this.isEnabled;
    return data;
  }

  clone(): AddAdminUserEnabledDevice {
    const json = this.toJSON();
    let result = new AddAdminUserEnabledDevice();
    result.init(json);
    return result;
  }
}

export interface IAddAdminUserEnabledDevice {
  userId: number;
  deviceId: string | undefined;
  bioMetricData: string | undefined;
  isEnabled: number | undefined;
}

export class AddAdminUserNotification implements IAddAdminUserNotification {
  userId: number;
  notificationTypeId: number;
  date: moment.Moment | undefined;
  subject: string | undefined;
  content: string | undefined;
  isSeen: number | undefined;

  constructor(data?: IAddAdminUserNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data["userId"];
      this.notificationTypeId = _data["notificationTypeId"];
      this.date = _data["date"]
        ? moment(_data["date"].toString())
        : <any>undefined;
      this.subject = _data["subject"];
      this.content = _data["content"];
      this.isSeen = _data["isSeen"];
    }
  }

  static fromJS(data: any): AddAdminUserNotification {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminUserNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userId"] = this.userId;
    data["notificationTypeId"] = this.notificationTypeId;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["subject"] = this.subject;
    data["content"] = this.content;
    data["isSeen"] = this.isSeen;
    return data;
  }

  clone(): AddAdminUserNotification {
    const json = this.toJSON();
    let result = new AddAdminUserNotification();
    result.init(json);
    return result;
  }
}

export interface IAddAdminUserNotification {
  userId: number;
  notificationTypeId: number;
  date: moment.Moment | undefined;
  subject: string | undefined;
  content: string | undefined;
  isSeen: number | undefined;
}

export class AddApplicationDeclarationQuestionRequest
  implements IAddApplicationDeclarationQuestionRequest {
  applicationPersonalInformationId: number | undefined;
  declarationQuestionId: number | undefined;
  yesNo: number | undefined;
  description5a: string | undefined;

  constructor(data?: IAddApplicationDeclarationQuestionRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.declarationQuestionId = _data["declarationQuestionId"];
      this.yesNo = _data["yesNo"];
      this.description5a = _data["description5a"];
    }
  }

  static fromJS(data: any): AddApplicationDeclarationQuestionRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddApplicationDeclarationQuestionRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["declarationQuestionId"] = this.declarationQuestionId;
    data["yesNo"] = this.yesNo;
    data["description5a"] = this.description5a;
    return data;
  }

  clone(): AddApplicationDeclarationQuestionRequest {
    const json = this.toJSON();
    let result = new AddApplicationDeclarationQuestionRequest();
    result.init(json);
    return result;
  }
}

export interface IAddApplicationDeclarationQuestionRequest {
  applicationPersonalInformationId: number | undefined;
  declarationQuestionId: number | undefined;
  yesNo: number | undefined;
  description5a: string | undefined;
}

export class AddApplicationFinancialAssetRequest
  implements IAddApplicationFinancialAssetRequest {
  applicationPersonalInformationId: number | undefined;
  financialAccountTypeId2a1: number;
  financialInstitution2a2: string | undefined;
  accountNumber2a3: string | undefined;
  value2a4: number | undefined;

  constructor(data?: IAddApplicationFinancialAssetRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.financialAccountTypeId2a1 = _data["financialAccountTypeId2a1"];
      this.financialInstitution2a2 = _data["financialInstitution2a2"];
      this.accountNumber2a3 = _data["accountNumber2a3"];
      this.value2a4 = _data["value2a4"];
    }
  }

  static fromJS(data: any): AddApplicationFinancialAssetRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddApplicationFinancialAssetRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["financialAccountTypeId2a1"] = this.financialAccountTypeId2a1;
    data["financialInstitution2a2"] = this.financialInstitution2a2;
    data["accountNumber2a3"] = this.accountNumber2a3;
    data["value2a4"] = this.value2a4;
    return data;
  }

  clone(): AddApplicationFinancialAssetRequest {
    const json = this.toJSON();
    let result = new AddApplicationFinancialAssetRequest();
    result.init(json);
    return result;
  }
}

export interface IAddApplicationFinancialAssetRequest {
  applicationPersonalInformationId: number | undefined;
  financialAccountTypeId2a1: number;
  financialInstitution2a2: string | undefined;
  accountNumber2a3: string | undefined;
  value2a4: number | undefined;
}

export class AddApplicationFinancialLiabilityRequest
  implements IAddApplicationFinancialLiabilityRequest {
  applicationPersonalInformationId: number | undefined;
  financialLaibilitiesType2c1: number;
  companyName2c2: string | undefined;
  accountNumber2c3: string | undefined;
  unpaidBalance2c4: number | undefined;
  paidOff2c5: number | undefined;
  monthlyValue2c6: number | undefined;

  constructor(data?: IAddApplicationFinancialLiabilityRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.financialLaibilitiesType2c1 = _data["financialLaibilitiesType2c1"];
      this.companyName2c2 = _data["companyName2c2"];
      this.accountNumber2c3 = _data["accountNumber2c3"];
      this.unpaidBalance2c4 = _data["unpaidBalance2c4"];
      this.paidOff2c5 = _data["paidOff2c5"];
      this.monthlyValue2c6 = _data["monthlyValue2c6"];
    }
  }

  static fromJS(data: any): AddApplicationFinancialLiabilityRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddApplicationFinancialLiabilityRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["financialLaibilitiesType2c1"] = this.financialLaibilitiesType2c1;
    data["companyName2c2"] = this.companyName2c2;
    data["accountNumber2c3"] = this.accountNumber2c3;
    data["unpaidBalance2c4"] = this.unpaidBalance2c4;
    data["paidOff2c5"] = this.paidOff2c5;
    data["monthlyValue2c6"] = this.monthlyValue2c6;
    return data;
  }

  clone(): AddApplicationFinancialLiabilityRequest {
    const json = this.toJSON();
    let result = new AddApplicationFinancialLiabilityRequest();
    result.init(json);
    return result;
  }
}

export interface IAddApplicationFinancialLiabilityRequest {
  applicationPersonalInformationId: number | undefined;
  financialLaibilitiesType2c1: number;
  companyName2c2: string | undefined;
  accountNumber2c3: string | undefined;
  unpaidBalance2c4: number | undefined;
  paidOff2c5: number | undefined;
  monthlyValue2c6: number | undefined;
}

export class AddApplicationFinancialOtherAssetRequest
  implements IAddApplicationFinancialOtherAssetRequest {
  applicationPersonalInformationId: number | undefined;
  financialAssetsTypesId2b1: number;
  value2b2: number | undefined;

  constructor(data?: IAddApplicationFinancialOtherAssetRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.financialAssetsTypesId2b1 = _data["financialAssetsTypesId2b1"];
      this.value2b2 = _data["value2b2"];
    }
  }

  static fromJS(data: any): AddApplicationFinancialOtherAssetRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddApplicationFinancialOtherAssetRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["financialAssetsTypesId2b1"] = this.financialAssetsTypesId2b1;
    data["value2b2"] = this.value2b2;
    return data;
  }

  clone(): AddApplicationFinancialOtherAssetRequest {
    const json = this.toJSON();
    let result = new AddApplicationFinancialOtherAssetRequest();
    result.init(json);
    return result;
  }
}

export interface IAddApplicationFinancialOtherAssetRequest {
  applicationPersonalInformationId: number | undefined;
  financialAssetsTypesId2b1: number;
  value2b2: number | undefined;
}

export class AddApplicationFinancialOtherLaibilityRequest
  implements IAddApplicationFinancialOtherLaibilityRequest {
  applicationPersonalInformationId: number | undefined;
  financialOtherLaibilitiesTypeId2d1: number;
  monthlyPayment2d2: number | undefined;

  constructor(data?: IAddApplicationFinancialOtherLaibilityRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.financialOtherLaibilitiesTypeId2d1 =
        _data["financialOtherLaibilitiesTypeId2d1"];
      this.monthlyPayment2d2 = _data["monthlyPayment2d2"];
    }
  }

  static fromJS(data: any): AddApplicationFinancialOtherLaibilityRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddApplicationFinancialOtherLaibilityRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data[
      "financialOtherLaibilitiesTypeId2d1"
    ] = this.financialOtherLaibilitiesTypeId2d1;
    data["monthlyPayment2d2"] = this.monthlyPayment2d2;
    return data;
  }

  clone(): AddApplicationFinancialOtherLaibilityRequest {
    const json = this.toJSON();
    let result = new AddApplicationFinancialOtherLaibilityRequest();
    result.init(json);
    return result;
  }
}

export interface IAddApplicationFinancialOtherLaibilityRequest {
  applicationPersonalInformationId: number | undefined;
  financialOtherLaibilitiesTypeId2d1: number;
  monthlyPayment2d2: number | undefined;
}

export class AddApplicationIncomeSourceRequest
  implements IAddApplicationIncomeSourceRequest {
  applicationPersonalInformationId: number | undefined;
  incomeSourceId1e1: number;
  amount1e2: number | undefined;

  constructor(data?: IAddApplicationIncomeSourceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.incomeSourceId1e1 = _data["incomeSourceId1e1"];
      this.amount1e2 = _data["amount1e2"];
    }
  }

  static fromJS(data: any): AddApplicationIncomeSourceRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddApplicationIncomeSourceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["incomeSourceId1e1"] = this.incomeSourceId1e1;
    data["amount1e2"] = this.amount1e2;
    return data;
  }

  clone(): AddApplicationIncomeSourceRequest {
    const json = this.toJSON();
    let result = new AddApplicationIncomeSourceRequest();
    result.init(json);
    return result;
  }
}

export interface IAddApplicationIncomeSourceRequest {
  applicationPersonalInformationId: number | undefined;
  incomeSourceId1e1: number;
  amount1e2: number | undefined;
}

export class AddCitizenshipTypeRequest implements IAddCitizenshipTypeRequest {
  citizenshipType1: string | undefined;

  constructor(data?: IAddCitizenshipTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.citizenshipType1 = _data["citizenshipType1"];
    }
  }

  static fromJS(data: any): AddCitizenshipTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddCitizenshipTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["citizenshipType1"] = this.citizenshipType1;
    return data;
  }

  clone(): AddCitizenshipTypeRequest {
    const json = this.toJSON();
    let result = new AddCitizenshipTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddCitizenshipTypeRequest {
  citizenshipType1: string | undefined;
}

export class AddCityRequest implements IAddCityRequest {
  stateId: number;
  cityName: string | undefined;

  constructor(data?: IAddCityRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.stateId = _data["stateId"];
      this.cityName = _data["cityName"];
    }
  }

  static fromJS(data: any): AddCityRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddCityRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["stateId"] = this.stateId;
    data["cityName"] = this.cityName;
    return data;
  }

  clone(): AddCityRequest {
    const json = this.toJSON();
    let result = new AddCityRequest();
    result.init(json);
    return result;
  }
}

export interface IAddCityRequest {
  stateId: number;
  cityName: string | undefined;
}

export class AddCountryRequest implements IAddCountryRequest {
  countryName: string | undefined;

  constructor(data?: IAddCountryRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.countryName = _data["countryName"];
    }
  }

  static fromJS(data: any): AddCountryRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddCountryRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["countryName"] = this.countryName;
    return data;
  }

  clone(): AddCountryRequest {
    const json = this.toJSON();
    let result = new AddCountryRequest();
    result.init(json);
    return result;
  }
}

export interface IAddCountryRequest {
  countryName: string | undefined;
}

export class AddCreditTypeRequest implements IAddCreditTypeRequest {
  creditType1: string | undefined;

  constructor(data?: IAddCreditTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.creditType1 = _data["creditType1"];
    }
  }

  static fromJS(data: any): AddCreditTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddCreditTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["creditType1"] = this.creditType1;
    return data;
  }

  clone(): AddCreditTypeRequest {
    const json = this.toJSON();
    let result = new AddCreditTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddCreditTypeRequest {
  creditType1: string | undefined;
}

export class AddDeclarationCategoryRequest
  implements IAddDeclarationCategoryRequest {
  declarationCategory1: string | undefined;

  constructor(data?: IAddDeclarationCategoryRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationCategory1 = _data["declarationCategory1"];
    }
  }

  static fromJS(data: any): AddDeclarationCategoryRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddDeclarationCategoryRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationCategory1"] = this.declarationCategory1;
    return data;
  }

  clone(): AddDeclarationCategoryRequest {
    const json = this.toJSON();
    let result = new AddDeclarationCategoryRequest();
    result.init(json);
    return result;
  }
}

export interface IAddDeclarationCategoryRequest {
  declarationCategory1: string | undefined;
}

export class AddDeclarationQuestionRequest
  implements IAddDeclarationQuestionRequest {
  declarationCategoryId: number | undefined;
  parentQuestionId: number | undefined;
  question: string | undefined;
  isActive: number | undefined;

  constructor(data?: IAddDeclarationQuestionRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationCategoryId = _data["declarationCategoryId"];
      this.parentQuestionId = _data["parentQuestionId"];
      this.question = _data["question"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): AddDeclarationQuestionRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddDeclarationQuestionRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationCategoryId"] = this.declarationCategoryId;
    data["parentQuestionId"] = this.parentQuestionId;
    data["question"] = this.question;
    data["isActive"] = this.isActive;
    return data;
  }

  clone(): AddDeclarationQuestionRequest {
    const json = this.toJSON();
    let result = new AddDeclarationQuestionRequest();
    result.init(json);
    return result;
  }
}

export interface IAddDeclarationQuestionRequest {
  declarationCategoryId: number | undefined;
  parentQuestionId: number | undefined;
  question: string | undefined;
  isActive: number | undefined;
}

export class AddDemographicInfoSourceRequest
  implements IAddDemographicInfoSourceRequest {
  value: string | undefined;

  constructor(data?: IAddDemographicInfoSourceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): AddDemographicInfoSourceRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddDemographicInfoSourceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value;
    return data;
  }

  clone(): AddDemographicInfoSourceRequest {
    const json = this.toJSON();
    let result = new AddDemographicInfoSourceRequest();
    result.init(json);
    return result;
  }
}

export interface IAddDemographicInfoSourceRequest {
  value: string | undefined;
}

export class AddDemographicInformationRequest
  implements IAddDemographicInformationRequest {
  applicationPersonalInformationId: number | undefined;
  ethnicity81: string | undefined;
  gender82: string | undefined;
  race83: string | undefined;
  isEthnicityByObservation84: number | undefined;
  isGenderByObservation85: number | undefined;
  isRaceByObservation86: number | undefined;
  demographicInfoSourceId87: number | undefined;

  constructor(data?: IAddDemographicInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.ethnicity81 = _data["ethnicity81"];
      this.gender82 = _data["gender82"];
      this.race83 = _data["race83"];
      this.isEthnicityByObservation84 = _data["isEthnicityByObservation84"];
      this.isGenderByObservation85 = _data["isGenderByObservation85"];
      this.isRaceByObservation86 = _data["isRaceByObservation86"];
      this.demographicInfoSourceId87 = _data["demographicInfoSourceId87"];
    }
  }

  static fromJS(data: any): AddDemographicInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddDemographicInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["ethnicity81"] = this.ethnicity81;
    data["gender82"] = this.gender82;
    data["race83"] = this.race83;
    data["isEthnicityByObservation84"] = this.isEthnicityByObservation84;
    data["isGenderByObservation85"] = this.isGenderByObservation85;
    data["isRaceByObservation86"] = this.isRaceByObservation86;
    data["demographicInfoSourceId87"] = this.demographicInfoSourceId87;
    return data;
  }

  clone(): AddDemographicInformationRequest {
    const json = this.toJSON();
    let result = new AddDemographicInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IAddDemographicInformationRequest {
  applicationPersonalInformationId: number | undefined;
  ethnicity81: string | undefined;
  gender82: string | undefined;
  race83: string | undefined;
  isEthnicityByObservation84: number | undefined;
  isGenderByObservation85: number | undefined;
  isRaceByObservation86: number | undefined;
  demographicInfoSourceId87: number | undefined;
}

export class AddEmployementIncomeDetailRequest
  implements IAddEmployementIncomeDetailRequest {
  applicationEmployementDetailsId: number;
  incomeTypeId1b101: number;
  amount1b10: number | undefined;

  constructor(data?: IAddEmployementIncomeDetailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationEmployementDetailsId =
        _data["applicationEmployementDetailsId"];
      this.incomeTypeId1b101 = _data["incomeTypeId1b101"];
      this.amount1b10 = _data["amount1b10"];
    }
  }

  static fromJS(data: any): AddEmployementIncomeDetailRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddEmployementIncomeDetailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationEmployementDetailsId"
    ] = this.applicationEmployementDetailsId;
    data["incomeTypeId1b101"] = this.incomeTypeId1b101;
    data["amount1b10"] = this.amount1b10;
    return data;
  }

  clone(): AddEmployementIncomeDetailRequest {
    const json = this.toJSON();
    let result = new AddEmployementIncomeDetailRequest();
    result.init(json);
    return result;
  }
}

export interface IAddEmployementIncomeDetailRequest {
  applicationEmployementDetailsId: number;
  incomeTypeId1b101: number;
  amount1b10: number | undefined;
}

export class AddEmploymentDetailRequest implements IAddEmploymentDetailRequest {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName1b2: string | undefined;
  phone1b3: string | undefined;
  street1b41: string | undefined;
  unit1b42: string | undefined;
  zip1b45: string | undefined;
  countryId1b46: number;
  stateId1b44: number;
  cityId1b43: number;
  positionTitle1b5: string | undefined;
  startDate1b6: moment.Moment | undefined;
  workingYears1b7: number | undefined;
  workingMonths: number | undefined;
  isEmployedBySomeone1b8: number | undefined;
  isSelfEmployed1b9: number | undefined;
  isOwnershipLessThan251b91: number | undefined;
  monthlyIncome1b92: number | undefined;

  constructor(data?: IAddEmploymentDetailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.employerBusinessName1b2 = _data["employerBusinessName1b2"];
      this.phone1b3 = _data["phone1b3"];
      this.street1b41 = _data["street1b41"];
      this.unit1b42 = _data["unit1b42"];
      this.zip1b45 = _data["zip1b45"];
      this.countryId1b46 = _data["countryId1b46"];
      this.stateId1b44 = _data["stateId1b44"];
      this.cityId1b43 = _data["cityId1b43"];
      this.positionTitle1b5 = _data["positionTitle1b5"];
      this.startDate1b6 = _data["startDate1b6"]
        ? moment(_data["startDate1b6"].toString())
        : <any>undefined;
      this.workingYears1b7 = _data["workingYears1b7"];
      this.workingMonths = _data["workingMonths"];
      this.isEmployedBySomeone1b8 = _data["isEmployedBySomeone1b8"];
      this.isSelfEmployed1b9 = _data["isSelfEmployed1b9"];
      this.isOwnershipLessThan251b91 = _data["isOwnershipLessThan251b91"];
      this.monthlyIncome1b92 = _data["monthlyIncome1b92"];
    }
  }

  static fromJS(data: any): AddEmploymentDetailRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddEmploymentDetailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["employerBusinessName1b2"] = this.employerBusinessName1b2;
    data["phone1b3"] = this.phone1b3;
    data["street1b41"] = this.street1b41;
    data["unit1b42"] = this.unit1b42;
    data["zip1b45"] = this.zip1b45;
    data["countryId1b46"] = this.countryId1b46;
    data["stateId1b44"] = this.stateId1b44;
    data["cityId1b43"] = this.cityId1b43;
    data["positionTitle1b5"] = this.positionTitle1b5;
    data["startDate1b6"] = this.startDate1b6
      ? this.startDate1b6.toISOString()
      : <any>undefined;
    data["workingYears1b7"] = this.workingYears1b7;
    data["workingMonths"] = this.workingMonths;
    data["isEmployedBySomeone1b8"] = this.isEmployedBySomeone1b8;
    data["isSelfEmployed1b9"] = this.isSelfEmployed1b9;
    data["isOwnershipLessThan251b91"] = this.isOwnershipLessThan251b91;
    data["monthlyIncome1b92"] = this.monthlyIncome1b92;
    return data;
  }

  clone(): AddEmploymentDetailRequest {
    const json = this.toJSON();
    let result = new AddEmploymentDetailRequest();
    result.init(json);
    return result;
  }
}

export interface IAddEmploymentDetailRequest {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName1b2: string | undefined;
  phone1b3: string | undefined;
  street1b41: string | undefined;
  unit1b42: string | undefined;
  zip1b45: string | undefined;
  countryId1b46: number;
  stateId1b44: number;
  cityId1b43: number;
  positionTitle1b5: string | undefined;
  startDate1b6: moment.Moment | undefined;
  workingYears1b7: number | undefined;
  workingMonths: number | undefined;
  isEmployedBySomeone1b8: number | undefined;
  isSelfEmployed1b9: number | undefined;
  isOwnershipLessThan251b91: number | undefined;
  monthlyIncome1b92: number | undefined;
}

export class AddFinancialRealEstateRequest
  implements IAddFinancialRealEstateRequest {
  applicationPersonalInformationId: number | undefined;
  street3a21: string | undefined;
  unitNo3a22: string | undefined;
  zip3a25: string | undefined;
  countryId3a26: number;
  stateId3a24: number;
  cityId3a23: number;
  propertyValue3a3: number | undefined;
  financialPropertyStatusId3a4: number;
  financialPropertyIntendedOccupancyId3a5: number;
  monthlyMortagePayment3a6: number | undefined;
  monthlyRentalIncome3a7: number | undefined;
  netMonthlyRentalIncome3a8: number | undefined;

  constructor(data?: IAddFinancialRealEstateRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.street3a21 = _data["street3a21"];
      this.unitNo3a22 = _data["unitNo3a22"];
      this.zip3a25 = _data["zip3a25"];
      this.countryId3a26 = _data["countryId3a26"];
      this.stateId3a24 = _data["stateId3a24"];
      this.cityId3a23 = _data["cityId3a23"];
      this.propertyValue3a3 = _data["propertyValue3a3"];
      this.financialPropertyStatusId3a4 = _data["financialPropertyStatusId3a4"];
      this.financialPropertyIntendedOccupancyId3a5 =
        _data["financialPropertyIntendedOccupancyId3a5"];
      this.monthlyMortagePayment3a6 = _data["monthlyMortagePayment3a6"];
      this.monthlyRentalIncome3a7 = _data["monthlyRentalIncome3a7"];
      this.netMonthlyRentalIncome3a8 = _data["netMonthlyRentalIncome3a8"];
    }
  }

  static fromJS(data: any): AddFinancialRealEstateRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddFinancialRealEstateRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["street3a21"] = this.street3a21;
    data["unitNo3a22"] = this.unitNo3a22;
    data["zip3a25"] = this.zip3a25;
    data["countryId3a26"] = this.countryId3a26;
    data["stateId3a24"] = this.stateId3a24;
    data["cityId3a23"] = this.cityId3a23;
    data["propertyValue3a3"] = this.propertyValue3a3;
    data["financialPropertyStatusId3a4"] = this.financialPropertyStatusId3a4;
    data[
      "financialPropertyIntendedOccupancyId3a5"
    ] = this.financialPropertyIntendedOccupancyId3a5;
    data["monthlyMortagePayment3a6"] = this.monthlyMortagePayment3a6;
    data["monthlyRentalIncome3a7"] = this.monthlyRentalIncome3a7;
    data["netMonthlyRentalIncome3a8"] = this.netMonthlyRentalIncome3a8;
    return data;
  }

  clone(): AddFinancialRealEstateRequest {
    const json = this.toJSON();
    let result = new AddFinancialRealEstateRequest();
    result.init(json);
    return result;
  }
}

export interface IAddFinancialRealEstateRequest {
  applicationPersonalInformationId: number | undefined;
  street3a21: string | undefined;
  unitNo3a22: string | undefined;
  zip3a25: string | undefined;
  countryId3a26: number;
  stateId3a24: number;
  cityId3a23: number;
  propertyValue3a3: number | undefined;
  financialPropertyStatusId3a4: number;
  financialPropertyIntendedOccupancyId3a5: number;
  monthlyMortagePayment3a6: number | undefined;
  monthlyRentalIncome3a7: number | undefined;
  netMonthlyRentalIncome3a8: number | undefined;
}

export class AddHousingTypeRequest implements IAddHousingTypeRequest {
  housingType1: string | undefined;

  constructor(data?: IAddHousingTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.housingType1 = _data["housingType1"];
    }
  }

  static fromJS(data: any): AddHousingTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddHousingTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["housingType1"] = this.housingType1;
    return data;
  }

  clone(): AddHousingTypeRequest {
    const json = this.toJSON();
    let result = new AddHousingTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddHousingTypeRequest {
  housingType1: string | undefined;
}

export class AddIncomeSourceRequest implements IAddIncomeSourceRequest {
  incomeSource1: string | undefined;

  constructor(data?: IAddIncomeSourceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.incomeSource1 = _data["incomeSource1"];
    }
  }

  static fromJS(data: any): AddIncomeSourceRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddIncomeSourceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["incomeSource1"] = this.incomeSource1;
    return data;
  }

  clone(): AddIncomeSourceRequest {
    const json = this.toJSON();
    let result = new AddIncomeSourceRequest();
    result.init(json);
    return result;
  }
}

export interface IAddIncomeSourceRequest {
  incomeSource1: string | undefined;
}

export class AddIncomeTypeRequest implements IAddIncomeTypeRequest {
  incomeType1: string | undefined;

  constructor(data?: IAddIncomeTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.incomeType1 = _data["incomeType1"];
    }
  }

  static fromJS(data: any): AddIncomeTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddIncomeTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["incomeType1"] = this.incomeType1;
    return data;
  }

  clone(): AddIncomeTypeRequest {
    const json = this.toJSON();
    let result = new AddIncomeTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddIncomeTypeRequest {
  incomeType1: string | undefined;
}

export class AddLaibilitiesTypeRequest implements IAddLaibilitiesTypeRequest {
  financialLaibilitiesType1: string | undefined;

  constructor(data?: IAddLaibilitiesTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialLaibilitiesType1 = _data["financialLaibilitiesType1"];
    }
  }

  static fromJS(data: any): AddLaibilitiesTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLaibilitiesTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialLaibilitiesType1"] = this.financialLaibilitiesType1;
    return data;
  }

  clone(): AddLaibilitiesTypeRequest {
    const json = this.toJSON();
    let result = new AddLaibilitiesTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLaibilitiesTypeRequest {
  financialLaibilitiesType1: string | undefined;
}

export class AddLeadApplicationQuestions
  implements IAddLeadApplicationQuestions {
  question: string | undefined;

  constructor(data?: IAddLeadApplicationQuestions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.question = _data["question"];
    }
  }

  static fromJS(data: any): AddLeadApplicationQuestions {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadApplicationQuestions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["question"] = this.question;
    return data;
  }

  clone(): AddLeadApplicationQuestions {
    const json = this.toJSON();
    let result = new AddLeadApplicationQuestions();
    result.init(json);
    return result;
  }
}

export interface IAddLeadApplicationQuestions {
  question: string | undefined;
}

export class AddLeadApplicationType implements IAddLeadApplicationType {
  applicationType: string | undefined;

  constructor(data?: IAddLeadApplicationType) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationType = _data["applicationType"];
    }
  }

  static fromJS(data: any): AddLeadApplicationType {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadApplicationType();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["applicationType"] = this.applicationType;
    return data;
  }

  clone(): AddLeadApplicationType {
    const json = this.toJSON();
    let result = new AddLeadApplicationType();
    result.init(json);
    return result;
  }
}

export interface IAddLeadApplicationType {
  applicationType: string | undefined;
}

export class AddLeadAssetDetails implements IAddLeadAssetDetails {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  assetTypeId: number;
  leadApplicationTypeId: number;
  financialInstitution: string | undefined;
  balance: number | undefined;
  ownerTypeId: number;

  constructor(data?: IAddLeadAssetDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.leadApplicationDetailPurchasingId =
        _data["leadApplicationDetailPurchasingId"];
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.assetTypeId = _data["assetTypeId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.financialInstitution = _data["financialInstitution"];
      this.balance = _data["balance"];
      this.ownerTypeId = _data["ownerTypeId"];
    }
  }

  static fromJS(data: any): AddLeadAssetDetails {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadAssetDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "leadApplicationDetailPurchasingId"
    ] = this.leadApplicationDetailPurchasingId;
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["assetTypeId"] = this.assetTypeId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["financialInstitution"] = this.financialInstitution;
    data["balance"] = this.balance;
    data["ownerTypeId"] = this.ownerTypeId;
    return data;
  }

  clone(): AddLeadAssetDetails {
    const json = this.toJSON();
    let result = new AddLeadAssetDetails();
    result.init(json);
    return result;
  }
}

export interface IAddLeadAssetDetails {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  assetTypeId: number;
  leadApplicationTypeId: number;
  financialInstitution: string | undefined;
  balance: number | undefined;
  ownerTypeId: number;
}

export class AddLeadAssetTypes implements IAddLeadAssetTypes {
  assetsType: string | undefined;

  constructor(data?: IAddLeadAssetTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.assetsType = _data["assetsType"];
    }
  }

  static fromJS(data: any): AddLeadAssetTypes {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadAssetTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["assetsType"] = this.assetsType;
    return data;
  }

  clone(): AddLeadAssetTypes {
    const json = this.toJSON();
    let result = new AddLeadAssetTypes();
    result.init(json);
    return result;
  }
}

export interface IAddLeadAssetTypes {
  assetsType: string | undefined;
}

export class AddLeadEmploymentDetails implements IAddLeadEmploymentDetails {
  employeeTypeId: number;
  leadApplicationDetailPurchasingId: number | undefined;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number;
  employerName: string | undefined;
  employementAddress: string | undefined;
  employementSuite: string | undefined;
  employementCity: string | undefined;
  employementTaxeId: number;
  employementZip: string | undefined;
  employerPhoneNumber: string | undefined;
  isCurrentJob: number | undefined;
  estimatedStartDate: moment.Moment | undefined;
  jobTitle: string | undefined;
  estimatedAnnualBaseSalary: number | undefined;
  estimatedAnnualBonus: number | undefined;
  estimatedAnnualCommission: number | undefined;
  estimatedAnnualOvertime: number | undefined;
  isCoBorrower: number | undefined;

  constructor(data?: IAddLeadEmploymentDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.employeeTypeId = _data["employeeTypeId"];
      this.leadApplicationDetailPurchasingId =
        _data["leadApplicationDetailPurchasingId"];
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.employerName = _data["employerName"];
      this.employementAddress = _data["employementAddress"];
      this.employementSuite = _data["employementSuite"];
      this.employementCity = _data["employementCity"];
      this.employementTaxeId = _data["employementTaxeId"];
      this.employementZip = _data["employementZip"];
      this.employerPhoneNumber = _data["employerPhoneNumber"];
      this.isCurrentJob = _data["isCurrentJob"];
      this.estimatedStartDate = _data["estimatedStartDate"]
        ? moment(_data["estimatedStartDate"].toString())
        : <any>undefined;
      this.jobTitle = _data["jobTitle"];
      this.estimatedAnnualBaseSalary = _data["estimatedAnnualBaseSalary"];
      this.estimatedAnnualBonus = _data["estimatedAnnualBonus"];
      this.estimatedAnnualCommission = _data["estimatedAnnualCommission"];
      this.estimatedAnnualOvertime = _data["estimatedAnnualOvertime"];
      this.isCoBorrower = _data["isCoBorrower"];
    }
  }

  static fromJS(data: any): AddLeadEmploymentDetails {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadEmploymentDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["employeeTypeId"] = this.employeeTypeId;
    data[
      "leadApplicationDetailPurchasingId"
    ] = this.leadApplicationDetailPurchasingId;
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["employerName"] = this.employerName;
    data["employementAddress"] = this.employementAddress;
    data["employementSuite"] = this.employementSuite;
    data["employementCity"] = this.employementCity;
    data["employementTaxeId"] = this.employementTaxeId;
    data["employementZip"] = this.employementZip;
    data["employerPhoneNumber"] = this.employerPhoneNumber;
    data["isCurrentJob"] = this.isCurrentJob;
    data["estimatedStartDate"] = this.estimatedStartDate
      ? this.estimatedStartDate.toISOString()
      : <any>undefined;
    data["jobTitle"] = this.jobTitle;
    data["estimatedAnnualBaseSalary"] = this.estimatedAnnualBaseSalary;
    data["estimatedAnnualBonus"] = this.estimatedAnnualBonus;
    data["estimatedAnnualCommission"] = this.estimatedAnnualCommission;
    data["estimatedAnnualOvertime"] = this.estimatedAnnualOvertime;
    data["isCoBorrower"] = this.isCoBorrower;
    return data;
  }

  clone(): AddLeadEmploymentDetails {
    const json = this.toJSON();
    let result = new AddLeadEmploymentDetails();
    result.init(json);
    return result;
  }
}

export interface IAddLeadEmploymentDetails {
  employeeTypeId: number;
  leadApplicationDetailPurchasingId: number | undefined;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number;
  employerName: string | undefined;
  employementAddress: string | undefined;
  employementSuite: string | undefined;
  employementCity: string | undefined;
  employementTaxeId: number;
  employementZip: string | undefined;
  employerPhoneNumber: string | undefined;
  isCurrentJob: number | undefined;
  estimatedStartDate: moment.Moment | undefined;
  jobTitle: string | undefined;
  estimatedAnnualBaseSalary: number | undefined;
  estimatedAnnualBonus: number | undefined;
  estimatedAnnualCommission: number | undefined;
  estimatedAnnualOvertime: number | undefined;
  isCoBorrower: number | undefined;
}

export class AddLeadEmploymentTypes implements IAddLeadEmploymentTypes {
  employementType: string | undefined;

  constructor(data?: IAddLeadEmploymentTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.employementType = _data["employementType"];
    }
  }

  static fromJS(data: any): AddLeadEmploymentTypes {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadEmploymentTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["employementType"] = this.employementType;
    return data;
  }

  clone(): AddLeadEmploymentTypes {
    const json = this.toJSON();
    let result = new AddLeadEmploymentTypes();
    result.init(json);
    return result;
  }
}

export interface IAddLeadEmploymentTypes {
  employementType: string | undefined;
}

export class AddLeadIncomeTypes implements IAddLeadIncomeTypes {
  incomeType: string | undefined;

  constructor(data?: IAddLeadIncomeTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.incomeType = _data["incomeType"];
    }
  }

  static fromJS(data: any): AddLeadIncomeTypes {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadIncomeTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["incomeType"] = this.incomeType;
    return data;
  }

  clone(): AddLeadIncomeTypes {
    const json = this.toJSON();
    let result = new AddLeadIncomeTypes();
    result.init(json);
    return result;
  }
}

export interface IAddLeadIncomeTypes {
  incomeType: string | undefined;
}

export class AddLeadOwnerTypes implements IAddLeadOwnerTypes {
  ownerType: string | undefined;

  constructor(data?: IAddLeadOwnerTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ownerType = _data["ownerType"];
    }
  }

  static fromJS(data: any): AddLeadOwnerTypes {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadOwnerTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ownerType"] = this.ownerType;
    return data;
  }

  clone(): AddLeadOwnerTypes {
    const json = this.toJSON();
    let result = new AddLeadOwnerTypes();
    result.init(json);
    return result;
  }
}

export interface IAddLeadOwnerTypes {
  ownerType: string | undefined;
}

export class AddLeadPurchasingDetail implements IAddLeadPurchasingDetail {
  stage: string | undefined;
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  newHomeAddress: string | undefined;
  newHomeUnit: string | undefined;
  newHomeCity: string | undefined;
  newHomeStateId: number;
  newHomeZipCode: string | undefined;
  contractClosingDate: moment.Moment | undefined;
  contractType: string | undefined;
  estimatedHomePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  creditScore: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  typeOfNewHome: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isSomeOneRefer: number | undefined;
  isApplyOwn: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  isEmployementHistory: number | undefined;
  isOtherSourceOfIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;

  constructor(data?: IAddLeadPurchasingDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.stage = _data["stage"];
      this.isWorkingWithEzalready = _data["isWorkingWithEzalready"];
      this.workingOfficerName = _data["workingOfficerName"];
      this.newHomeAddress = _data["newHomeAddress"];
      this.newHomeUnit = _data["newHomeUnit"];
      this.newHomeCity = _data["newHomeCity"];
      this.newHomeStateId = _data["newHomeStateId"];
      this.newHomeZipCode = _data["newHomeZipCode"];
      this.contractClosingDate = _data["contractClosingDate"]
        ? moment(_data["contractClosingDate"].toString())
        : <any>undefined;
      this.contractType = _data["contractType"];
      this.estimatedHomePrice = _data["estimatedHomePrice"];
      this.downPaymentAmount = _data["downPaymentAmount"];
      this.downPaymentPercentage = _data["downPaymentPercentage"];
      this.estimatedAnnualTax = _data["estimatedAnnualTax"];
      this.estimatedAnnualHomeInsurance = _data["estimatedAnnualHomeInsurance"];
      this.creditScore = _data["creditScore"];
      this.propertyLegalFirstName = _data["propertyLegalFirstName"];
      this.propertyMiddleInitial = _data["propertyMiddleInitial"];
      this.propertyLegalLastName = _data["propertyLegalLastName"];
      this.propertyPhoneNumber = _data["propertyPhoneNumber"];
      this.propertyEmailAddress = _data["propertyEmailAddress"];
      this.typeOfHome = _data["typeOfHome"];
      this.monthlyHoadues = _data["monthlyHoadues"];
      this.typeOfNewHome = _data["typeOfNewHome"];
      this.isMilitaryMember = _data["isMilitaryMember"];
      this.currentMilitaryStatus = _data["currentMilitaryStatus"];
      this.militaryBranch = _data["militaryBranch"];
      this.isEtsdateinYear = _data["isEtsdateinYear"];
      this.etsdate = _data["etsdate"]
        ? moment(_data["etsdate"].toString())
        : <any>undefined;
      this.isValoanPreviously = _data["isValoanPreviously"];
      this.whoLivingInHome = _data["whoLivingInHome"];
      this.personalLegalFirstName = _data["personalLegalFirstName"];
      this.personalMiddleInitial = _data["personalMiddleInitial"];
      this.personalLegalLastName = _data["personalLegalLastName"];
      this.personalPhoneNumber = _data["personalPhoneNumber"];
      this.personalEmailAddress = _data["personalEmailAddress"];
      this.personalPassword = _data["personalPassword"];
      this.isSomeOneRefer = _data["isSomeOneRefer"];
      this.isApplyOwn = _data["isApplyOwn"];
      this.maritialStatus = _data["maritialStatus"];
      this.numberOfDependents = _data["numberOfDependents"];
      this.currentAddress = _data["currentAddress"];
      this.currentUnit = _data["currentUnit"];
      this.currentCity = _data["currentCity"];
      this.currentStateId = _data["currentStateId"];
      this.currentZipCode = _data["currentZipCode"];
      this.currentStartLivingDate = _data["currentStartLivingDate"]
        ? moment(_data["currentStartLivingDate"].toString())
        : <any>undefined;
      this.currentReantingType = _data["currentReantingType"];
      this.estimatedMonthlyExpenses = _data["estimatedMonthlyExpenses"];
      this.isEmployementHistory = _data["isEmployementHistory"];
      this.isOtherSourceOfIncome = _data["isOtherSourceOfIncome"];
      this.sex = _data["sex"];
      this.ethnicity = _data["ethnicity"];
      this.race = _data["race"];
      this.citizenshipId = _data["citizenshipId"];
      this.isCertify = _data["isCertify"];
      this.isReadEconsent = _data["isReadEconsent"];
      this.isReadThirdPartyConsent = _data["isReadThirdPartyConsent"];
      this.socialSecurityNumber = _data["socialSecurityNumber"];
      this.conformSsn = _data["conformSsn"];
      this.birthDate = _data["birthDate"]
        ? moment(_data["birthDate"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddLeadPurchasingDetail {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadPurchasingDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["stage"] = this.stage;
    data["isWorkingWithEzalready"] = this.isWorkingWithEzalready;
    data["workingOfficerName"] = this.workingOfficerName;
    data["newHomeAddress"] = this.newHomeAddress;
    data["newHomeUnit"] = this.newHomeUnit;
    data["newHomeCity"] = this.newHomeCity;
    data["newHomeStateId"] = this.newHomeStateId;
    data["newHomeZipCode"] = this.newHomeZipCode;
    data["contractClosingDate"] = this.contractClosingDate
      ? this.contractClosingDate.toISOString()
      : <any>undefined;
    data["contractType"] = this.contractType;
    data["estimatedHomePrice"] = this.estimatedHomePrice;
    data["downPaymentAmount"] = this.downPaymentAmount;
    data["downPaymentPercentage"] = this.downPaymentPercentage;
    data["estimatedAnnualTax"] = this.estimatedAnnualTax;
    data["estimatedAnnualHomeInsurance"] = this.estimatedAnnualHomeInsurance;
    data["creditScore"] = this.creditScore;
    data["propertyLegalFirstName"] = this.propertyLegalFirstName;
    data["propertyMiddleInitial"] = this.propertyMiddleInitial;
    data["propertyLegalLastName"] = this.propertyLegalLastName;
    data["propertyPhoneNumber"] = this.propertyPhoneNumber;
    data["propertyEmailAddress"] = this.propertyEmailAddress;
    data["typeOfHome"] = this.typeOfHome;
    data["monthlyHoadues"] = this.monthlyHoadues;
    data["typeOfNewHome"] = this.typeOfNewHome;
    data["isMilitaryMember"] = this.isMilitaryMember;
    data["currentMilitaryStatus"] = this.currentMilitaryStatus;
    data["militaryBranch"] = this.militaryBranch;
    data["isEtsdateinYear"] = this.isEtsdateinYear;
    data["etsdate"] = this.etsdate
      ? this.etsdate.toISOString()
      : <any>undefined;
    data["isValoanPreviously"] = this.isValoanPreviously;
    data["whoLivingInHome"] = this.whoLivingInHome;
    data["personalLegalFirstName"] = this.personalLegalFirstName;
    data["personalMiddleInitial"] = this.personalMiddleInitial;
    data["personalLegalLastName"] = this.personalLegalLastName;
    data["personalPhoneNumber"] = this.personalPhoneNumber;
    data["personalEmailAddress"] = this.personalEmailAddress;
    data["personalPassword"] = this.personalPassword;
    data["isSomeOneRefer"] = this.isSomeOneRefer;
    data["isApplyOwn"] = this.isApplyOwn;
    data["maritialStatus"] = this.maritialStatus;
    data["numberOfDependents"] = this.numberOfDependents;
    data["currentAddress"] = this.currentAddress;
    data["currentUnit"] = this.currentUnit;
    data["currentCity"] = this.currentCity;
    data["currentStateId"] = this.currentStateId;
    data["currentZipCode"] = this.currentZipCode;
    data["currentStartLivingDate"] = this.currentStartLivingDate
      ? this.currentStartLivingDate.toISOString()
      : <any>undefined;
    data["currentReantingType"] = this.currentReantingType;
    data["estimatedMonthlyExpenses"] = this.estimatedMonthlyExpenses;
    data["isEmployementHistory"] = this.isEmployementHistory;
    data["isOtherSourceOfIncome"] = this.isOtherSourceOfIncome;
    data["sex"] = this.sex;
    data["ethnicity"] = this.ethnicity;
    data["race"] = this.race;
    data["citizenshipId"] = this.citizenshipId;
    data["isCertify"] = this.isCertify;
    data["isReadEconsent"] = this.isReadEconsent;
    data["isReadThirdPartyConsent"] = this.isReadThirdPartyConsent;
    data["socialSecurityNumber"] = this.socialSecurityNumber;
    data["conformSsn"] = this.conformSsn;
    data["birthDate"] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): AddLeadPurchasingDetail {
    const json = this.toJSON();
    let result = new AddLeadPurchasingDetail();
    result.init(json);
    return result;
  }
}

export interface IAddLeadPurchasingDetail {
  stage: string | undefined;
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  newHomeAddress: string | undefined;
  newHomeUnit: string | undefined;
  newHomeCity: string | undefined;
  newHomeStateId: number;
  newHomeZipCode: string | undefined;
  contractClosingDate: moment.Moment | undefined;
  contractType: string | undefined;
  estimatedHomePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  creditScore: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  typeOfNewHome: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isSomeOneRefer: number | undefined;
  isApplyOwn: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  isEmployementHistory: number | undefined;
  isOtherSourceOfIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;
}

export class AddLeadQuestionAnswers implements IAddLeadQuestionAnswers {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  questionId: number;
  isYes: number | undefined;

  constructor(data?: IAddLeadQuestionAnswers) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.leadApplicationDetailPurchasingId =
        _data["leadApplicationDetailPurchasingId"];
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.questionId = _data["questionId"];
      this.isYes = _data["isYes"];
    }
  }

  static fromJS(data: any): AddLeadQuestionAnswers {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadQuestionAnswers();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "leadApplicationDetailPurchasingId"
    ] = this.leadApplicationDetailPurchasingId;
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["questionId"] = this.questionId;
    data["isYes"] = this.isYes;
    return data;
  }

  clone(): AddLeadQuestionAnswers {
    const json = this.toJSON();
    let result = new AddLeadQuestionAnswers();
    result.init(json);
    return result;
  }
}

export interface IAddLeadQuestionAnswers {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  questionId: number;
  isYes: number | undefined;
}

export class AddLeadRefinancingDetails implements IAddLeadRefinancingDetails {
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  objectiveReason: string | undefined;
  propertyAddress: string | undefined;
  propertyUnit: string | undefined;
  propertyCity: string | undefined;
  propertyZip: string | undefined;
  propertyStateId: number;
  propertyCountryId: number;
  propertyEstimatedValue: number | undefined;
  propertyLoanBalance: number | undefined;
  propertCashOutAmount: number | undefined;
  newLoanEstimateAmount: number | undefined;
  creditScore: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  yearHomePurchased: number | undefined;
  orignalPurchasedPrice: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  currentlyUsingHomeAs: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  propertyPassword: string | undefined;
  isSomeoneRefer: number | undefined;
  refferedBy: string | undefined;
  isApplyOwn: number | undefined;
  isLegalSpouse: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  firstDependantAge: number | undefined;
  isCurrentlyLivingOnRefinancingProperty: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isAddressSameAsPrimaryBorrower: number | undefined;
  personalAddress: string | undefined;
  personalUnit: string | undefined;
  personalCity: string | undefined;
  personalStateId: number;
  personalZipCode: string | undefined;
  personalStartLivingDate: moment.Moment | undefined;
  personalReantingType: string | undefined;
  isEmployementHistory: number | undefined;
  isCoBorrowerHaveShareIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;

  constructor(data?: IAddLeadRefinancingDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isWorkingWithEzalready = _data["isWorkingWithEzalready"];
      this.workingOfficerName = _data["workingOfficerName"];
      this.objectiveReason = _data["objectiveReason"];
      this.propertyAddress = _data["propertyAddress"];
      this.propertyUnit = _data["propertyUnit"];
      this.propertyCity = _data["propertyCity"];
      this.propertyZip = _data["propertyZip"];
      this.propertyStateId = _data["propertyStateId"];
      this.propertyCountryId = _data["propertyCountryId"];
      this.propertyEstimatedValue = _data["propertyEstimatedValue"];
      this.propertyLoanBalance = _data["propertyLoanBalance"];
      this.propertCashOutAmount = _data["propertCashOutAmount"];
      this.newLoanEstimateAmount = _data["newLoanEstimateAmount"];
      this.creditScore = _data["creditScore"];
      this.typeOfHome = _data["typeOfHome"];
      this.monthlyHoadues = _data["monthlyHoadues"];
      this.yearHomePurchased = _data["yearHomePurchased"];
      this.orignalPurchasedPrice = _data["orignalPurchasedPrice"];
      this.estimatedAnnualTax = _data["estimatedAnnualTax"];
      this.estimatedAnnualHomeInsurance = _data["estimatedAnnualHomeInsurance"];
      this.currentlyUsingHomeAs = _data["currentlyUsingHomeAs"];
      this.isMilitaryMember = _data["isMilitaryMember"];
      this.currentMilitaryStatus = _data["currentMilitaryStatus"];
      this.militaryBranch = _data["militaryBranch"];
      this.isEtsdateinYear = _data["isEtsdateinYear"];
      this.etsdate = _data["etsdate"]
        ? moment(_data["etsdate"].toString())
        : <any>undefined;
      this.isValoanPreviously = _data["isValoanPreviously"];
      this.whoLivingInHome = _data["whoLivingInHome"];
      this.propertyLegalFirstName = _data["propertyLegalFirstName"];
      this.propertyMiddleInitial = _data["propertyMiddleInitial"];
      this.propertyLegalLastName = _data["propertyLegalLastName"];
      this.propertyPhoneNumber = _data["propertyPhoneNumber"];
      this.propertyEmailAddress = _data["propertyEmailAddress"];
      this.propertyPassword = _data["propertyPassword"];
      this.isSomeoneRefer = _data["isSomeoneRefer"];
      this.refferedBy = _data["refferedBy"];
      this.isApplyOwn = _data["isApplyOwn"];
      this.isLegalSpouse = _data["isLegalSpouse"];
      this.maritialStatus = _data["maritialStatus"];
      this.numberOfDependents = _data["numberOfDependents"];
      this.firstDependantAge = _data["firstDependantAge"];
      this.isCurrentlyLivingOnRefinancingProperty =
        _data["isCurrentlyLivingOnRefinancingProperty"];
      this.currentAddress = _data["currentAddress"];
      this.currentUnit = _data["currentUnit"];
      this.currentCity = _data["currentCity"];
      this.currentStateId = _data["currentStateId"];
      this.currentZipCode = _data["currentZipCode"];
      this.currentStartLivingDate = _data["currentStartLivingDate"]
        ? moment(_data["currentStartLivingDate"].toString())
        : <any>undefined;
      this.currentReantingType = _data["currentReantingType"];
      this.estimatedMonthlyExpenses = _data["estimatedMonthlyExpenses"];
      this.personalLegalFirstName = _data["personalLegalFirstName"];
      this.personalMiddleInitial = _data["personalMiddleInitial"];
      this.personalLegalLastName = _data["personalLegalLastName"];
      this.personalPhoneNumber = _data["personalPhoneNumber"];
      this.personalEmailAddress = _data["personalEmailAddress"];
      this.personalPassword = _data["personalPassword"];
      this.isAddressSameAsPrimaryBorrower =
        _data["isAddressSameAsPrimaryBorrower"];
      this.personalAddress = _data["personalAddress"];
      this.personalUnit = _data["personalUnit"];
      this.personalCity = _data["personalCity"];
      this.personalStateId = _data["personalStateId"];
      this.personalZipCode = _data["personalZipCode"];
      this.personalStartLivingDate = _data["personalStartLivingDate"]
        ? moment(_data["personalStartLivingDate"].toString())
        : <any>undefined;
      this.personalReantingType = _data["personalReantingType"];
      this.isEmployementHistory = _data["isEmployementHistory"];
      this.isCoBorrowerHaveShareIncome = _data["isCoBorrowerHaveShareIncome"];
      this.sex = _data["sex"];
      this.ethnicity = _data["ethnicity"];
      this.race = _data["race"];
      this.citizenshipId = _data["citizenshipId"];
      this.isCertify = _data["isCertify"];
      this.isReadEconsent = _data["isReadEconsent"];
      this.isReadThirdPartyConsent = _data["isReadThirdPartyConsent"];
      this.socialSecurityNumber = _data["socialSecurityNumber"];
      this.conformSsn = _data["conformSsn"];
      this.birthDate = _data["birthDate"]
        ? moment(_data["birthDate"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddLeadRefinancingDetails {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadRefinancingDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["isWorkingWithEzalready"] = this.isWorkingWithEzalready;
    data["workingOfficerName"] = this.workingOfficerName;
    data["objectiveReason"] = this.objectiveReason;
    data["propertyAddress"] = this.propertyAddress;
    data["propertyUnit"] = this.propertyUnit;
    data["propertyCity"] = this.propertyCity;
    data["propertyZip"] = this.propertyZip;
    data["propertyStateId"] = this.propertyStateId;
    data["propertyCountryId"] = this.propertyCountryId;
    data["propertyEstimatedValue"] = this.propertyEstimatedValue;
    data["propertyLoanBalance"] = this.propertyLoanBalance;
    data["propertCashOutAmount"] = this.propertCashOutAmount;
    data["newLoanEstimateAmount"] = this.newLoanEstimateAmount;
    data["creditScore"] = this.creditScore;
    data["typeOfHome"] = this.typeOfHome;
    data["monthlyHoadues"] = this.monthlyHoadues;
    data["yearHomePurchased"] = this.yearHomePurchased;
    data["orignalPurchasedPrice"] = this.orignalPurchasedPrice;
    data["estimatedAnnualTax"] = this.estimatedAnnualTax;
    data["estimatedAnnualHomeInsurance"] = this.estimatedAnnualHomeInsurance;
    data["currentlyUsingHomeAs"] = this.currentlyUsingHomeAs;
    data["isMilitaryMember"] = this.isMilitaryMember;
    data["currentMilitaryStatus"] = this.currentMilitaryStatus;
    data["militaryBranch"] = this.militaryBranch;
    data["isEtsdateinYear"] = this.isEtsdateinYear;
    data["etsdate"] = this.etsdate
      ? this.etsdate.toISOString()
      : <any>undefined;
    data["isValoanPreviously"] = this.isValoanPreviously;
    data["whoLivingInHome"] = this.whoLivingInHome;
    data["propertyLegalFirstName"] = this.propertyLegalFirstName;
    data["propertyMiddleInitial"] = this.propertyMiddleInitial;
    data["propertyLegalLastName"] = this.propertyLegalLastName;
    data["propertyPhoneNumber"] = this.propertyPhoneNumber;
    data["propertyEmailAddress"] = this.propertyEmailAddress;
    data["propertyPassword"] = this.propertyPassword;
    data["isSomeoneRefer"] = this.isSomeoneRefer;
    data["refferedBy"] = this.refferedBy;
    data["isApplyOwn"] = this.isApplyOwn;
    data["isLegalSpouse"] = this.isLegalSpouse;
    data["maritialStatus"] = this.maritialStatus;
    data["numberOfDependents"] = this.numberOfDependents;
    data["firstDependantAge"] = this.firstDependantAge;
    data[
      "isCurrentlyLivingOnRefinancingProperty"
    ] = this.isCurrentlyLivingOnRefinancingProperty;
    data["currentAddress"] = this.currentAddress;
    data["currentUnit"] = this.currentUnit;
    data["currentCity"] = this.currentCity;
    data["currentStateId"] = this.currentStateId;
    data["currentZipCode"] = this.currentZipCode;
    data["currentStartLivingDate"] = this.currentStartLivingDate
      ? this.currentStartLivingDate.toISOString()
      : <any>undefined;
    data["currentReantingType"] = this.currentReantingType;
    data["estimatedMonthlyExpenses"] = this.estimatedMonthlyExpenses;
    data["personalLegalFirstName"] = this.personalLegalFirstName;
    data["personalMiddleInitial"] = this.personalMiddleInitial;
    data["personalLegalLastName"] = this.personalLegalLastName;
    data["personalPhoneNumber"] = this.personalPhoneNumber;
    data["personalEmailAddress"] = this.personalEmailAddress;
    data["personalPassword"] = this.personalPassword;
    data[
      "isAddressSameAsPrimaryBorrower"
    ] = this.isAddressSameAsPrimaryBorrower;
    data["personalAddress"] = this.personalAddress;
    data["personalUnit"] = this.personalUnit;
    data["personalCity"] = this.personalCity;
    data["personalStateId"] = this.personalStateId;
    data["personalZipCode"] = this.personalZipCode;
    data["personalStartLivingDate"] = this.personalStartLivingDate
      ? this.personalStartLivingDate.toISOString()
      : <any>undefined;
    data["personalReantingType"] = this.personalReantingType;
    data["isEmployementHistory"] = this.isEmployementHistory;
    data["isCoBorrowerHaveShareIncome"] = this.isCoBorrowerHaveShareIncome;
    data["sex"] = this.sex;
    data["ethnicity"] = this.ethnicity;
    data["race"] = this.race;
    data["citizenshipId"] = this.citizenshipId;
    data["isCertify"] = this.isCertify;
    data["isReadEconsent"] = this.isReadEconsent;
    data["isReadThirdPartyConsent"] = this.isReadThirdPartyConsent;
    data["socialSecurityNumber"] = this.socialSecurityNumber;
    data["conformSsn"] = this.conformSsn;
    data["birthDate"] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): AddLeadRefinancingDetails {
    const json = this.toJSON();
    let result = new AddLeadRefinancingDetails();
    result.init(json);
    return result;
  }
}

export interface IAddLeadRefinancingDetails {
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  objectiveReason: string | undefined;
  propertyAddress: string | undefined;
  propertyUnit: string | undefined;
  propertyCity: string | undefined;
  propertyZip: string | undefined;
  propertyStateId: number;
  propertyCountryId: number;
  propertyEstimatedValue: number | undefined;
  propertyLoanBalance: number | undefined;
  propertCashOutAmount: number | undefined;
  newLoanEstimateAmount: number | undefined;
  creditScore: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  yearHomePurchased: number | undefined;
  orignalPurchasedPrice: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  currentlyUsingHomeAs: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  propertyPassword: string | undefined;
  isSomeoneRefer: number | undefined;
  refferedBy: string | undefined;
  isApplyOwn: number | undefined;
  isLegalSpouse: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  firstDependantAge: number | undefined;
  isCurrentlyLivingOnRefinancingProperty: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isAddressSameAsPrimaryBorrower: number | undefined;
  personalAddress: string | undefined;
  personalUnit: string | undefined;
  personalCity: string | undefined;
  personalStateId: number;
  personalZipCode: string | undefined;
  personalStartLivingDate: moment.Moment | undefined;
  personalReantingType: string | undefined;
  isEmployementHistory: number | undefined;
  isCoBorrowerHaveShareIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;
}

export class AddLeadRefinancingIncomeDetails
  implements IAddLeadRefinancingIncomeDetails {
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  incomeTypeId: number;
  monthlyAmount: number | undefined;

  constructor(data?: IAddLeadRefinancingIncomeDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.incomeTypeId = _data["incomeTypeId"];
      this.monthlyAmount = _data["monthlyAmount"];
    }
  }

  static fromJS(data: any): AddLeadRefinancingIncomeDetails {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadRefinancingIncomeDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["incomeTypeId"] = this.incomeTypeId;
    data["monthlyAmount"] = this.monthlyAmount;
    return data;
  }

  clone(): AddLeadRefinancingIncomeDetails {
    const json = this.toJSON();
    let result = new AddLeadRefinancingIncomeDetails();
    result.init(json);
    return result;
  }
}

export interface IAddLeadRefinancingIncomeDetails {
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  incomeTypeId: number;
  monthlyAmount: number | undefined;
}

export class AddLeadTaxTypes implements IAddLeadTaxTypes {
  taxesType: string | undefined;

  constructor(data?: IAddLeadTaxTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.taxesType = _data["taxesType"];
    }
  }

  static fromJS(data: any): AddLeadTaxTypes {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadTaxTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["taxesType"] = this.taxesType;
    return data;
  }

  clone(): AddLeadTaxTypes {
    const json = this.toJSON();
    let result = new AddLeadTaxTypes();
    result.init(json);
    return result;
  }
}

export interface IAddLeadTaxTypes {
  taxesType: string | undefined;
}

export class AddLoanAndPropertyInformationGiftRequest
  implements IAddLoanAndPropertyInformationGiftRequest {
  applicationPersonalInformationId: number | undefined;
  loanPropertyGiftTypeId4d1: number | undefined;
  deposited4d2: number | undefined;
  source4d3: string | undefined;
  value4d4: number | undefined;

  constructor(data?: IAddLoanAndPropertyInformationGiftRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.loanPropertyGiftTypeId4d1 = _data["loanPropertyGiftTypeId4d1"];
      this.deposited4d2 = _data["deposited4d2"];
      this.source4d3 = _data["source4d3"];
      this.value4d4 = _data["value4d4"];
    }
  }

  static fromJS(data: any): AddLoanAndPropertyInformationGiftRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanAndPropertyInformationGiftRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["loanPropertyGiftTypeId4d1"] = this.loanPropertyGiftTypeId4d1;
    data["deposited4d2"] = this.deposited4d2;
    data["source4d3"] = this.source4d3;
    data["value4d4"] = this.value4d4;
    return data;
  }

  clone(): AddLoanAndPropertyInformationGiftRequest {
    const json = this.toJSON();
    let result = new AddLoanAndPropertyInformationGiftRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanAndPropertyInformationGiftRequest {
  applicationPersonalInformationId: number | undefined;
  loanPropertyGiftTypeId4d1: number | undefined;
  deposited4d2: number | undefined;
  source4d3: string | undefined;
  value4d4: number | undefined;
}

export class AddLoanAndPropertyInformationOtherMortageLoanRequest
  implements IAddLoanAndPropertyInformationOtherMortageLoanRequest {
  applicationPersonalInformationId: number | undefined;
  creditorName4b1: string | undefined;
  lienType4b2: string | undefined;
  monthlyPayment4b3: number | undefined;
  loanAmount4b4: number | undefined;
  creditAmount4b5: number | undefined;

  constructor(data?: IAddLoanAndPropertyInformationOtherMortageLoanRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.creditorName4b1 = _data["creditorName4b1"];
      this.lienType4b2 = _data["lienType4b2"];
      this.monthlyPayment4b3 = _data["monthlyPayment4b3"];
      this.loanAmount4b4 = _data["loanAmount4b4"];
      this.creditAmount4b5 = _data["creditAmount4b5"];
    }
  }

  static fromJS(
    data: any
  ): AddLoanAndPropertyInformationOtherMortageLoanRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanAndPropertyInformationOtherMortageLoanRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["creditorName4b1"] = this.creditorName4b1;
    data["lienType4b2"] = this.lienType4b2;
    data["monthlyPayment4b3"] = this.monthlyPayment4b3;
    data["loanAmount4b4"] = this.loanAmount4b4;
    data["creditAmount4b5"] = this.creditAmount4b5;
    return data;
  }

  clone(): AddLoanAndPropertyInformationOtherMortageLoanRequest {
    const json = this.toJSON();
    let result = new AddLoanAndPropertyInformationOtherMortageLoanRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanAndPropertyInformationOtherMortageLoanRequest {
  applicationPersonalInformationId: number | undefined;
  creditorName4b1: string | undefined;
  lienType4b2: string | undefined;
  monthlyPayment4b3: number | undefined;
  loanAmount4b4: number | undefined;
  creditAmount4b5: number | undefined;
}

export class AddLoanAndPropertyInformationRentalIncomeRequest
  implements IAddLoanAndPropertyInformationRentalIncomeRequest {
  applicationPersonalInformationId: number | undefined;
  expectedMonthlyIncome4c1: number | undefined;
  lenderExpectedMonthlyIncome4c2: number | undefined;

  constructor(data?: IAddLoanAndPropertyInformationRentalIncomeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.expectedMonthlyIncome4c1 = _data["expectedMonthlyIncome4c1"];
      this.lenderExpectedMonthlyIncome4c2 =
        _data["lenderExpectedMonthlyIncome4c2"];
    }
  }

  static fromJS(data: any): AddLoanAndPropertyInformationRentalIncomeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanAndPropertyInformationRentalIncomeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["expectedMonthlyIncome4c1"] = this.expectedMonthlyIncome4c1;
    data[
      "lenderExpectedMonthlyIncome4c2"
    ] = this.lenderExpectedMonthlyIncome4c2;
    return data;
  }

  clone(): AddLoanAndPropertyInformationRentalIncomeRequest {
    const json = this.toJSON();
    let result = new AddLoanAndPropertyInformationRentalIncomeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanAndPropertyInformationRentalIncomeRequest {
  applicationPersonalInformationId: number | undefined;
  expectedMonthlyIncome4c1: number | undefined;
  lenderExpectedMonthlyIncome4c2: number | undefined;
}

export class AddLoanAndPropertyInformationRequest
  implements IAddLoanAndPropertyInformationRequest {
  applicationPersonalInformationId: number | undefined;
  loanAmount4a1: number | undefined;
  loanPurpose4a2: string | undefined;
  propertyStreet4a31: string | undefined;
  propertyUnitNo4a32: string | undefined;
  propertyZip4a35: string | undefined;
  countryId4a36: number;
  stateId4a34: number;
  cityId4a33: number;
  propertyNumberUnits4a4: number | undefined;
  propertyValue4a5: number | undefined;
  loanPropertyOccupancyId4a6: number | undefined;
  fhaSecondaryResidance4a61: number | undefined;
  isMixedUseProperty4a7: number | undefined;
  isManufacturedHome4a8: number | undefined;

  constructor(data?: IAddLoanAndPropertyInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.loanAmount4a1 = _data["loanAmount4a1"];
      this.loanPurpose4a2 = _data["loanPurpose4a2"];
      this.propertyStreet4a31 = _data["propertyStreet4a31"];
      this.propertyUnitNo4a32 = _data["propertyUnitNo4a32"];
      this.propertyZip4a35 = _data["propertyZip4a35"];
      this.countryId4a36 = _data["countryId4a36"];
      this.stateId4a34 = _data["stateId4a34"];
      this.cityId4a33 = _data["cityId4a33"];
      this.propertyNumberUnits4a4 = _data["propertyNumberUnits4a4"];
      this.propertyValue4a5 = _data["propertyValue4a5"];
      this.loanPropertyOccupancyId4a6 = _data["loanPropertyOccupancyId4a6"];
      this.fhaSecondaryResidance4a61 = _data["fhaSecondaryResidance4a61"];
      this.isMixedUseProperty4a7 = _data["isMixedUseProperty4a7"];
      this.isManufacturedHome4a8 = _data["isManufacturedHome4a8"];
    }
  }

  static fromJS(data: any): AddLoanAndPropertyInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanAndPropertyInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["loanAmount4a1"] = this.loanAmount4a1;
    data["loanPurpose4a2"] = this.loanPurpose4a2;
    data["propertyStreet4a31"] = this.propertyStreet4a31;
    data["propertyUnitNo4a32"] = this.propertyUnitNo4a32;
    data["propertyZip4a35"] = this.propertyZip4a35;
    data["countryId4a36"] = this.countryId4a36;
    data["stateId4a34"] = this.stateId4a34;
    data["cityId4a33"] = this.cityId4a33;
    data["propertyNumberUnits4a4"] = this.propertyNumberUnits4a4;
    data["propertyValue4a5"] = this.propertyValue4a5;
    data["loanPropertyOccupancyId4a6"] = this.loanPropertyOccupancyId4a6;
    data["fhaSecondaryResidance4a61"] = this.fhaSecondaryResidance4a61;
    data["isMixedUseProperty4a7"] = this.isMixedUseProperty4a7;
    data["isManufacturedHome4a8"] = this.isManufacturedHome4a8;
    return data;
  }

  clone(): AddLoanAndPropertyInformationRequest {
    const json = this.toJSON();
    let result = new AddLoanAndPropertyInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanAndPropertyInformationRequest {
  applicationPersonalInformationId: number | undefined;
  loanAmount4a1: number | undefined;
  loanPurpose4a2: string | undefined;
  propertyStreet4a31: string | undefined;
  propertyUnitNo4a32: string | undefined;
  propertyZip4a35: string | undefined;
  countryId4a36: number;
  stateId4a34: number;
  cityId4a33: number;
  propertyNumberUnits4a4: number | undefined;
  propertyValue4a5: number | undefined;
  loanPropertyOccupancyId4a6: number | undefined;
  fhaSecondaryResidance4a61: number | undefined;
  isMixedUseProperty4a7: number | undefined;
  isManufacturedHome4a8: number | undefined;
}

export class AddLoanOriginatorInformationRequest
  implements IAddLoanOriginatorInformationRequest {
  applicationPersonalInformationId: number | undefined;
  organizationName91: string | undefined;
  address92: string | undefined;
  organizationNmlsrId93: string | undefined;
  organizationStateLicence94: string | undefined;
  originatorName95: string | undefined;
  originatorNmlsrId96: string | undefined;
  originatorStateLicense97: string | undefined;
  email98: string | undefined;
  phone99: string | undefined;
  date910: moment.Moment | undefined;

  constructor(data?: IAddLoanOriginatorInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.organizationName91 = _data["organizationName91"];
      this.address92 = _data["address92"];
      this.organizationNmlsrId93 = _data["organizationNmlsrId93"];
      this.organizationStateLicence94 = _data["organizationStateLicence94"];
      this.originatorName95 = _data["originatorName95"];
      this.originatorNmlsrId96 = _data["originatorNmlsrId96"];
      this.originatorStateLicense97 = _data["originatorStateLicense97"];
      this.email98 = _data["email98"];
      this.phone99 = _data["phone99"];
      this.date910 = _data["date910"]
        ? moment(_data["date910"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddLoanOriginatorInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanOriginatorInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["organizationName91"] = this.organizationName91;
    data["address92"] = this.address92;
    data["organizationNmlsrId93"] = this.organizationNmlsrId93;
    data["organizationStateLicence94"] = this.organizationStateLicence94;
    data["originatorName95"] = this.originatorName95;
    data["originatorNmlsrId96"] = this.originatorNmlsrId96;
    data["originatorStateLicense97"] = this.originatorStateLicense97;
    data["email98"] = this.email98;
    data["phone99"] = this.phone99;
    data["date910"] = this.date910
      ? this.date910.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): AddLoanOriginatorInformationRequest {
    const json = this.toJSON();
    let result = new AddLoanOriginatorInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanOriginatorInformationRequest {
  applicationPersonalInformationId: number | undefined;
  organizationName91: string | undefined;
  address92: string | undefined;
  organizationNmlsrId93: string | undefined;
  organizationStateLicence94: string | undefined;
  originatorName95: string | undefined;
  originatorNmlsrId96: string | undefined;
  originatorStateLicense97: string | undefined;
  email98: string | undefined;
  phone99: string | undefined;
  date910: moment.Moment | undefined;
}

export class AddLoanPropertyGiftTypeRequest
  implements IAddLoanPropertyGiftTypeRequest {
  loanPropertyGiftType1: string | undefined;

  constructor(data?: IAddLoanPropertyGiftTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanPropertyGiftType1 = _data["loanPropertyGiftType1"];
    }
  }

  static fromJS(data: any): AddLoanPropertyGiftTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanPropertyGiftTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanPropertyGiftType1"] = this.loanPropertyGiftType1;
    return data;
  }

  clone(): AddLoanPropertyGiftTypeRequest {
    const json = this.toJSON();
    let result = new AddLoanPropertyGiftTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanPropertyGiftTypeRequest {
  loanPropertyGiftType1: string | undefined;
}

export class AddLoanPropertyOccupancyRequest
  implements IAddLoanPropertyOccupancyRequest {
  loanPropertyOccupancy1: string | undefined;

  constructor(data?: IAddLoanPropertyOccupancyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanPropertyOccupancy1 = _data["loanPropertyOccupancy1"];
    }
  }

  static fromJS(data: any): AddLoanPropertyOccupancyRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanPropertyOccupancyRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanPropertyOccupancy1"] = this.loanPropertyOccupancy1;
    return data;
  }

  clone(): AddLoanPropertyOccupancyRequest {
    const json = this.toJSON();
    let result = new AddLoanPropertyOccupancyRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanPropertyOccupancyRequest {
  loanPropertyOccupancy1: string | undefined;
}

export class AddMaritalStatusRequest implements IAddMaritalStatusRequest {
  maritialStatus1: string | undefined;

  constructor(data?: IAddMaritalStatusRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.maritialStatus1 = _data["maritialStatus1"];
    }
  }

  static fromJS(data: any): AddMaritalStatusRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddMaritalStatusRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["maritialStatus1"] = this.maritialStatus1;
    return data;
  }

  clone(): AddMaritalStatusRequest {
    const json = this.toJSON();
    let result = new AddMaritalStatusRequest();
    result.init(json);
    return result;
  }
}

export interface IAddMaritalStatusRequest {
  maritialStatus1: string | undefined;
}

export class AddMilitaryServiceRequest implements IAddMilitaryServiceRequest {
  applicationPersonalInformationId: number | undefined;
  servedInForces7a1: number | undefined;
  currentlyServing7a2: number | undefined;
  dateOfServiceExpiration7a3: moment.Moment | undefined;
  retired7a2: number | undefined;
  nonActivatedMember7a2: number | undefined;
  survivingSpouse7a21: number | undefined;

  constructor(data?: IAddMilitaryServiceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.servedInForces7a1 = _data["servedInForces7a1"];
      this.currentlyServing7a2 = _data["currentlyServing7a2"];
      this.dateOfServiceExpiration7a3 = _data["dateOfServiceExpiration7a3"]
        ? moment(_data["dateOfServiceExpiration7a3"].toString())
        : <any>undefined;
      this.retired7a2 = _data["retired7a2"];
      this.nonActivatedMember7a2 = _data["nonActivatedMember7a2"];
      this.survivingSpouse7a21 = _data["survivingSpouse7a21"];
    }
  }

  static fromJS(data: any): AddMilitaryServiceRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddMilitaryServiceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["servedInForces7a1"] = this.servedInForces7a1;
    data["currentlyServing7a2"] = this.currentlyServing7a2;
    data["dateOfServiceExpiration7a3"] = this.dateOfServiceExpiration7a3
      ? this.dateOfServiceExpiration7a3.toISOString()
      : <any>undefined;
    data["retired7a2"] = this.retired7a2;
    data["nonActivatedMember7a2"] = this.nonActivatedMember7a2;
    data["survivingSpouse7a21"] = this.survivingSpouse7a21;
    return data;
  }

  clone(): AddMilitaryServiceRequest {
    const json = this.toJSON();
    let result = new AddMilitaryServiceRequest();
    result.init(json);
    return result;
  }
}

export interface IAddMilitaryServiceRequest {
  applicationPersonalInformationId: number | undefined;
  servedInForces7a1: number | undefined;
  currentlyServing7a2: number | undefined;
  dateOfServiceExpiration7a3: moment.Moment | undefined;
  retired7a2: number | undefined;
  nonActivatedMember7a2: number | undefined;
  survivingSpouse7a21: number | undefined;
}

export class AddMortageLoanOnPropertyRequest
  implements IAddMortageLoanOnPropertyRequest {
  applicationFinancialRealEstateId: number | undefined;
  creditorName3a9: string | undefined;
  accountNumber3a10: string | undefined;
  monthlyMortagePayment3a11: number | undefined;
  unpaidBalance3a12: number | undefined;
  paidOff3a13: number | undefined;
  mortageLoanTypesId3a14: number;
  creditLimit3a15: number | undefined;

  constructor(data?: IAddMortageLoanOnPropertyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationFinancialRealEstateId =
        _data["applicationFinancialRealEstateId"];
      this.creditorName3a9 = _data["creditorName3a9"];
      this.accountNumber3a10 = _data["accountNumber3a10"];
      this.monthlyMortagePayment3a11 = _data["monthlyMortagePayment3a11"];
      this.unpaidBalance3a12 = _data["unpaidBalance3a12"];
      this.paidOff3a13 = _data["paidOff3a13"];
      this.mortageLoanTypesId3a14 = _data["mortageLoanTypesId3a14"];
      this.creditLimit3a15 = _data["creditLimit3a15"];
    }
  }

  static fromJS(data: any): AddMortageLoanOnPropertyRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddMortageLoanOnPropertyRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationFinancialRealEstateId"
    ] = this.applicationFinancialRealEstateId;
    data["creditorName3a9"] = this.creditorName3a9;
    data["accountNumber3a10"] = this.accountNumber3a10;
    data["monthlyMortagePayment3a11"] = this.monthlyMortagePayment3a11;
    data["unpaidBalance3a12"] = this.unpaidBalance3a12;
    data["paidOff3a13"] = this.paidOff3a13;
    data["mortageLoanTypesId3a14"] = this.mortageLoanTypesId3a14;
    data["creditLimit3a15"] = this.creditLimit3a15;
    return data;
  }

  clone(): AddMortageLoanOnPropertyRequest {
    const json = this.toJSON();
    let result = new AddMortageLoanOnPropertyRequest();
    result.init(json);
    return result;
  }
}

export interface IAddMortageLoanOnPropertyRequest {
  applicationFinancialRealEstateId: number | undefined;
  creditorName3a9: string | undefined;
  accountNumber3a10: string | undefined;
  monthlyMortagePayment3a11: number | undefined;
  unpaidBalance3a12: number | undefined;
  paidOff3a13: number | undefined;
  mortageLoanTypesId3a14: number;
  creditLimit3a15: number | undefined;
}

export class AddMortageLoanTypeRequest implements IAddMortageLoanTypeRequest {
  mortageLoanTypesId: string | undefined;

  constructor(data?: IAddMortageLoanTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.mortageLoanTypesId = _data["mortageLoanTypesId"];
    }
  }

  static fromJS(data: any): AddMortageLoanTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddMortageLoanTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["mortageLoanTypesId"] = this.mortageLoanTypesId;
    return data;
  }

  clone(): AddMortageLoanTypeRequest {
    const json = this.toJSON();
    let result = new AddMortageLoanTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddMortageLoanTypeRequest {
  mortageLoanTypesId: string | undefined;
}

export class AddOtherLaibilitiesTypeRequest
  implements IAddOtherLaibilitiesTypeRequest {
  financialOtherLaibilitiesType1: string | undefined;

  constructor(data?: IAddOtherLaibilitiesTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialOtherLaibilitiesType1 =
        _data["financialOtherLaibilitiesType1"];
    }
  }

  static fromJS(data: any): AddOtherLaibilitiesTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddOtherLaibilitiesTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "financialOtherLaibilitiesType1"
    ] = this.financialOtherLaibilitiesType1;
    return data;
  }

  clone(): AddOtherLaibilitiesTypeRequest {
    const json = this.toJSON();
    let result = new AddOtherLaibilitiesTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddOtherLaibilitiesTypeRequest {
  financialOtherLaibilitiesType1: string | undefined;
}

export class AddPersonalInformationRequest
  implements IAddPersonalInformationRequest {
  applicationId: number;
  firstName1a1: string | undefined;
  middleName1a2: string | undefined;
  lastName1a3: string | undefined;
  suffix1a4: string | undefined;
  alternateFirstName1a21: string | undefined;
  alternateMiddleName1a22: string | undefined;
  alternateLastName1a23: string | undefined;
  alternateSuffix1a24: string | undefined;
  ssn1a3: string | undefined;
  dob1a4: moment.Moment | undefined;
  citizenshipTypeId1a5: number;
  maritialStatusId1a7: number;
  dependents1a8: number | undefined;
  ages1a81: string | undefined;
  homePhone1a9: string | undefined;
  cellPhone1a10: string | undefined;
  workPhone1a11: string | undefined;
  ext1a111: string | undefined;
  email1a12: string | undefined;
  currentStreet1a131: string | undefined;
  currentUnit1a132: string | undefined;
  currentZip1a135: string | undefined;
  currentCountryId1a136: number;
  currentStateId1a134: number;
  currentCityId1a133: number;
  currentYears1a14: number | undefined;
  currentMonths1a15: number | undefined;
  currentHousingTypeId1a141: number;
  currentRent1a142: number | undefined;
  formerStreet1a151: string | undefined;
  formerUnit1a152: string | undefined;
  formerZip1a155: string | undefined;
  formerCountryId1a156: number;
  formerStateId1a154: number;
  formerCityId1a153: number;
  formerYears1a16: number | undefined;
  formerMonths1a161: number | undefined;
  formerHousingTypeId1a161: number;
  formerRent1a162: number | undefined;
  mailingStreet1a171: string | undefined;
  mailingUnit1a172: string | undefined;
  mailingZip1a175: string | undefined;
  mailingCountryId1a176: number;
  mailingStateId1a174: number;
  mailingCityId1a173: number;

  constructor(data?: IAddPersonalInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationId = _data["applicationId"];
      this.firstName1a1 = _data["firstName1a1"];
      this.middleName1a2 = _data["middleName1a2"];
      this.lastName1a3 = _data["lastName1a3"];
      this.suffix1a4 = _data["suffix1a4"];
      this.alternateFirstName1a21 = _data["alternateFirstName1a21"];
      this.alternateMiddleName1a22 = _data["alternateMiddleName1a22"];
      this.alternateLastName1a23 = _data["alternateLastName1a23"];
      this.alternateSuffix1a24 = _data["alternateSuffix1a24"];
      this.ssn1a3 = _data["ssn1a3"];
      this.dob1a4 = _data["dob1a4"]
        ? moment(_data["dob1a4"].toString())
        : <any>undefined;
      this.citizenshipTypeId1a5 = _data["citizenshipTypeId1a5"];
      this.maritialStatusId1a7 = _data["maritialStatusId1a7"];
      this.dependents1a8 = _data["dependents1a8"];
      this.ages1a81 = _data["ages1a81"];
      this.homePhone1a9 = _data["homePhone1a9"];
      this.cellPhone1a10 = _data["cellPhone1a10"];
      this.workPhone1a11 = _data["workPhone1a11"];
      this.ext1a111 = _data["ext1a111"];
      this.email1a12 = _data["email1a12"];
      this.currentStreet1a131 = _data["currentStreet1a131"];
      this.currentUnit1a132 = _data["currentUnit1a132"];
      this.currentZip1a135 = _data["currentZip1a135"];
      this.currentCountryId1a136 = _data["currentCountryId1a136"];
      this.currentStateId1a134 = _data["currentStateId1a134"];
      this.currentCityId1a133 = _data["currentCityId1a133"];
      this.currentYears1a14 = _data["currentYears1a14"];
      this.currentMonths1a15 = _data["currentMonths1a15"];
      this.currentHousingTypeId1a141 = _data["currentHousingTypeId1a141"];
      this.currentRent1a142 = _data["currentRent1a142"];
      this.formerStreet1a151 = _data["formerStreet1a151"];
      this.formerUnit1a152 = _data["formerUnit1a152"];
      this.formerZip1a155 = _data["formerZip1a155"];
      this.formerCountryId1a156 = _data["formerCountryId1a156"];
      this.formerStateId1a154 = _data["formerStateId1a154"];
      this.formerCityId1a153 = _data["formerCityId1a153"];
      this.formerYears1a16 = _data["formerYears1a16"];
      this.formerMonths1a161 = _data["formerMonths1a161"];
      this.formerHousingTypeId1a161 = _data["formerHousingTypeId1a161"];
      this.formerRent1a162 = _data["formerRent1a162"];
      this.mailingStreet1a171 = _data["mailingStreet1a171"];
      this.mailingUnit1a172 = _data["mailingUnit1a172"];
      this.mailingZip1a175 = _data["mailingZip1a175"];
      this.mailingCountryId1a176 = _data["mailingCountryId1a176"];
      this.mailingStateId1a174 = _data["mailingStateId1a174"];
      this.mailingCityId1a173 = _data["mailingCityId1a173"];
    }
  }

  static fromJS(data: any): AddPersonalInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddPersonalInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["applicationId"] = this.applicationId;
    data["firstName1a1"] = this.firstName1a1;
    data["middleName1a2"] = this.middleName1a2;
    data["lastName1a3"] = this.lastName1a3;
    data["suffix1a4"] = this.suffix1a4;
    data["alternateFirstName1a21"] = this.alternateFirstName1a21;
    data["alternateMiddleName1a22"] = this.alternateMiddleName1a22;
    data["alternateLastName1a23"] = this.alternateLastName1a23;
    data["alternateSuffix1a24"] = this.alternateSuffix1a24;
    data["ssn1a3"] = this.ssn1a3;
    data["dob1a4"] = this.dob1a4 ? this.dob1a4.toISOString() : <any>undefined;
    data["citizenshipTypeId1a5"] = this.citizenshipTypeId1a5;
    data["maritialStatusId1a7"] = this.maritialStatusId1a7;
    data["dependents1a8"] = this.dependents1a8;
    data["ages1a81"] = this.ages1a81;
    data["homePhone1a9"] = this.homePhone1a9;
    data["cellPhone1a10"] = this.cellPhone1a10;
    data["workPhone1a11"] = this.workPhone1a11;
    data["ext1a111"] = this.ext1a111;
    data["email1a12"] = this.email1a12;
    data["currentStreet1a131"] = this.currentStreet1a131;
    data["currentUnit1a132"] = this.currentUnit1a132;
    data["currentZip1a135"] = this.currentZip1a135;
    data["currentCountryId1a136"] = this.currentCountryId1a136;
    data["currentStateId1a134"] = this.currentStateId1a134;
    data["currentCityId1a133"] = this.currentCityId1a133;
    data["currentYears1a14"] = this.currentYears1a14;
    data["currentMonths1a15"] = this.currentMonths1a15;
    data["currentHousingTypeId1a141"] = this.currentHousingTypeId1a141;
    data["currentRent1a142"] = this.currentRent1a142;
    data["formerStreet1a151"] = this.formerStreet1a151;
    data["formerUnit1a152"] = this.formerUnit1a152;
    data["formerZip1a155"] = this.formerZip1a155;
    data["formerCountryId1a156"] = this.formerCountryId1a156;
    data["formerStateId1a154"] = this.formerStateId1a154;
    data["formerCityId1a153"] = this.formerCityId1a153;
    data["formerYears1a16"] = this.formerYears1a16;
    data["formerMonths1a161"] = this.formerMonths1a161;
    data["formerHousingTypeId1a161"] = this.formerHousingTypeId1a161;
    data["formerRent1a162"] = this.formerRent1a162;
    data["mailingStreet1a171"] = this.mailingStreet1a171;
    data["mailingUnit1a172"] = this.mailingUnit1a172;
    data["mailingZip1a175"] = this.mailingZip1a175;
    data["mailingCountryId1a176"] = this.mailingCountryId1a176;
    data["mailingStateId1a174"] = this.mailingStateId1a174;
    data["mailingCityId1a173"] = this.mailingCityId1a173;
    return data;
  }

  clone(): AddPersonalInformationRequest {
    const json = this.toJSON();
    let result = new AddPersonalInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IAddPersonalInformationRequest {
  applicationId: number;
  firstName1a1: string | undefined;
  middleName1a2: string | undefined;
  lastName1a3: string | undefined;
  suffix1a4: string | undefined;
  alternateFirstName1a21: string | undefined;
  alternateMiddleName1a22: string | undefined;
  alternateLastName1a23: string | undefined;
  alternateSuffix1a24: string | undefined;
  ssn1a3: string | undefined;
  dob1a4: moment.Moment | undefined;
  citizenshipTypeId1a5: number;
  maritialStatusId1a7: number;
  dependents1a8: number | undefined;
  ages1a81: string | undefined;
  homePhone1a9: string | undefined;
  cellPhone1a10: string | undefined;
  workPhone1a11: string | undefined;
  ext1a111: string | undefined;
  email1a12: string | undefined;
  currentStreet1a131: string | undefined;
  currentUnit1a132: string | undefined;
  currentZip1a135: string | undefined;
  currentCountryId1a136: number;
  currentStateId1a134: number;
  currentCityId1a133: number;
  currentYears1a14: number | undefined;
  currentMonths1a15: number | undefined;
  currentHousingTypeId1a141: number;
  currentRent1a142: number | undefined;
  formerStreet1a151: string | undefined;
  formerUnit1a152: string | undefined;
  formerZip1a155: string | undefined;
  formerCountryId1a156: number;
  formerStateId1a154: number;
  formerCityId1a153: number;
  formerYears1a16: number | undefined;
  formerMonths1a161: number | undefined;
  formerHousingTypeId1a161: number;
  formerRent1a162: number | undefined;
  mailingStreet1a171: string | undefined;
  mailingUnit1a172: string | undefined;
  mailingZip1a175: string | undefined;
  mailingCountryId1a176: number;
  mailingStateId1a174: number;
  mailingCityId1a173: number;
}

export class AddPreviousEmployementDetailRequest
  implements IAddPreviousEmployementDetailRequest {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName1d2: string | undefined;
  street1d31: string | undefined;
  unit1d32: string | undefined;
  zip1d35: string | undefined;
  countryId1d36: number;
  stateId1d34: number;
  cityId1d33: number;
  positionTitle1d4: string | undefined;
  startDate1d5: moment.Moment | undefined;
  endDate1d6: moment.Moment | undefined;
  isSelfEmployed1d7: number | undefined;
  grossMonthlyIncome1d8: number | undefined;

  constructor(data?: IAddPreviousEmployementDetailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.employerBusinessName1d2 = _data["employerBusinessName1d2"];
      this.street1d31 = _data["street1d31"];
      this.unit1d32 = _data["unit1d32"];
      this.zip1d35 = _data["zip1d35"];
      this.countryId1d36 = _data["countryId1d36"];
      this.stateId1d34 = _data["stateId1d34"];
      this.cityId1d33 = _data["cityId1d33"];
      this.positionTitle1d4 = _data["positionTitle1d4"];
      this.startDate1d5 = _data["startDate1d5"]
        ? moment(_data["startDate1d5"].toString())
        : <any>undefined;
      this.endDate1d6 = _data["endDate1d6"]
        ? moment(_data["endDate1d6"].toString())
        : <any>undefined;
      this.isSelfEmployed1d7 = _data["isSelfEmployed1d7"];
      this.grossMonthlyIncome1d8 = _data["grossMonthlyIncome1d8"];
    }
  }

  static fromJS(data: any): AddPreviousEmployementDetailRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddPreviousEmployementDetailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["employerBusinessName1d2"] = this.employerBusinessName1d2;
    data["street1d31"] = this.street1d31;
    data["unit1d32"] = this.unit1d32;
    data["zip1d35"] = this.zip1d35;
    data["countryId1d36"] = this.countryId1d36;
    data["stateId1d34"] = this.stateId1d34;
    data["cityId1d33"] = this.cityId1d33;
    data["positionTitle1d4"] = this.positionTitle1d4;
    data["startDate1d5"] = this.startDate1d5
      ? this.startDate1d5.toISOString()
      : <any>undefined;
    data["endDate1d6"] = this.endDate1d6
      ? this.endDate1d6.toISOString()
      : <any>undefined;
    data["isSelfEmployed1d7"] = this.isSelfEmployed1d7;
    data["grossMonthlyIncome1d8"] = this.grossMonthlyIncome1d8;
    return data;
  }

  clone(): AddPreviousEmployementDetailRequest {
    const json = this.toJSON();
    let result = new AddPreviousEmployementDetailRequest();
    result.init(json);
    return result;
  }
}

export interface IAddPreviousEmployementDetailRequest {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName1d2: string | undefined;
  street1d31: string | undefined;
  unit1d32: string | undefined;
  zip1d35: string | undefined;
  countryId1d36: number;
  stateId1d34: number;
  cityId1d33: number;
  positionTitle1d4: string | undefined;
  startDate1d5: moment.Moment | undefined;
  endDate1d6: moment.Moment | undefined;
  isSelfEmployed1d7: number | undefined;
  grossMonthlyIncome1d8: number | undefined;
}

export class AddPropertyIntendedOccupancyRequest
  implements IAddPropertyIntendedOccupancyRequest {
  financialPropertyIntendedOccupancy1: string | undefined;

  constructor(data?: IAddPropertyIntendedOccupancyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialPropertyIntendedOccupancy1 =
        _data["financialPropertyIntendedOccupancy1"];
    }
  }

  static fromJS(data: any): AddPropertyIntendedOccupancyRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddPropertyIntendedOccupancyRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "financialPropertyIntendedOccupancy1"
    ] = this.financialPropertyIntendedOccupancy1;
    return data;
  }

  clone(): AddPropertyIntendedOccupancyRequest {
    const json = this.toJSON();
    let result = new AddPropertyIntendedOccupancyRequest();
    result.init(json);
    return result;
  }
}

export interface IAddPropertyIntendedOccupancyRequest {
  financialPropertyIntendedOccupancy1: string | undefined;
}

export class AddPropertyStatusRequest implements IAddPropertyStatusRequest {
  financialPropertyStatus1: string | undefined;

  constructor(data?: IAddPropertyStatusRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialPropertyStatus1 = _data["financialPropertyStatus1"];
    }
  }

  static fromJS(data: any): AddPropertyStatusRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddPropertyStatusRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialPropertyStatus1"] = this.financialPropertyStatus1;
    return data;
  }

  clone(): AddPropertyStatusRequest {
    const json = this.toJSON();
    let result = new AddPropertyStatusRequest();
    result.init(json);
    return result;
  }
}

export interface IAddPropertyStatusRequest {
  financialPropertyStatus1: string | undefined;
}

export class AddStateRequest implements IAddStateRequest {
  countryId: number;
  stateName: string | undefined;

  constructor(data?: IAddStateRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.countryId = _data["countryId"];
      this.stateName = _data["stateName"];
    }
  }

  static fromJS(data: any): AddStateRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddStateRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["countryId"] = this.countryId;
    data["stateName"] = this.stateName;
    return data;
  }

  clone(): AddStateRequest {
    const json = this.toJSON();
    let result = new AddStateRequest();
    result.init(json);
    return result;
  }
}

export interface IAddStateRequest {
  countryId: number;
  stateName: string | undefined;
}

export class AdditionalDetail implements IAdditionalDetail {
  id: number;
  nameOfIndividualsOnTitle: string | undefined;
  nameOfIndividualsCoBorrowerOnTitle: string | undefined;

  constructor(data?: IAdditionalDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.nameOfIndividualsOnTitle = _data["nameOfIndividualsOnTitle"];
      this.nameOfIndividualsCoBorrowerOnTitle =
        _data["nameOfIndividualsCoBorrowerOnTitle"];
    }
  }

  static fromJS(data: any): AdditionalDetail {
    data = typeof data === "object" ? data : {};
    let result = new AdditionalDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["nameOfIndividualsOnTitle"] = this.nameOfIndividualsOnTitle;
    data[
      "nameOfIndividualsCoBorrowerOnTitle"
    ] = this.nameOfIndividualsCoBorrowerOnTitle;
    return data;
  }

  clone(): AdditionalDetail {
    const json = this.toJSON();
    let result = new AdditionalDetail();
    result.init(json);
    return result;
  }
}

export interface IAdditionalDetail {
  id: number;
  nameOfIndividualsOnTitle: string | undefined;
  nameOfIndividualsCoBorrowerOnTitle: string | undefined;
}

export class AdditionalDetailsDto implements IAdditionalDetailsDto {
  id: number | undefined;
  nameOfIndividualsOnTitle: string | undefined;
  nameOfIndividualsCoBorrowerOnTitle: string | undefined;

  constructor(data?: IAdditionalDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.nameOfIndividualsOnTitle = _data["nameOfIndividualsOnTitle"];
      this.nameOfIndividualsCoBorrowerOnTitle =
        _data["nameOfIndividualsCoBorrowerOnTitle"];
    }
  }

  static fromJS(data: any): AdditionalDetailsDto {
    data = typeof data === "object" ? data : {};
    let result = new AdditionalDetailsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["nameOfIndividualsOnTitle"] = this.nameOfIndividualsOnTitle;
    data[
      "nameOfIndividualsCoBorrowerOnTitle"
    ] = this.nameOfIndividualsCoBorrowerOnTitle;
    return data;
  }

  clone(): AdditionalDetailsDto {
    const json = this.toJSON();
    let result = new AdditionalDetailsDto();
    result.init(json);
    return result;
  }
}

export interface IAdditionalDetailsDto {
  id: number | undefined;
  nameOfIndividualsOnTitle: string | undefined;
  nameOfIndividualsCoBorrowerOnTitle: string | undefined;
}

export class AdditionalDetailsDtoPagedResultDto
  implements IAdditionalDetailsDtoPagedResultDto {
  items: AdditionalDetailsDto[] | undefined;
  totalCount: number;

  constructor(data?: IAdditionalDetailsDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(AdditionalDetailsDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): AdditionalDetailsDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new AdditionalDetailsDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): AdditionalDetailsDtoPagedResultDto {
    const json = this.toJSON();
    let result = new AdditionalDetailsDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IAdditionalDetailsDtoPagedResultDto {
  items: AdditionalDetailsDto[] | undefined;
  totalCount: number;
}

export class AdditionalIncome implements IAdditionalIncome {
  id: number;
  amount: number | undefined;
  incomeSourceId: number | undefined;
  borrowerTypeId: number | undefined;
  loanApplicationId: number;
  borrowerType: BorrowerType;
  loanApplication: LoanApplication;
  incomeSource: IncomeSource;

  constructor(data?: IAdditionalIncome) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.amount = _data["amount"];
      this.incomeSourceId = _data["incomeSourceId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerType = _data["borrowerType"]
        ? BorrowerType.fromJS(_data["borrowerType"])
        : <any>undefined;
      this.loanApplication = _data["loanApplication"]
        ? LoanApplication.fromJS(_data["loanApplication"])
        : <any>undefined;
      this.incomeSource = _data["incomeSource"]
        ? IncomeSource.fromJS(_data["incomeSource"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): AdditionalIncome {
    data = typeof data === "object" ? data : {};
    let result = new AdditionalIncome();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["amount"] = this.amount;
    data["incomeSourceId"] = this.incomeSourceId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    data["loanApplication"] = this.loanApplication
      ? this.loanApplication.toJSON()
      : <any>undefined;
    data["incomeSource"] = this.incomeSource
      ? this.incomeSource.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): AdditionalIncome {
    const json = this.toJSON();
    let result = new AdditionalIncome();
    result.init(json);
    return result;
  }
}

export interface IAdditionalIncome {
  id: number;
  amount: number | undefined;
  incomeSourceId: number | undefined;
  borrowerTypeId: number | undefined;
  loanApplicationId: number;
  borrowerType: BorrowerType;
  loanApplication: LoanApplication;
  incomeSource: IncomeSource;
}

export class AdditionalIncomeDto implements IAdditionalIncomeDto {
  id: number | undefined;
  amount: number | undefined;
  incomeSourceId: number | undefined;
  borrowerTypeId: number | undefined;
  loanApplicationId: number;

  constructor(data?: IAdditionalIncomeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.amount = _data["amount"];
      this.incomeSourceId = _data["incomeSourceId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplicationId = _data["loanApplicationId"];
    }
  }

  static fromJS(data: any): AdditionalIncomeDto {
    data = typeof data === "object" ? data : {};
    let result = new AdditionalIncomeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["amount"] = this.amount;
    data["incomeSourceId"] = this.incomeSourceId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplicationId"] = this.loanApplicationId;
    return data;
  }

  clone(): AdditionalIncomeDto {
    const json = this.toJSON();
    let result = new AdditionalIncomeDto();
    result.init(json);
    return result;
  }
}

export interface IAdditionalIncomeDto {
  id: number | undefined;
  amount: number | undefined;
  incomeSourceId: number | undefined;
  borrowerTypeId: number | undefined;
  loanApplicationId: number;
}

export class AdditionalIncomeDtoPagedResultDto
  implements IAdditionalIncomeDtoPagedResultDto {
  items: AdditionalIncomeDto[] | undefined;
  totalCount: number;

  constructor(data?: IAdditionalIncomeDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(AdditionalIncomeDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): AdditionalIncomeDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new AdditionalIncomeDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): AdditionalIncomeDtoPagedResultDto {
    const json = this.toJSON();
    let result = new AdditionalIncomeDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IAdditionalIncomeDtoPagedResultDto {
  items: AdditionalIncomeDto[] | undefined;
  totalCount: number;
}

export class Address implements IAddress {
  id: number;
  addressType: string | undefined;
  addressLine1: string | undefined;
  addressLine2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  years: number | undefined;
  months: number | undefined;
  personalDetailId: number;
  borrowerTypeId: number;
  personalDetail: PersonalDetail;
  state: State;
  borrowerType: BorrowerType;

  constructor(data?: IAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.addressType = _data["addressType"];
      this.addressLine1 = _data["addressLine1"];
      this.addressLine2 = _data["addressLine2"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.zipCode = _data["zipCode"];
      this.years = _data["years"];
      this.months = _data["months"];
      this.personalDetailId = _data["personalDetailId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.personalDetail = _data["personalDetail"]
        ? PersonalDetail.fromJS(_data["personalDetail"])
        : <any>undefined;
      this.state = _data["state"]
        ? State.fromJS(_data["state"])
        : <any>undefined;
      this.borrowerType = _data["borrowerType"]
        ? BorrowerType.fromJS(_data["borrowerType"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Address {
    data = typeof data === "object" ? data : {};
    let result = new Address();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["addressType"] = this.addressType;
    data["addressLine1"] = this.addressLine1;
    data["addressLine2"] = this.addressLine2;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["zipCode"] = this.zipCode;
    data["years"] = this.years;
    data["months"] = this.months;
    data["personalDetailId"] = this.personalDetailId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["personalDetail"] = this.personalDetail
      ? this.personalDetail.toJSON()
      : <any>undefined;
    data["state"] = this.state ? this.state.toJSON() : <any>undefined;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): Address {
    const json = this.toJSON();
    let result = new Address();
    result.init(json);
    return result;
  }
}

export interface IAddress {
  id: number;
  addressType: string | undefined;
  addressLine1: string | undefined;
  addressLine2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  years: number | undefined;
  months: number | undefined;
  personalDetailId: number;
  borrowerTypeId: number;
  personalDetail: PersonalDetail;
  state: State;
  borrowerType: BorrowerType;
}

export class AddressDto implements IAddressDto {
  id: number | undefined;
  addressLine1: string | undefined;
  addressLine2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  years: number | undefined;
  months: number | undefined;

  constructor(data?: IAddressDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.addressLine1 = _data["addressLine1"];
      this.addressLine2 = _data["addressLine2"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.zipCode = _data["zipCode"];
      this.years = _data["years"];
      this.months = _data["months"];
    }
  }

  static fromJS(data: any): AddressDto {
    data = typeof data === "object" ? data : {};
    let result = new AddressDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["addressLine1"] = this.addressLine1;
    data["addressLine2"] = this.addressLine2;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["zipCode"] = this.zipCode;
    data["years"] = this.years;
    data["months"] = this.months;
    return data;
  }

  clone(): AddressDto {
    const json = this.toJSON();
    let result = new AddressDto();
    result.init(json);
    return result;
  }
}

export interface IAddressDto {
  id: number | undefined;
  addressLine1: string | undefined;
  addressLine2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  years: number | undefined;
  months: number | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
  version: string | undefined;
  releaseDate: moment.Moment;
  features: { [key: string]: boolean } | undefined;

  constructor(data?: IApplicationInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.version = _data["version"];
      this.releaseDate = _data["releaseDate"]
        ? moment(_data["releaseDate"].toString())
        : <any>undefined;
      if (_data["features"]) {
        this.features = {} as any;
        for (let key in _data["features"]) {
          if (_data["features"].hasOwnProperty(key))
            (<any>this.features)[key] = _data["features"][key];
        }
      }
    }
  }

  static fromJS(data: any): ApplicationInfoDto {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["version"] = this.version;
    data["releaseDate"] = this.releaseDate
      ? this.releaseDate.toISOString()
      : <any>undefined;
    if (this.features) {
      data["features"] = {};
      for (let key in this.features) {
        if (this.features.hasOwnProperty(key))
          (<any>data["features"])[key] = this.features[key];
      }
    }
    return data;
  }

  clone(): ApplicationInfoDto {
    const json = this.toJSON();
    let result = new ApplicationInfoDto();
    result.init(json);
    return result;
  }
}

export interface IApplicationInfoDto {
  version: string | undefined;
  releaseDate: moment.Moment;
  features: { [key: string]: boolean } | undefined;
}

export class AssetType implements IAssetType {
  id: number;
  name: string | undefined;
  manualAssetEntries: ManualAssetEntry[] | undefined;

  constructor(data?: IAssetType) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      if (Array.isArray(_data["manualAssetEntries"])) {
        this.manualAssetEntries = [] as any;
        for (let item of _data["manualAssetEntries"])
          this.manualAssetEntries.push(ManualAssetEntry.fromJS(item));
      }
    }
  }

  static fromJS(data: any): AssetType {
    data = typeof data === "object" ? data : {};
    let result = new AssetType();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    if (Array.isArray(this.manualAssetEntries)) {
      data["manualAssetEntries"] = [];
      for (let item of this.manualAssetEntries)
        data["manualAssetEntries"].push(item.toJSON());
    }
    return data;
  }

  clone(): AssetType {
    const json = this.toJSON();
    let result = new AssetType();
    result.init(json);
    return result;
  }
}

export interface IAssetType {
  id: number;
  name: string | undefined;
  manualAssetEntries: ManualAssetEntry[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
  userNameOrEmailAddress: string;
  password: string;
  rememberClient: boolean;

  constructor(data?: IAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
      this.password = _data["password"];
      this.rememberClient = _data["rememberClient"];
    }
  }

  static fromJS(data: any): AuthenticateModel {
    data = typeof data === "object" ? data : {};
    let result = new AuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
    data["password"] = this.password;
    data["rememberClient"] = this.rememberClient;
    return data;
  }

  clone(): AuthenticateModel {
    const json = this.toJSON();
    let result = new AuthenticateModel();
    result.init(json);
    return result;
  }
}

export interface IAuthenticateModel {
  userNameOrEmailAddress: string;
  password: string;
  rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  userId: number;

  constructor(data?: IAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data["accessToken"];
      this.encryptedAccessToken = _data["encryptedAccessToken"];
      this.expireInSeconds = _data["expireInSeconds"];
      this.userId = _data["userId"];
    }
  }

  static fromJS(data: any): AuthenticateResultModel {
    data = typeof data === "object" ? data : {};
    let result = new AuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["accessToken"] = this.accessToken;
    data["encryptedAccessToken"] = this.encryptedAccessToken;
    data["expireInSeconds"] = this.expireInSeconds;
    data["userId"] = this.userId;
    return data;
  }

  clone(): AuthenticateResultModel {
    const json = this.toJSON();
    let result = new AuthenticateResultModel();
    result.init(json);
    return result;
  }
}

export interface IAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  userId: number;
}

export class Borrower implements IBorrower {
  id: number;
  firstName: string | undefined;
  middleInitial: string | undefined;
  lastName: string | undefined;
  suffix: string | undefined;
  email: string | undefined;
  dateOfBirth: string | undefined;
  socialSecurityNumber: string | undefined;
  maritalStatusId: number | undefined;
  numberOfDependents: number | undefined;
  cellPhone: string | undefined;
  homePhone: string | undefined;
  borrowerType: BorrowerType;
  borrowerTypeId: number;

  constructor(data?: IBorrower) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.firstName = _data["firstName"];
      this.middleInitial = _data["middleInitial"];
      this.lastName = _data["lastName"];
      this.suffix = _data["suffix"];
      this.email = _data["email"];
      this.dateOfBirth = _data["dateOfBirth"];
      this.socialSecurityNumber = _data["socialSecurityNumber"];
      this.maritalStatusId = _data["maritalStatusId"];
      this.numberOfDependents = _data["numberOfDependents"];
      this.cellPhone = _data["cellPhone"];
      this.homePhone = _data["homePhone"];
      this.borrowerType = _data["borrowerType"]
        ? BorrowerType.fromJS(_data["borrowerType"])
        : <any>undefined;
      this.borrowerTypeId = _data["borrowerTypeId"];
    }
  }

  static fromJS(data: any): Borrower {
    data = typeof data === "object" ? data : {};
    let result = new Borrower();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["firstName"] = this.firstName;
    data["middleInitial"] = this.middleInitial;
    data["lastName"] = this.lastName;
    data["suffix"] = this.suffix;
    data["email"] = this.email;
    data["dateOfBirth"] = this.dateOfBirth;
    data["socialSecurityNumber"] = this.socialSecurityNumber;
    data["maritalStatusId"] = this.maritalStatusId;
    data["numberOfDependents"] = this.numberOfDependents;
    data["cellPhone"] = this.cellPhone;
    data["homePhone"] = this.homePhone;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    data["borrowerTypeId"] = this.borrowerTypeId;
    return data;
  }

  clone(): Borrower {
    const json = this.toJSON();
    let result = new Borrower();
    result.init(json);
    return result;
  }
}

export interface IBorrower {
  id: number;
  firstName: string | undefined;
  middleInitial: string | undefined;
  lastName: string | undefined;
  suffix: string | undefined;
  email: string | undefined;
  dateOfBirth: string | undefined;
  socialSecurityNumber: string | undefined;
  maritalStatusId: number | undefined;
  numberOfDependents: number | undefined;
  cellPhone: string | undefined;
  homePhone: string | undefined;
  borrowerType: BorrowerType;
  borrowerTypeId: number;
}

export class BorrowerDto implements IBorrowerDto {
  id: number | undefined;
  firstName: string | undefined;
  middleInitial: string | undefined;
  lastName: string | undefined;
  suffix: string | undefined;
  email: string | undefined;
  dateOfBirth: string | undefined;
  socialSecurityNumber: string | undefined;
  maritalStatusId: number | undefined;
  numberOfDependents: number | undefined;
  cellPhone: string | undefined;
  homePhone: string | undefined;
  personalDetailId: number | undefined;
  borrowerTypeId: number;

  constructor(data?: IBorrowerDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.firstName = _data["firstName"];
      this.middleInitial = _data["middleInitial"];
      this.lastName = _data["lastName"];
      this.suffix = _data["suffix"];
      this.email = _data["email"];
      this.dateOfBirth = _data["dateOfBirth"];
      this.socialSecurityNumber = _data["socialSecurityNumber"];
      this.maritalStatusId = _data["maritalStatusId"];
      this.numberOfDependents = _data["numberOfDependents"];
      this.cellPhone = _data["cellPhone"];
      this.homePhone = _data["homePhone"];
      this.personalDetailId = _data["personalDetailId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
    }
  }

  static fromJS(data: any): BorrowerDto {
    data = typeof data === "object" ? data : {};
    let result = new BorrowerDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["firstName"] = this.firstName;
    data["middleInitial"] = this.middleInitial;
    data["lastName"] = this.lastName;
    data["suffix"] = this.suffix;
    data["email"] = this.email;
    data["dateOfBirth"] = this.dateOfBirth;
    data["socialSecurityNumber"] = this.socialSecurityNumber;
    data["maritalStatusId"] = this.maritalStatusId;
    data["numberOfDependents"] = this.numberOfDependents;
    data["cellPhone"] = this.cellPhone;
    data["homePhone"] = this.homePhone;
    data["personalDetailId"] = this.personalDetailId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    return data;
  }

  clone(): BorrowerDto {
    const json = this.toJSON();
    let result = new BorrowerDto();
    result.init(json);
    return result;
  }
}

export interface IBorrowerDto {
  id: number | undefined;
  firstName: string | undefined;
  middleInitial: string | undefined;
  lastName: string | undefined;
  suffix: string | undefined;
  email: string | undefined;
  dateOfBirth: string | undefined;
  socialSecurityNumber: string | undefined;
  maritalStatusId: number | undefined;
  numberOfDependents: number | undefined;
  cellPhone: string | undefined;
  homePhone: string | undefined;
  personalDetailId: number | undefined;
  borrowerTypeId: number;
}

export class BorrowerEmploymentInformation
  implements IBorrowerEmploymentInformation {
  id: number;
  employersName: string | undefined;
  employersAddress1: string | undefined;
  employersAddress2: string | undefined;
  isSelfEmployed: boolean | undefined;
  position: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  startDate: moment.Moment | undefined;
  endDate: moment.Moment | undefined;
  borrowerType: BorrowerType;
  borrowerTypeId: number;
  loanApplication: LoanApplication;
  loanApplicationId: number;

  constructor(data?: IBorrowerEmploymentInformation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.employersName = _data["employersName"];
      this.employersAddress1 = _data["employersAddress1"];
      this.employersAddress2 = _data["employersAddress2"];
      this.isSelfEmployed = _data["isSelfEmployed"];
      this.position = _data["position"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.zipCode = _data["zipCode"];
      this.startDate = _data["startDate"]
        ? moment(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? moment(_data["endDate"].toString())
        : <any>undefined;
      this.borrowerType = _data["borrowerType"]
        ? BorrowerType.fromJS(_data["borrowerType"])
        : <any>undefined;
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplication = _data["loanApplication"]
        ? LoanApplication.fromJS(_data["loanApplication"])
        : <any>undefined;
      this.loanApplicationId = _data["loanApplicationId"];
    }
  }

  static fromJS(data: any): BorrowerEmploymentInformation {
    data = typeof data === "object" ? data : {};
    let result = new BorrowerEmploymentInformation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["employersName"] = this.employersName;
    data["employersAddress1"] = this.employersAddress1;
    data["employersAddress2"] = this.employersAddress2;
    data["isSelfEmployed"] = this.isSelfEmployed;
    data["position"] = this.position;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["zipCode"] = this.zipCode;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplication"] = this.loanApplication
      ? this.loanApplication.toJSON()
      : <any>undefined;
    data["loanApplicationId"] = this.loanApplicationId;
    return data;
  }

  clone(): BorrowerEmploymentInformation {
    const json = this.toJSON();
    let result = new BorrowerEmploymentInformation();
    result.init(json);
    return result;
  }
}

export interface IBorrowerEmploymentInformation {
  id: number;
  employersName: string | undefined;
  employersAddress1: string | undefined;
  employersAddress2: string | undefined;
  isSelfEmployed: boolean | undefined;
  position: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  startDate: moment.Moment | undefined;
  endDate: moment.Moment | undefined;
  borrowerType: BorrowerType;
  borrowerTypeId: number;
  loanApplication: LoanApplication;
  loanApplicationId: number;
}

export class BorrowerEmploymentInformationDto
  implements IBorrowerEmploymentInformationDto {
  id: number | undefined;
  employerName: string | undefined;
  address1: string | undefined;
  address2: string | undefined;
  isSelfEmployed: boolean | undefined;
  position: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  startDate: moment.Moment | undefined;
  endDate: moment.Moment | undefined;
  borrowerTypeId: number;
  loanApplicationId: number | undefined;

  constructor(data?: IBorrowerEmploymentInformationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.employerName = _data["employerName"];
      this.address1 = _data["address1"];
      this.address2 = _data["address2"];
      this.isSelfEmployed = _data["isSelfEmployed"];
      this.position = _data["position"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.zipCode = _data["zipCode"];
      this.startDate = _data["startDate"]
        ? moment(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? moment(_data["endDate"].toString())
        : <any>undefined;
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplicationId = _data["loanApplicationId"];
    }
  }

  static fromJS(data: any): BorrowerEmploymentInformationDto {
    data = typeof data === "object" ? data : {};
    let result = new BorrowerEmploymentInformationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["employerName"] = this.employerName;
    data["address1"] = this.address1;
    data["address2"] = this.address2;
    data["isSelfEmployed"] = this.isSelfEmployed;
    data["position"] = this.position;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["zipCode"] = this.zipCode;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplicationId"] = this.loanApplicationId;
    return data;
  }

  clone(): BorrowerEmploymentInformationDto {
    const json = this.toJSON();
    let result = new BorrowerEmploymentInformationDto();
    result.init(json);
    return result;
  }
}

export interface IBorrowerEmploymentInformationDto {
  id: number | undefined;
  employerName: string | undefined;
  address1: string | undefined;
  address2: string | undefined;
  isSelfEmployed: boolean | undefined;
  position: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  startDate: moment.Moment | undefined;
  endDate: moment.Moment | undefined;
  borrowerTypeId: number;
  loanApplicationId: number | undefined;
}

export class BorrowerEmploymentInformationDtoPagedResultDto
  implements IBorrowerEmploymentInformationDtoPagedResultDto {
  items: BorrowerEmploymentInformationDto[] | undefined;
  totalCount: number;

  constructor(data?: IBorrowerEmploymentInformationDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(BorrowerEmploymentInformationDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): BorrowerEmploymentInformationDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new BorrowerEmploymentInformationDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): BorrowerEmploymentInformationDtoPagedResultDto {
    const json = this.toJSON();
    let result = new BorrowerEmploymentInformationDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IBorrowerEmploymentInformationDtoPagedResultDto {
  items: BorrowerEmploymentInformationDto[] | undefined;
  totalCount: number;
}

export class BorrowerMonthlyIncome implements IBorrowerMonthlyIncome {
  id: number;
  base: number | undefined;
  overtime: number | undefined;
  bonuses: number | undefined;
  commissions: number | undefined;
  dividends: number | undefined;
  borrowerType: BorrowerType;
  borrowerTypeId: number;
  loanApplication: LoanApplication;
  loanApplicationId: number;

  constructor(data?: IBorrowerMonthlyIncome) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.base = _data["base"];
      this.overtime = _data["overtime"];
      this.bonuses = _data["bonuses"];
      this.commissions = _data["commissions"];
      this.dividends = _data["dividends"];
      this.borrowerType = _data["borrowerType"]
        ? BorrowerType.fromJS(_data["borrowerType"])
        : <any>undefined;
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplication = _data["loanApplication"]
        ? LoanApplication.fromJS(_data["loanApplication"])
        : <any>undefined;
      this.loanApplicationId = _data["loanApplicationId"];
    }
  }

  static fromJS(data: any): BorrowerMonthlyIncome {
    data = typeof data === "object" ? data : {};
    let result = new BorrowerMonthlyIncome();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["base"] = this.base;
    data["overtime"] = this.overtime;
    data["bonuses"] = this.bonuses;
    data["commissions"] = this.commissions;
    data["dividends"] = this.dividends;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplication"] = this.loanApplication
      ? this.loanApplication.toJSON()
      : <any>undefined;
    data["loanApplicationId"] = this.loanApplicationId;
    return data;
  }

  clone(): BorrowerMonthlyIncome {
    const json = this.toJSON();
    let result = new BorrowerMonthlyIncome();
    result.init(json);
    return result;
  }
}

export interface IBorrowerMonthlyIncome {
  id: number;
  base: number | undefined;
  overtime: number | undefined;
  bonuses: number | undefined;
  commissions: number | undefined;
  dividends: number | undefined;
  borrowerType: BorrowerType;
  borrowerTypeId: number;
  loanApplication: LoanApplication;
  loanApplicationId: number;
}

export class BorrowerMonthlyIncomeDto implements IBorrowerMonthlyIncomeDto {
  id: number | undefined;
  base: number | undefined;
  overtime: number | undefined;
  bonuses: number | undefined;
  commissions: number | undefined;
  dividends: number | undefined;
  borrowerTypeId: number;
  loanApplicationId: number | undefined;

  constructor(data?: IBorrowerMonthlyIncomeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.base = _data["base"];
      this.overtime = _data["overtime"];
      this.bonuses = _data["bonuses"];
      this.commissions = _data["commissions"];
      this.dividends = _data["dividends"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplicationId = _data["loanApplicationId"];
    }
  }

  static fromJS(data: any): BorrowerMonthlyIncomeDto {
    data = typeof data === "object" ? data : {};
    let result = new BorrowerMonthlyIncomeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["base"] = this.base;
    data["overtime"] = this.overtime;
    data["bonuses"] = this.bonuses;
    data["commissions"] = this.commissions;
    data["dividends"] = this.dividends;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplicationId"] = this.loanApplicationId;
    return data;
  }

  clone(): BorrowerMonthlyIncomeDto {
    const json = this.toJSON();
    let result = new BorrowerMonthlyIncomeDto();
    result.init(json);
    return result;
  }
}

export interface IBorrowerMonthlyIncomeDto {
  id: number | undefined;
  base: number | undefined;
  overtime: number | undefined;
  bonuses: number | undefined;
  commissions: number | undefined;
  dividends: number | undefined;
  borrowerTypeId: number;
  loanApplicationId: number | undefined;
}

export class BorrowerMonthlyIncomeDtoPagedResultDto
  implements IBorrowerMonthlyIncomeDtoPagedResultDto {
  items: BorrowerMonthlyIncomeDto[] | undefined;
  totalCount: number;

  constructor(data?: IBorrowerMonthlyIncomeDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(BorrowerMonthlyIncomeDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): BorrowerMonthlyIncomeDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new BorrowerMonthlyIncomeDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): BorrowerMonthlyIncomeDtoPagedResultDto {
    const json = this.toJSON();
    let result = new BorrowerMonthlyIncomeDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IBorrowerMonthlyIncomeDtoPagedResultDto {
  items: BorrowerMonthlyIncomeDto[] | undefined;
  totalCount: number;
}

export class BorrowerType implements IBorrowerType {
  id: number;
  name: string | undefined;

  constructor(data?: IBorrowerType) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): BorrowerType {
    data = typeof data === "object" ? data : {};
    let result = new BorrowerType();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    return data;
  }

  clone(): BorrowerType {
    const json = this.toJSON();
    let result = new BorrowerType();
    result.init(json);
    return result;
  }
}

export interface IBorrowerType {
  id: number;
  name: string | undefined;
}

export class BuyingHomeDto implements IBuyingHomeDto {
  id: number | undefined;
  propertyType: string | undefined;
  propertyUse: string | undefined;
  firstTimeHomeBuying: boolean;
  planToPurchase: string | undefined;
  propertyLocated: string | undefined;
  purchasePrice: string | undefined;
  downPayment: number;
  currentEmployed: string | undefined;
  houseHoldIncome: string | undefined;
  proofOfincome: boolean;
  militarySevice: boolean;
  bankruptcyPastThreeYears: boolean;
  foreclosurePastTwoYears: boolean;
  lateMortgagePayments: string | undefined;
  rateCredit: string | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;
  refferedBy: string | undefined;

  constructor(data?: IBuyingHomeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.propertyType = _data["propertyType"];
      this.propertyUse = _data["propertyUse"];
      this.firstTimeHomeBuying = _data["firstTimeHomeBuying"];
      this.planToPurchase = _data["planToPurchase"];
      this.propertyLocated = _data["propertyLocated"];
      this.purchasePrice = _data["purchasePrice"];
      this.downPayment = _data["downPayment"];
      this.currentEmployed = _data["currentEmployed"];
      this.houseHoldIncome = _data["houseHoldIncome"];
      this.proofOfincome = _data["proofOfincome"];
      this.militarySevice = _data["militarySevice"];
      this.bankruptcyPastThreeYears = _data["bankruptcyPastThreeYears"];
      this.foreclosurePastTwoYears = _data["foreclosurePastTwoYears"];
      this.lateMortgagePayments = _data["lateMortgagePayments"];
      this.rateCredit = _data["rateCredit"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.emailAddress = _data["emailAddress"];
      this.phoneNumber = _data["phoneNumber"];
      this.refferedBy = _data["refferedBy"];
    }
  }

  static fromJS(data: any): BuyingHomeDto {
    data = typeof data === "object" ? data : {};
    let result = new BuyingHomeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["propertyType"] = this.propertyType;
    data["propertyUse"] = this.propertyUse;
    data["firstTimeHomeBuying"] = this.firstTimeHomeBuying;
    data["planToPurchase"] = this.planToPurchase;
    data["propertyLocated"] = this.propertyLocated;
    data["purchasePrice"] = this.purchasePrice;
    data["downPayment"] = this.downPayment;
    data["currentEmployed"] = this.currentEmployed;
    data["houseHoldIncome"] = this.houseHoldIncome;
    data["proofOfincome"] = this.proofOfincome;
    data["militarySevice"] = this.militarySevice;
    data["bankruptcyPastThreeYears"] = this.bankruptcyPastThreeYears;
    data["foreclosurePastTwoYears"] = this.foreclosurePastTwoYears;
    data["lateMortgagePayments"] = this.lateMortgagePayments;
    data["rateCredit"] = this.rateCredit;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["emailAddress"] = this.emailAddress;
    data["phoneNumber"] = this.phoneNumber;
    data["refferedBy"] = this.refferedBy;
    return data;
  }

  clone(): BuyingHomeDto {
    const json = this.toJSON();
    let result = new BuyingHomeDto();
    result.init(json);
    return result;
  }
}

export interface IBuyingHomeDto {
  id: number | undefined;
  propertyType: string | undefined;
  propertyUse: string | undefined;
  firstTimeHomeBuying: boolean;
  planToPurchase: string | undefined;
  propertyLocated: string | undefined;
  purchasePrice: string | undefined;
  downPayment: number;
  currentEmployed: string | undefined;
  houseHoldIncome: string | undefined;
  proofOfincome: boolean;
  militarySevice: boolean;
  bankruptcyPastThreeYears: boolean;
  foreclosurePastTwoYears: boolean;
  lateMortgagePayments: string | undefined;
  rateCredit: string | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;
  refferedBy: string | undefined;
}

export class BuyingHomeDtoPagedResultDto
  implements IBuyingHomeDtoPagedResultDto {
  items: BuyingHomeDto[] | undefined;
  totalCount: number;

  constructor(data?: IBuyingHomeDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(BuyingHomeDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): BuyingHomeDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new BuyingHomeDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): BuyingHomeDtoPagedResultDto {
    const json = this.toJSON();
    let result = new BuyingHomeDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IBuyingHomeDtoPagedResultDto {
  items: BuyingHomeDto[] | undefined;
  totalCount: number;
}

export class ChangePasswordDto implements IChangePasswordDto {
  currentPassword: string;
  newPassword: string;

  constructor(data?: IChangePasswordDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPassword = _data["currentPassword"];
      this.newPassword = _data["newPassword"];
    }
  }

  static fromJS(data: any): ChangePasswordDto {
    data = typeof data === "object" ? data : {};
    let result = new ChangePasswordDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currentPassword"] = this.currentPassword;
    data["newPassword"] = this.newPassword;
    return data;
  }

  clone(): ChangePasswordDto {
    const json = this.toJSON();
    let result = new ChangePasswordDto();
    result.init(json);
    return result;
  }
}

export interface IChangePasswordDto {
  currentPassword: string;
  newPassword: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
  theme: string;

  constructor(data?: IChangeUiThemeInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.theme = _data["theme"];
    }
  }

  static fromJS(data: any): ChangeUiThemeInput {
    data = typeof data === "object" ? data : {};
    let result = new ChangeUiThemeInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["theme"] = this.theme;
    return data;
  }

  clone(): ChangeUiThemeInput {
    const json = this.toJSON();
    let result = new ChangeUiThemeInput();
    result.init(json);
    return result;
  }
}

export interface IChangeUiThemeInput {
  theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
  languageName: string;

  constructor(data?: IChangeUserLanguageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.languageName = _data["languageName"];
    }
  }

  static fromJS(data: any): ChangeUserLanguageDto {
    data = typeof data === "object" ? data : {};
    let result = new ChangeUserLanguageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["languageName"] = this.languageName;
    return data;
  }

  clone(): ChangeUserLanguageDto {
    const json = this.toJSON();
    let result = new ChangeUserLanguageDto();
    result.init(json);
    return result;
  }
}

export interface IChangeUserLanguageDto {
  languageName: string;
}

export class ConsentDetail implements IConsentDetail {
  id: number;
  agreeEConsent: boolean | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  email: string | undefined;
  coborrowerAgreeEConsent: boolean | undefined;
  coborrowerFirstName: string | undefined;
  coborrowerLastName: string | undefined;
  coborrowerEmail: string | undefined;

  constructor(data?: IConsentDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.agreeEConsent = _data["agreeEConsent"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.email = _data["email"];
      this.coborrowerAgreeEConsent = _data["coborrowerAgreeEConsent"];
      this.coborrowerFirstName = _data["coborrowerFirstName"];
      this.coborrowerLastName = _data["coborrowerLastName"];
      this.coborrowerEmail = _data["coborrowerEmail"];
    }
  }

  static fromJS(data: any): ConsentDetail {
    data = typeof data === "object" ? data : {};
    let result = new ConsentDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["agreeEConsent"] = this.agreeEConsent;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["email"] = this.email;
    data["coborrowerAgreeEConsent"] = this.coborrowerAgreeEConsent;
    data["coborrowerFirstName"] = this.coborrowerFirstName;
    data["coborrowerLastName"] = this.coborrowerLastName;
    data["coborrowerEmail"] = this.coborrowerEmail;
    return data;
  }

  clone(): ConsentDetail {
    const json = this.toJSON();
    let result = new ConsentDetail();
    result.init(json);
    return result;
  }
}

export interface IConsentDetail {
  id: number;
  agreeEConsent: boolean | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  email: string | undefined;
  coborrowerAgreeEConsent: boolean | undefined;
  coborrowerFirstName: string | undefined;
  coborrowerLastName: string | undefined;
  coborrowerEmail: string | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;

  constructor(data?: ICreateRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.normalizedName = _data["normalizedName"];
      this.description = _data["description"];
      if (Array.isArray(_data["grantedPermissions"])) {
        this.grantedPermissions = [] as any;
        for (let item of _data["grantedPermissions"])
          this.grantedPermissions.push(item);
      }
    }
  }

  static fromJS(data: any): CreateRoleDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["normalizedName"] = this.normalizedName;
    data["description"] = this.description;
    if (Array.isArray(this.grantedPermissions)) {
      data["grantedPermissions"] = [];
      for (let item of this.grantedPermissions)
        data["grantedPermissions"].push(item);
    }
    return data;
  }

  clone(): CreateRoleDto {
    const json = this.toJSON();
    let result = new CreateRoleDto();
    result.init(json);
    return result;
  }
}

export interface ICreateRoleDto {
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
  tenancyName: string;
  name: string;
  adminEmailAddress: string;
  connectionString: string | undefined;
  isActive: boolean;

  constructor(data?: ICreateTenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data["tenancyName"];
      this.name = _data["name"];
      this.adminEmailAddress = _data["adminEmailAddress"];
      this.connectionString = _data["connectionString"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): CreateTenantDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateTenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    data["adminEmailAddress"] = this.adminEmailAddress;
    data["connectionString"] = this.connectionString;
    data["isActive"] = this.isActive;
    return data;
  }

  clone(): CreateTenantDto {
    const json = this.toJSON();
    let result = new CreateTenantDto();
    result.init(json);
    return result;
  }
}

export interface ICreateTenantDto {
  tenancyName: string;
  name: string;
  adminEmailAddress: string;
  connectionString: string | undefined;
  isActive: boolean;
}

export class CreateUserDto implements ICreateUserDto {
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  roleNames: string[] | undefined;
  password: string;

  constructor(data?: ICreateUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data["userName"];
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.emailAddress = _data["emailAddress"];
      this.isActive = _data["isActive"];
      if (Array.isArray(_data["roleNames"])) {
        this.roleNames = [] as any;
        for (let item of _data["roleNames"]) this.roleNames.push(item);
      }
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): CreateUserDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateUserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userName"] = this.userName;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["emailAddress"] = this.emailAddress;
    data["isActive"] = this.isActive;
    if (Array.isArray(this.roleNames)) {
      data["roleNames"] = [];
      for (let item of this.roleNames) data["roleNames"].push(item);
    }
    data["password"] = this.password;
    return data;
  }

  clone(): CreateUserDto {
    const json = this.toJSON();
    let result = new CreateUserDto();
    result.init(json);
    return result;
  }
}

export interface ICreateUserDto {
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  roleNames: string[] | undefined;
  password: string;
}

export class CreditAuthAgreement implements ICreditAuthAgreement {
  id: number;
  agreeCreditAuthAgreement: boolean | undefined;

  constructor(data?: ICreditAuthAgreement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.agreeCreditAuthAgreement = _data["agreeCreditAuthAgreement"];
    }
  }

  static fromJS(data: any): CreditAuthAgreement {
    data = typeof data === "object" ? data : {};
    let result = new CreditAuthAgreement();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["agreeCreditAuthAgreement"] = this.agreeCreditAuthAgreement;
    return data;
  }

  clone(): CreditAuthAgreement {
    const json = this.toJSON();
    let result = new CreditAuthAgreement();
    result.init(json);
    return result;
  }
}

export interface ICreditAuthAgreement {
  id: number;
  agreeCreditAuthAgreement: boolean | undefined;
}

export class CreditAuthAgreementDto implements ICreditAuthAgreementDto {
  id: number | undefined;
  agreeCreditAuthAgreement: boolean | undefined;

  constructor(data?: ICreditAuthAgreementDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.agreeCreditAuthAgreement = _data["agreeCreditAuthAgreement"];
    }
  }

  static fromJS(data: any): CreditAuthAgreementDto {
    data = typeof data === "object" ? data : {};
    let result = new CreditAuthAgreementDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["agreeCreditAuthAgreement"] = this.agreeCreditAuthAgreement;
    return data;
  }

  clone(): CreditAuthAgreementDto {
    const json = this.toJSON();
    let result = new CreditAuthAgreementDto();
    result.init(json);
    return result;
  }
}

export interface ICreditAuthAgreementDto {
  id: number | undefined;
  agreeCreditAuthAgreement: boolean | undefined;
}

export class CreditAuthAgreementDtoPagedResultDto
  implements ICreditAuthAgreementDtoPagedResultDto {
  items: CreditAuthAgreementDto[] | undefined;
  totalCount: number;

  constructor(data?: ICreditAuthAgreementDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(CreditAuthAgreementDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): CreditAuthAgreementDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new CreditAuthAgreementDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): CreditAuthAgreementDtoPagedResultDto {
    const json = this.toJSON();
    let result = new CreditAuthAgreementDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ICreditAuthAgreementDtoPagedResultDto {
  items: CreditAuthAgreementDto[] | undefined;
  totalCount: number;
}

export class Declaration implements IDeclaration {
  id: number;
  isOutstandingJudgmentsAgainstYou: boolean | undefined;
  isDeclaredBankrupt: boolean | undefined;
  isPropertyForeClosedUponOrGivenTitle: boolean | undefined;
  isPartyToLawsuit: boolean | undefined;
  isObligatedOnAnyLoanWhichResultedForeclosure: boolean | undefined;
  isPresentlyDelinquent: boolean | undefined;
  isObligatedToPayAlimonyChildSupport: boolean | undefined;
  isAnyPartOfTheDownPayment: boolean | undefined;
  isCoMakerOrEndorser: boolean | undefined;
  isUSCitizen: boolean | undefined;
  isPermanentResidentSlien: boolean | undefined;
  isIntendToOccupyThePropertyAsYourPrimary: boolean | undefined;
  isOwnershipInterestInPropertyInTheLastThreeYears: boolean | undefined;
  declarationsSection: string | undefined;
  loanApplicationId: number;
  borrowerTypeId: number;
  loanApplication: LoanApplication;
  borrowerType: BorrowerType;

  constructor(data?: IDeclaration) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isOutstandingJudgmentsAgainstYou =
        _data["isOutstandingJudgmentsAgainstYou"];
      this.isDeclaredBankrupt = _data["isDeclaredBankrupt"];
      this.isPropertyForeClosedUponOrGivenTitle =
        _data["isPropertyForeClosedUponOrGivenTitle"];
      this.isPartyToLawsuit = _data["isPartyToLawsuit"];
      this.isObligatedOnAnyLoanWhichResultedForeclosure =
        _data["isObligatedOnAnyLoanWhichResultedForeclosure"];
      this.isPresentlyDelinquent = _data["isPresentlyDelinquent"];
      this.isObligatedToPayAlimonyChildSupport =
        _data["isObligatedToPayAlimonyChildSupport"];
      this.isAnyPartOfTheDownPayment = _data["isAnyPartOfTheDownPayment"];
      this.isCoMakerOrEndorser = _data["isCoMakerOrEndorser"];
      this.isUSCitizen = _data["isUSCitizen"];
      this.isPermanentResidentSlien = _data["isPermanentResidentSlien"];
      this.isIntendToOccupyThePropertyAsYourPrimary =
        _data["isIntendToOccupyThePropertyAsYourPrimary"];
      this.isOwnershipInterestInPropertyInTheLastThreeYears =
        _data["isOwnershipInterestInPropertyInTheLastThreeYears"];
      this.declarationsSection = _data["declarationsSection"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplication = _data["loanApplication"]
        ? LoanApplication.fromJS(_data["loanApplication"])
        : <any>undefined;
      this.borrowerType = _data["borrowerType"]
        ? BorrowerType.fromJS(_data["borrowerType"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Declaration {
    data = typeof data === "object" ? data : {};
    let result = new Declaration();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data[
      "isOutstandingJudgmentsAgainstYou"
    ] = this.isOutstandingJudgmentsAgainstYou;
    data["isDeclaredBankrupt"] = this.isDeclaredBankrupt;
    data[
      "isPropertyForeClosedUponOrGivenTitle"
    ] = this.isPropertyForeClosedUponOrGivenTitle;
    data["isPartyToLawsuit"] = this.isPartyToLawsuit;
    data[
      "isObligatedOnAnyLoanWhichResultedForeclosure"
    ] = this.isObligatedOnAnyLoanWhichResultedForeclosure;
    data["isPresentlyDelinquent"] = this.isPresentlyDelinquent;
    data[
      "isObligatedToPayAlimonyChildSupport"
    ] = this.isObligatedToPayAlimonyChildSupport;
    data["isAnyPartOfTheDownPayment"] = this.isAnyPartOfTheDownPayment;
    data["isCoMakerOrEndorser"] = this.isCoMakerOrEndorser;
    data["isUSCitizen"] = this.isUSCitizen;
    data["isPermanentResidentSlien"] = this.isPermanentResidentSlien;
    data[
      "isIntendToOccupyThePropertyAsYourPrimary"
    ] = this.isIntendToOccupyThePropertyAsYourPrimary;
    data[
      "isOwnershipInterestInPropertyInTheLastThreeYears"
    ] = this.isOwnershipInterestInPropertyInTheLastThreeYears;
    data["declarationsSection"] = this.declarationsSection;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplication"] = this.loanApplication
      ? this.loanApplication.toJSON()
      : <any>undefined;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): Declaration {
    const json = this.toJSON();
    let result = new Declaration();
    result.init(json);
    return result;
  }
}

export interface IDeclaration {
  id: number;
  isOutstandingJudgmentsAgainstYou: boolean | undefined;
  isDeclaredBankrupt: boolean | undefined;
  isPropertyForeClosedUponOrGivenTitle: boolean | undefined;
  isPartyToLawsuit: boolean | undefined;
  isObligatedOnAnyLoanWhichResultedForeclosure: boolean | undefined;
  isPresentlyDelinquent: boolean | undefined;
  isObligatedToPayAlimonyChildSupport: boolean | undefined;
  isAnyPartOfTheDownPayment: boolean | undefined;
  isCoMakerOrEndorser: boolean | undefined;
  isUSCitizen: boolean | undefined;
  isPermanentResidentSlien: boolean | undefined;
  isIntendToOccupyThePropertyAsYourPrimary: boolean | undefined;
  isOwnershipInterestInPropertyInTheLastThreeYears: boolean | undefined;
  declarationsSection: string | undefined;
  loanApplicationId: number;
  borrowerTypeId: number;
  loanApplication: LoanApplication;
  borrowerType: BorrowerType;
}

export class DeclarationBorrowereDemographicsInformation
  implements IDeclarationBorrowereDemographicsInformation {
  id: number;
  isHispanicOrLatino: boolean | undefined;
  isMexican: boolean | undefined;
  isPuertoRican: boolean | undefined;
  isCuban: boolean | undefined;
  isOtherHispanicOrLatino: boolean | undefined;
  origin: string | undefined;
  isNotHispanicOrLatino: boolean | undefined;
  canNotProvideEthnic: boolean | undefined;
  isAmericanIndianOrAlaskaNative: boolean | undefined;
  nameOfEnrolledOrPrincipalTribe: string | undefined;
  isAsian: boolean | undefined;
  isAsianIndian: boolean | undefined;
  isChinese: boolean | undefined;
  isFilipino: boolean | undefined;
  isJapanese: boolean | undefined;
  isKorean: boolean | undefined;
  isVietnamese: boolean | undefined;
  isOtherAsian: boolean | undefined;
  isBlackOrAfricanAmerican: boolean | undefined;
  isNativeHawaiianOrOtherPacificIslander: boolean | undefined;
  isNativeHawaiian: boolean | undefined;
  isGuamanianOrChamorro: boolean | undefined;
  isSamoan: boolean | undefined;
  isOtherPacificIslander: boolean | undefined;
  enterRace: string | undefined;
  isWhite: boolean | undefined;
  canNotProvideRace: boolean | undefined;
  isMale: boolean | undefined;
  isFemale: boolean | undefined;
  canNotProvideSex: boolean | undefined;
  borrowerTypeId: number;
  loanApplicationId: number;
  borrowerType: BorrowerType;
  loanApplication: LoanApplication;

  constructor(data?: IDeclarationBorrowereDemographicsInformation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isHispanicOrLatino = _data["isHispanicOrLatino"];
      this.isMexican = _data["isMexican"];
      this.isPuertoRican = _data["isPuertoRican"];
      this.isCuban = _data["isCuban"];
      this.isOtherHispanicOrLatino = _data["isOtherHispanicOrLatino"];
      this.origin = _data["origin"];
      this.isNotHispanicOrLatino = _data["isNotHispanicOrLatino"];
      this.canNotProvideEthnic = _data["canNotProvideEthnic"];
      this.isAmericanIndianOrAlaskaNative =
        _data["isAmericanIndianOrAlaskaNative"];
      this.nameOfEnrolledOrPrincipalTribe =
        _data["nameOfEnrolledOrPrincipalTribe"];
      this.isAsian = _data["isAsian"];
      this.isAsianIndian = _data["isAsianIndian"];
      this.isChinese = _data["isChinese"];
      this.isFilipino = _data["isFilipino"];
      this.isJapanese = _data["isJapanese"];
      this.isKorean = _data["isKorean"];
      this.isVietnamese = _data["isVietnamese"];
      this.isOtherAsian = _data["isOtherAsian"];
      this.isBlackOrAfricanAmerican = _data["isBlackOrAfricanAmerican"];
      this.isNativeHawaiianOrOtherPacificIslander =
        _data["isNativeHawaiianOrOtherPacificIslander"];
      this.isNativeHawaiian = _data["isNativeHawaiian"];
      this.isGuamanianOrChamorro = _data["isGuamanianOrChamorro"];
      this.isSamoan = _data["isSamoan"];
      this.isOtherPacificIslander = _data["isOtherPacificIslander"];
      this.enterRace = _data["enterRace"];
      this.isWhite = _data["isWhite"];
      this.canNotProvideRace = _data["canNotProvideRace"];
      this.isMale = _data["isMale"];
      this.isFemale = _data["isFemale"];
      this.canNotProvideSex = _data["canNotProvideSex"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerType = _data["borrowerType"]
        ? BorrowerType.fromJS(_data["borrowerType"])
        : <any>undefined;
      this.loanApplication = _data["loanApplication"]
        ? LoanApplication.fromJS(_data["loanApplication"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): DeclarationBorrowereDemographicsInformation {
    data = typeof data === "object" ? data : {};
    let result = new DeclarationBorrowereDemographicsInformation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["isHispanicOrLatino"] = this.isHispanicOrLatino;
    data["isMexican"] = this.isMexican;
    data["isPuertoRican"] = this.isPuertoRican;
    data["isCuban"] = this.isCuban;
    data["isOtherHispanicOrLatino"] = this.isOtherHispanicOrLatino;
    data["origin"] = this.origin;
    data["isNotHispanicOrLatino"] = this.isNotHispanicOrLatino;
    data["canNotProvideEthnic"] = this.canNotProvideEthnic;
    data[
      "isAmericanIndianOrAlaskaNative"
    ] = this.isAmericanIndianOrAlaskaNative;
    data[
      "nameOfEnrolledOrPrincipalTribe"
    ] = this.nameOfEnrolledOrPrincipalTribe;
    data["isAsian"] = this.isAsian;
    data["isAsianIndian"] = this.isAsianIndian;
    data["isChinese"] = this.isChinese;
    data["isFilipino"] = this.isFilipino;
    data["isJapanese"] = this.isJapanese;
    data["isKorean"] = this.isKorean;
    data["isVietnamese"] = this.isVietnamese;
    data["isOtherAsian"] = this.isOtherAsian;
    data["isBlackOrAfricanAmerican"] = this.isBlackOrAfricanAmerican;
    data[
      "isNativeHawaiianOrOtherPacificIslander"
    ] = this.isNativeHawaiianOrOtherPacificIslander;
    data["isNativeHawaiian"] = this.isNativeHawaiian;
    data["isGuamanianOrChamorro"] = this.isGuamanianOrChamorro;
    data["isSamoan"] = this.isSamoan;
    data["isOtherPacificIslander"] = this.isOtherPacificIslander;
    data["enterRace"] = this.enterRace;
    data["isWhite"] = this.isWhite;
    data["canNotProvideRace"] = this.canNotProvideRace;
    data["isMale"] = this.isMale;
    data["isFemale"] = this.isFemale;
    data["canNotProvideSex"] = this.canNotProvideSex;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    data["loanApplication"] = this.loanApplication
      ? this.loanApplication.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): DeclarationBorrowereDemographicsInformation {
    const json = this.toJSON();
    let result = new DeclarationBorrowereDemographicsInformation();
    result.init(json);
    return result;
  }
}

export interface IDeclarationBorrowereDemographicsInformation {
  id: number;
  isHispanicOrLatino: boolean | undefined;
  isMexican: boolean | undefined;
  isPuertoRican: boolean | undefined;
  isCuban: boolean | undefined;
  isOtherHispanicOrLatino: boolean | undefined;
  origin: string | undefined;
  isNotHispanicOrLatino: boolean | undefined;
  canNotProvideEthnic: boolean | undefined;
  isAmericanIndianOrAlaskaNative: boolean | undefined;
  nameOfEnrolledOrPrincipalTribe: string | undefined;
  isAsian: boolean | undefined;
  isAsianIndian: boolean | undefined;
  isChinese: boolean | undefined;
  isFilipino: boolean | undefined;
  isJapanese: boolean | undefined;
  isKorean: boolean | undefined;
  isVietnamese: boolean | undefined;
  isOtherAsian: boolean | undefined;
  isBlackOrAfricanAmerican: boolean | undefined;
  isNativeHawaiianOrOtherPacificIslander: boolean | undefined;
  isNativeHawaiian: boolean | undefined;
  isGuamanianOrChamorro: boolean | undefined;
  isSamoan: boolean | undefined;
  isOtherPacificIslander: boolean | undefined;
  enterRace: string | undefined;
  isWhite: boolean | undefined;
  canNotProvideRace: boolean | undefined;
  isMale: boolean | undefined;
  isFemale: boolean | undefined;
  canNotProvideSex: boolean | undefined;
  borrowerTypeId: number;
  loanApplicationId: number;
  borrowerType: BorrowerType;
  loanApplication: LoanApplication;
}

export class DeclarationDetailDto implements IDeclarationDetailDto {
  id: number | undefined;
  isOutstandingJudgmentsAgainstYou: boolean | undefined;
  isDeclaredBankrupt: boolean | undefined;
  isPropertyForeClosedUponOrGivenTitle: boolean | undefined;
  isPartyToLawsuit: boolean | undefined;
  isObligatedOnAnyLoanWhichResultedForeclosure: boolean | undefined;
  isPresentlyDelinquent: boolean | undefined;
  isObligatedToPayAlimonyChildSupport: boolean | undefined;
  isAnyPartOfTheDownPayment: boolean | undefined;
  isCoMakerOrEndorser: boolean | undefined;
  isUSCitizen: boolean | undefined;
  isPermanentResidentSlien: boolean | undefined;
  isIntendToOccupyThePropertyAsYourPrimary: boolean | undefined;
  isOwnershipInterestInPropertyInTheLastThreeYears: boolean | undefined;
  declarationsSection: string | undefined;

  constructor(data?: IDeclarationDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isOutstandingJudgmentsAgainstYou =
        _data["isOutstandingJudgmentsAgainstYou"];
      this.isDeclaredBankrupt = _data["isDeclaredBankrupt"];
      this.isPropertyForeClosedUponOrGivenTitle =
        _data["isPropertyForeClosedUponOrGivenTitle"];
      this.isPartyToLawsuit = _data["isPartyToLawsuit"];
      this.isObligatedOnAnyLoanWhichResultedForeclosure =
        _data["isObligatedOnAnyLoanWhichResultedForeclosure"];
      this.isPresentlyDelinquent = _data["isPresentlyDelinquent"];
      this.isObligatedToPayAlimonyChildSupport =
        _data["isObligatedToPayAlimonyChildSupport"];
      this.isAnyPartOfTheDownPayment = _data["isAnyPartOfTheDownPayment"];
      this.isCoMakerOrEndorser = _data["isCoMakerOrEndorser"];
      this.isUSCitizen = _data["isUSCitizen"];
      this.isPermanentResidentSlien = _data["isPermanentResidentSlien"];
      this.isIntendToOccupyThePropertyAsYourPrimary =
        _data["isIntendToOccupyThePropertyAsYourPrimary"];
      this.isOwnershipInterestInPropertyInTheLastThreeYears =
        _data["isOwnershipInterestInPropertyInTheLastThreeYears"];
      this.declarationsSection = _data["declarationsSection"];
    }
  }

  static fromJS(data: any): DeclarationDetailDto {
    data = typeof data === "object" ? data : {};
    let result = new DeclarationDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data[
      "isOutstandingJudgmentsAgainstYou"
    ] = this.isOutstandingJudgmentsAgainstYou;
    data["isDeclaredBankrupt"] = this.isDeclaredBankrupt;
    data[
      "isPropertyForeClosedUponOrGivenTitle"
    ] = this.isPropertyForeClosedUponOrGivenTitle;
    data["isPartyToLawsuit"] = this.isPartyToLawsuit;
    data[
      "isObligatedOnAnyLoanWhichResultedForeclosure"
    ] = this.isObligatedOnAnyLoanWhichResultedForeclosure;
    data["isPresentlyDelinquent"] = this.isPresentlyDelinquent;
    data[
      "isObligatedToPayAlimonyChildSupport"
    ] = this.isObligatedToPayAlimonyChildSupport;
    data["isAnyPartOfTheDownPayment"] = this.isAnyPartOfTheDownPayment;
    data["isCoMakerOrEndorser"] = this.isCoMakerOrEndorser;
    data["isUSCitizen"] = this.isUSCitizen;
    data["isPermanentResidentSlien"] = this.isPermanentResidentSlien;
    data[
      "isIntendToOccupyThePropertyAsYourPrimary"
    ] = this.isIntendToOccupyThePropertyAsYourPrimary;
    data[
      "isOwnershipInterestInPropertyInTheLastThreeYears"
    ] = this.isOwnershipInterestInPropertyInTheLastThreeYears;
    data["declarationsSection"] = this.declarationsSection;
    return data;
  }

  clone(): DeclarationDetailDto {
    const json = this.toJSON();
    let result = new DeclarationDetailDto();
    result.init(json);
    return result;
  }
}

export interface IDeclarationDetailDto {
  id: number | undefined;
  isOutstandingJudgmentsAgainstYou: boolean | undefined;
  isDeclaredBankrupt: boolean | undefined;
  isPropertyForeClosedUponOrGivenTitle: boolean | undefined;
  isPartyToLawsuit: boolean | undefined;
  isObligatedOnAnyLoanWhichResultedForeclosure: boolean | undefined;
  isPresentlyDelinquent: boolean | undefined;
  isObligatedToPayAlimonyChildSupport: boolean | undefined;
  isAnyPartOfTheDownPayment: boolean | undefined;
  isCoMakerOrEndorser: boolean | undefined;
  isUSCitizen: boolean | undefined;
  isPermanentResidentSlien: boolean | undefined;
  isIntendToOccupyThePropertyAsYourPrimary: boolean | undefined;
  isOwnershipInterestInPropertyInTheLastThreeYears: boolean | undefined;
  declarationsSection: string | undefined;
}

export class DeclarationDto implements IDeclarationDto {
  id: number | undefined;
  loanApplicationId: number;
  borrowerDeclaration: DeclarationDetailDto;
  borrowerDemographic: DemographicDto;
  coBorrowerDeclaration: DeclarationDetailDto;
  coBorrowerDemographic: DemographicDto;

  constructor(data?: IDeclarationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerDeclaration = _data["borrowerDeclaration"]
        ? DeclarationDetailDto.fromJS(_data["borrowerDeclaration"])
        : <any>undefined;
      this.borrowerDemographic = _data["borrowerDemographic"]
        ? DemographicDto.fromJS(_data["borrowerDemographic"])
        : <any>undefined;
      this.coBorrowerDeclaration = _data["coBorrowerDeclaration"]
        ? DeclarationDetailDto.fromJS(_data["coBorrowerDeclaration"])
        : <any>undefined;
      this.coBorrowerDemographic = _data["coBorrowerDemographic"]
        ? DemographicDto.fromJS(_data["coBorrowerDemographic"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): DeclarationDto {
    data = typeof data === "object" ? data : {};
    let result = new DeclarationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerDeclaration"] = this.borrowerDeclaration
      ? this.borrowerDeclaration.toJSON()
      : <any>undefined;
    data["borrowerDemographic"] = this.borrowerDemographic
      ? this.borrowerDemographic.toJSON()
      : <any>undefined;
    data["coBorrowerDeclaration"] = this.coBorrowerDeclaration
      ? this.coBorrowerDeclaration.toJSON()
      : <any>undefined;
    data["coBorrowerDemographic"] = this.coBorrowerDemographic
      ? this.coBorrowerDemographic.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): DeclarationDto {
    const json = this.toJSON();
    let result = new DeclarationDto();
    result.init(json);
    return result;
  }
}

export interface IDeclarationDto {
  id: number | undefined;
  loanApplicationId: number;
  borrowerDeclaration: DeclarationDetailDto;
  borrowerDemographic: DemographicDto;
  coBorrowerDeclaration: DeclarationDetailDto;
  coBorrowerDemographic: DemographicDto;
}

export class DeclarationDtoPagedResultDto
  implements IDeclarationDtoPagedResultDto {
  items: DeclarationDto[] | undefined;
  totalCount: number;

  constructor(data?: IDeclarationDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(DeclarationDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): DeclarationDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new DeclarationDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): DeclarationDtoPagedResultDto {
    const json = this.toJSON();
    let result = new DeclarationDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IDeclarationDtoPagedResultDto {
  items: DeclarationDto[] | undefined;
  totalCount: number;
}

export class DemographicDto implements IDemographicDto {
  id: number | undefined;
  ethnicity: DemographicTypeDto[] | undefined;
  race: DemographicTypeDto[] | undefined;
  sex: DemographicTypeDto[] | undefined;

  constructor(data?: IDemographicDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      if (Array.isArray(_data["ethnicity"])) {
        this.ethnicity = [] as any;
        for (let item of _data["ethnicity"])
          this.ethnicity.push(DemographicTypeDto.fromJS(item));
      }
      if (Array.isArray(_data["race"])) {
        this.race = [] as any;
        for (let item of _data["race"])
          this.race.push(DemographicTypeDto.fromJS(item));
      }
      if (Array.isArray(_data["sex"])) {
        this.sex = [] as any;
        for (let item of _data["sex"])
          this.sex.push(DemographicTypeDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DemographicDto {
    data = typeof data === "object" ? data : {};
    let result = new DemographicDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    if (Array.isArray(this.ethnicity)) {
      data["ethnicity"] = [];
      for (let item of this.ethnicity) data["ethnicity"].push(item.toJSON());
    }
    if (Array.isArray(this.race)) {
      data["race"] = [];
      for (let item of this.race) data["race"].push(item.toJSON());
    }
    if (Array.isArray(this.sex)) {
      data["sex"] = [];
      for (let item of this.sex) data["sex"].push(item.toJSON());
    }
    return data;
  }

  clone(): DemographicDto {
    const json = this.toJSON();
    let result = new DemographicDto();
    result.init(json);
    return result;
  }
}

export interface IDemographicDto {
  id: number | undefined;
  ethnicity: DemographicTypeDto[] | undefined;
  race: DemographicTypeDto[] | undefined;
  sex: DemographicTypeDto[] | undefined;
}

export class DemographicTypeDto implements IDemographicTypeDto {
  id: number;
  otherValue: string | undefined;

  constructor(data?: IDemographicTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.otherValue = _data["otherValue"];
    }
  }

  static fromJS(data: any): DemographicTypeDto {
    data = typeof data === "object" ? data : {};
    let result = new DemographicTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["otherValue"] = this.otherValue;
    return data;
  }

  clone(): DemographicTypeDto {
    const json = this.toJSON();
    let result = new DemographicTypeDto();
    result.init(json);
    return result;
  }
}

export interface IDemographicTypeDto {
  id: number;
  otherValue: string | undefined;
}

export class EConsentDto implements IEConsentDto {
  id: number | undefined;
  agreeEConsent: boolean | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  email: string | undefined;
  coborrowerAgreeEConsent: boolean | undefined;
  coborrowerFirstName: string | undefined;
  coborrowerLastName: string | undefined;
  coborrowerEmail: string | undefined;

  constructor(data?: IEConsentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.agreeEConsent = _data["agreeEConsent"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.email = _data["email"];
      this.coborrowerAgreeEConsent = _data["coborrowerAgreeEConsent"];
      this.coborrowerFirstName = _data["coborrowerFirstName"];
      this.coborrowerLastName = _data["coborrowerLastName"];
      this.coborrowerEmail = _data["coborrowerEmail"];
    }
  }

  static fromJS(data: any): EConsentDto {
    data = typeof data === "object" ? data : {};
    let result = new EConsentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["agreeEConsent"] = this.agreeEConsent;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["email"] = this.email;
    data["coborrowerAgreeEConsent"] = this.coborrowerAgreeEConsent;
    data["coborrowerFirstName"] = this.coborrowerFirstName;
    data["coborrowerLastName"] = this.coborrowerLastName;
    data["coborrowerEmail"] = this.coborrowerEmail;
    return data;
  }

  clone(): EConsentDto {
    const json = this.toJSON();
    let result = new EConsentDto();
    result.init(json);
    return result;
  }
}

export interface IEConsentDto {
  id: number | undefined;
  agreeEConsent: boolean | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  email: string | undefined;
  coborrowerAgreeEConsent: boolean | undefined;
  coborrowerFirstName: string | undefined;
  coborrowerLastName: string | undefined;
  coborrowerEmail: string | undefined;
}

export class EConsentDtoPagedResultDto implements IEConsentDtoPagedResultDto {
  items: EConsentDto[] | undefined;
  totalCount: number;

  constructor(data?: IEConsentDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(EConsentDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): EConsentDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new EConsentDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): EConsentDtoPagedResultDto {
    const json = this.toJSON();
    let result = new EConsentDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IEConsentDtoPagedResultDto {
  items: EConsentDto[] | undefined;
  totalCount: number;
}

export class EmploymentIncomeDto implements IEmploymentIncomeDto {
  id: number | undefined;
  loanApplicationId: number | undefined;
  additionalIncomes: AdditionalIncomeDto[] | undefined;
  borrowerEmploymentInfo: BorrowerEmploymentInformationDto[] | undefined;
  coBorrowerEmploymentInfo: BorrowerEmploymentInformationDto[] | undefined;
  borrowerMonthlyIncome: BorrowerMonthlyIncomeDto;
  coBorrowerMonthlyIncome: BorrowerMonthlyIncomeDto;

  constructor(data?: IEmploymentIncomeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.loanApplicationId = _data["loanApplicationId"];
      if (Array.isArray(_data["additionalIncomes"])) {
        this.additionalIncomes = [] as any;
        for (let item of _data["additionalIncomes"])
          this.additionalIncomes.push(AdditionalIncomeDto.fromJS(item));
      }
      if (Array.isArray(_data["borrowerEmploymentInfo"])) {
        this.borrowerEmploymentInfo = [] as any;
        for (let item of _data["borrowerEmploymentInfo"])
          this.borrowerEmploymentInfo.push(
            BorrowerEmploymentInformationDto.fromJS(item)
          );
      }
      if (Array.isArray(_data["coBorrowerEmploymentInfo"])) {
        this.coBorrowerEmploymentInfo = [] as any;
        for (let item of _data["coBorrowerEmploymentInfo"])
          this.coBorrowerEmploymentInfo.push(
            BorrowerEmploymentInformationDto.fromJS(item)
          );
      }
      this.borrowerMonthlyIncome = _data["borrowerMonthlyIncome"]
        ? BorrowerMonthlyIncomeDto.fromJS(_data["borrowerMonthlyIncome"])
        : <any>undefined;
      this.coBorrowerMonthlyIncome = _data["coBorrowerMonthlyIncome"]
        ? BorrowerMonthlyIncomeDto.fromJS(_data["coBorrowerMonthlyIncome"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): EmploymentIncomeDto {
    data = typeof data === "object" ? data : {};
    let result = new EmploymentIncomeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["loanApplicationId"] = this.loanApplicationId;
    if (Array.isArray(this.additionalIncomes)) {
      data["additionalIncomes"] = [];
      for (let item of this.additionalIncomes)
        data["additionalIncomes"].push(item.toJSON());
    }
    if (Array.isArray(this.borrowerEmploymentInfo)) {
      data["borrowerEmploymentInfo"] = [];
      for (let item of this.borrowerEmploymentInfo)
        data["borrowerEmploymentInfo"].push(item.toJSON());
    }
    if (Array.isArray(this.coBorrowerEmploymentInfo)) {
      data["coBorrowerEmploymentInfo"] = [];
      for (let item of this.coBorrowerEmploymentInfo)
        data["coBorrowerEmploymentInfo"].push(item.toJSON());
    }
    data["borrowerMonthlyIncome"] = this.borrowerMonthlyIncome
      ? this.borrowerMonthlyIncome.toJSON()
      : <any>undefined;
    data["coBorrowerMonthlyIncome"] = this.coBorrowerMonthlyIncome
      ? this.coBorrowerMonthlyIncome.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): EmploymentIncomeDto {
    const json = this.toJSON();
    let result = new EmploymentIncomeDto();
    result.init(json);
    return result;
  }
}

export interface IEmploymentIncomeDto {
  id: number | undefined;
  loanApplicationId: number | undefined;
  additionalIncomes: AdditionalIncomeDto[] | undefined;
  borrowerEmploymentInfo: BorrowerEmploymentInformationDto[] | undefined;
  coBorrowerEmploymentInfo: BorrowerEmploymentInformationDto[] | undefined;
  borrowerMonthlyIncome: BorrowerMonthlyIncomeDto;
  coBorrowerMonthlyIncome: BorrowerMonthlyIncomeDto;
}

export class EmploymentIncomeDtoPagedResultDto
  implements IEmploymentIncomeDtoPagedResultDto {
  items: EmploymentIncomeDto[] | undefined;
  totalCount: number;

  constructor(data?: IEmploymentIncomeDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(EmploymentIncomeDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): EmploymentIncomeDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new EmploymentIncomeDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): EmploymentIncomeDtoPagedResultDto {
    const json = this.toJSON();
    let result = new EmploymentIncomeDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IEmploymentIncomeDtoPagedResultDto {
  items: EmploymentIncomeDto[] | undefined;
  totalCount: number;
}

export class Expense implements IExpense {
  id: number;
  isLiveWithFamilySelectRent: boolean | undefined;
  rent: number | undefined;
  otherHousingExpenses: number | undefined;
  firstMortgage: number | undefined;
  secondMortgage: number | undefined;
  hazardInsurance: number | undefined;
  realEstateTaxes: number | undefined;
  mortgageInsurance: number | undefined;
  homeOwnersAssociation: number | undefined;

  constructor(data?: IExpense) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isLiveWithFamilySelectRent = _data["isLiveWithFamilySelectRent"];
      this.rent = _data["rent"];
      this.otherHousingExpenses = _data["otherHousingExpenses"];
      this.firstMortgage = _data["firstMortgage"];
      this.secondMortgage = _data["secondMortgage"];
      this.hazardInsurance = _data["hazardInsurance"];
      this.realEstateTaxes = _data["realEstateTaxes"];
      this.mortgageInsurance = _data["mortgageInsurance"];
      this.homeOwnersAssociation = _data["homeOwnersAssociation"];
    }
  }

  static fromJS(data: any): Expense {
    data = typeof data === "object" ? data : {};
    let result = new Expense();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["isLiveWithFamilySelectRent"] = this.isLiveWithFamilySelectRent;
    data["rent"] = this.rent;
    data["otherHousingExpenses"] = this.otherHousingExpenses;
    data["firstMortgage"] = this.firstMortgage;
    data["secondMortgage"] = this.secondMortgage;
    data["hazardInsurance"] = this.hazardInsurance;
    data["realEstateTaxes"] = this.realEstateTaxes;
    data["mortgageInsurance"] = this.mortgageInsurance;
    data["homeOwnersAssociation"] = this.homeOwnersAssociation;
    return data;
  }

  clone(): Expense {
    const json = this.toJSON();
    let result = new Expense();
    result.init(json);
    return result;
  }
}

export interface IExpense {
  id: number;
  isLiveWithFamilySelectRent: boolean | undefined;
  rent: number | undefined;
  otherHousingExpenses: number | undefined;
  firstMortgage: number | undefined;
  secondMortgage: number | undefined;
  hazardInsurance: number | undefined;
  realEstateTaxes: number | undefined;
  mortgageInsurance: number | undefined;
  homeOwnersAssociation: number | undefined;
}

export class ExpensesDto implements IExpensesDto {
  id: number | undefined;
  isLiveWithFamilySelectRent: boolean | undefined;
  rent: number | undefined;
  otherHousingExpenses: number | undefined;
  firstMortgage: number | undefined;
  secondMortgage: number | undefined;
  hazardInsurance: number | undefined;
  realEstateTaxes: number | undefined;
  mortgageInsurance: number | undefined;
  homeOwnersAssociation: number | undefined;

  constructor(data?: IExpensesDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isLiveWithFamilySelectRent = _data["isLiveWithFamilySelectRent"];
      this.rent = _data["rent"];
      this.otherHousingExpenses = _data["otherHousingExpenses"];
      this.firstMortgage = _data["firstMortgage"];
      this.secondMortgage = _data["secondMortgage"];
      this.hazardInsurance = _data["hazardInsurance"];
      this.realEstateTaxes = _data["realEstateTaxes"];
      this.mortgageInsurance = _data["mortgageInsurance"];
      this.homeOwnersAssociation = _data["homeOwnersAssociation"];
    }
  }

  static fromJS(data: any): ExpensesDto {
    data = typeof data === "object" ? data : {};
    let result = new ExpensesDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["isLiveWithFamilySelectRent"] = this.isLiveWithFamilySelectRent;
    data["rent"] = this.rent;
    data["otherHousingExpenses"] = this.otherHousingExpenses;
    data["firstMortgage"] = this.firstMortgage;
    data["secondMortgage"] = this.secondMortgage;
    data["hazardInsurance"] = this.hazardInsurance;
    data["realEstateTaxes"] = this.realEstateTaxes;
    data["mortgageInsurance"] = this.mortgageInsurance;
    data["homeOwnersAssociation"] = this.homeOwnersAssociation;
    return data;
  }

  clone(): ExpensesDto {
    const json = this.toJSON();
    let result = new ExpensesDto();
    result.init(json);
    return result;
  }
}

export interface IExpensesDto {
  id: number | undefined;
  isLiveWithFamilySelectRent: boolean | undefined;
  rent: number | undefined;
  otherHousingExpenses: number | undefined;
  firstMortgage: number | undefined;
  secondMortgage: number | undefined;
  hazardInsurance: number | undefined;
  realEstateTaxes: number | undefined;
  mortgageInsurance: number | undefined;
  homeOwnersAssociation: number | undefined;
}

export class ExpensesDtoPagedResultDto implements IExpensesDtoPagedResultDto {
  items: ExpensesDto[] | undefined;
  totalCount: number;

  constructor(data?: IExpensesDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(ExpensesDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): ExpensesDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new ExpensesDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): ExpensesDtoPagedResultDto {
    const json = this.toJSON();
    let result = new ExpensesDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IExpensesDtoPagedResultDto {
  items: ExpensesDto[] | undefined;
  totalCount: number;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
  authProvider: string;
  providerKey: string;
  providerAccessCode: string;

  constructor(data?: IExternalAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.authProvider = _data["authProvider"];
      this.providerKey = _data["providerKey"];
      this.providerAccessCode = _data["providerAccessCode"];
    }
  }

  static fromJS(data: any): ExternalAuthenticateModel {
    data = typeof data === "object" ? data : {};
    let result = new ExternalAuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["authProvider"] = this.authProvider;
    data["providerKey"] = this.providerKey;
    data["providerAccessCode"] = this.providerAccessCode;
    return data;
  }

  clone(): ExternalAuthenticateModel {
    const json = this.toJSON();
    let result = new ExternalAuthenticateModel();
    result.init(json);
    return result;
  }
}

export interface IExternalAuthenticateModel {
  authProvider: string;
  providerKey: string;
  providerAccessCode: string;
}

export class ExternalAuthenticateResultModel
  implements IExternalAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  waitingForActivation: boolean;

  constructor(data?: IExternalAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data["accessToken"];
      this.encryptedAccessToken = _data["encryptedAccessToken"];
      this.expireInSeconds = _data["expireInSeconds"];
      this.waitingForActivation = _data["waitingForActivation"];
    }
  }

  static fromJS(data: any): ExternalAuthenticateResultModel {
    data = typeof data === "object" ? data : {};
    let result = new ExternalAuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["accessToken"] = this.accessToken;
    data["encryptedAccessToken"] = this.encryptedAccessToken;
    data["expireInSeconds"] = this.expireInSeconds;
    data["waitingForActivation"] = this.waitingForActivation;
    return data;
  }

  clone(): ExternalAuthenticateResultModel {
    const json = this.toJSON();
    let result = new ExternalAuthenticateResultModel();
    result.init(json);
    return result;
  }
}

export interface IExternalAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel
  implements IExternalLoginProviderInfoModel {
  name: string | undefined;
  clientId: string | undefined;

  constructor(data?: IExternalLoginProviderInfoModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.clientId = _data["clientId"];
    }
  }

  static fromJS(data: any): ExternalLoginProviderInfoModel {
    data = typeof data === "object" ? data : {};
    let result = new ExternalLoginProviderInfoModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["clientId"] = this.clientId;
    return data;
  }

  clone(): ExternalLoginProviderInfoModel {
    const json = this.toJSON();
    let result = new ExternalLoginProviderInfoModel();
    result.init(json);
    return result;
  }
}

export interface IExternalLoginProviderInfoModel {
  name: string | undefined;
  clientId: string | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;

  constructor(data?: IFlatPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): FlatPermissionDto {
    data = typeof data === "object" ? data : {};
    let result = new FlatPermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    return data;
  }

  clone(): FlatPermissionDto {
    const json = this.toJSON();
    let result = new FlatPermissionDto();
    result.init(json);
    return result;
  }
}

export interface IFlatPermissionDto {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
}

export class GetCurrentLoginInformationsOutput
  implements IGetCurrentLoginInformationsOutput {
  application: ApplicationInfoDto;
  user: UserLoginInfoDto;
  tenant: TenantLoginInfoDto;

  constructor(data?: IGetCurrentLoginInformationsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.application = _data["application"]
        ? ApplicationInfoDto.fromJS(_data["application"])
        : <any>undefined;
      this.user = _data["user"]
        ? UserLoginInfoDto.fromJS(_data["user"])
        : <any>undefined;
      this.tenant = _data["tenant"]
        ? TenantLoginInfoDto.fromJS(_data["tenant"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetCurrentLoginInformationsOutput {
    data = typeof data === "object" ? data : {};
    let result = new GetCurrentLoginInformationsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["application"] = this.application
      ? this.application.toJSON()
      : <any>undefined;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
    return data;
  }

  clone(): GetCurrentLoginInformationsOutput {
    const json = this.toJSON();
    let result = new GetCurrentLoginInformationsOutput();
    result.init(json);
    return result;
  }
}

export interface IGetCurrentLoginInformationsOutput {
  application: ApplicationInfoDto;
  user: UserLoginInfoDto;
  tenant: TenantLoginInfoDto;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
  role: RoleEditDto;
  permissions: FlatPermissionDto[] | undefined;
  grantedPermissionNames: string[] | undefined;

  constructor(data?: IGetRoleForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.role = _data["role"]
        ? RoleEditDto.fromJS(_data["role"])
        : <any>undefined;
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"])
          this.permissions.push(FlatPermissionDto.fromJS(item));
      }
      if (Array.isArray(_data["grantedPermissionNames"])) {
        this.grantedPermissionNames = [] as any;
        for (let item of _data["grantedPermissionNames"])
          this.grantedPermissionNames.push(item);
      }
    }
  }

  static fromJS(data: any): GetRoleForEditOutput {
    data = typeof data === "object" ? data : {};
    let result = new GetRoleForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["role"] = this.role ? this.role.toJSON() : <any>undefined;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item.toJSON());
    }
    if (Array.isArray(this.grantedPermissionNames)) {
      data["grantedPermissionNames"] = [];
      for (let item of this.grantedPermissionNames)
        data["grantedPermissionNames"].push(item);
    }
    return data;
  }

  clone(): GetRoleForEditOutput {
    const json = this.toJSON();
    let result = new GetRoleForEditOutput();
    result.init(json);
    return result;
  }
}

export interface IGetRoleForEditOutput {
  role: RoleEditDto;
  permissions: FlatPermissionDto[] | undefined;
  grantedPermissionNames: string[] | undefined;
}

export class IncomeSource implements IIncomeSource {
  id: number;
  name: string | undefined;

  constructor(data?: IIncomeSource) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): IncomeSource {
    data = typeof data === "object" ? data : {};
    let result = new IncomeSource();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    return data;
  }

  clone(): IncomeSource {
    const json = this.toJSON();
    let result = new IncomeSource();
    result.init(json);
    return result;
  }
}

export interface IIncomeSource {
  id: number;
  name: string | undefined;
}

export class InsertApplicationRequest implements IInsertApplicationRequest {
  date: moment.Moment;
  loanNoIdentifierB1B3: string | undefined;
  agencyCaseNoB2: string | undefined;
  creditTypeId: number;
  totalBorrowers1a6: number | undefined;
  initials: string | undefined;

  constructor(data?: IInsertApplicationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data["date"]
        ? moment(_data["date"].toString())
        : <any>undefined;
      this.loanNoIdentifierB1B3 = _data["loanNoIdentifierB1B3"];
      this.agencyCaseNoB2 = _data["agencyCaseNoB2"];
      this.creditTypeId = _data["creditTypeId"];
      this.totalBorrowers1a6 = _data["totalBorrowers1a6"];
      this.initials = _data["initials"];
    }
  }

  static fromJS(data: any): InsertApplicationRequest {
    data = typeof data === "object" ? data : {};
    let result = new InsertApplicationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["loanNoIdentifierB1B3"] = this.loanNoIdentifierB1B3;
    data["agencyCaseNoB2"] = this.agencyCaseNoB2;
    data["creditTypeId"] = this.creditTypeId;
    data["totalBorrowers1a6"] = this.totalBorrowers1a6;
    data["initials"] = this.initials;
    return data;
  }

  clone(): InsertApplicationRequest {
    const json = this.toJSON();
    let result = new InsertApplicationRequest();
    result.init(json);
    return result;
  }
}

export interface IInsertApplicationRequest {
  date: moment.Moment;
  loanNoIdentifierB1B3: string | undefined;
  agencyCaseNoB2: string | undefined;
  creditTypeId: number;
  totalBorrowers1a6: number | undefined;
  initials: string | undefined;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
  tenancyName: string;

  constructor(data?: IIsTenantAvailableInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data["tenancyName"];
    }
  }

  static fromJS(data: any): IsTenantAvailableInput {
    data = typeof data === "object" ? data : {};
    let result = new IsTenantAvailableInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tenancyName"] = this.tenancyName;
    return data;
  }

  clone(): IsTenantAvailableInput {
    const json = this.toJSON();
    let result = new IsTenantAvailableInput();
    result.init(json);
    return result;
  }
}

export interface IIsTenantAvailableInput {
  tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
  state: TenantAvailabilityState;
  tenantId: number | undefined;

  constructor(data?: IIsTenantAvailableOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.state = _data["state"];
      this.tenantId = _data["tenantId"];
    }
  }

  static fromJS(data: any): IsTenantAvailableOutput {
    data = typeof data === "object" ? data : {};
    let result = new IsTenantAvailableOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["state"] = this.state;
    data["tenantId"] = this.tenantId;
    return data;
  }

  clone(): IsTenantAvailableOutput {
    const json = this.toJSON();
    let result = new IsTenantAvailableOutput();
    result.init(json);
    return result;
  }
}

export interface IIsTenantAvailableOutput {
  state: TenantAvailabilityState;
  tenantId: number | undefined;
}

export class LoanApplication implements ILoanApplication {
  id: number;
  loanDetailId: number | undefined;
  loanDetail: LoanDetail;
  additionalDetailId: number | undefined;
  additionalDetail: AdditionalDetail;
  personalDetailId: number | undefined;
  personalDetail: PersonalDetail;
  creditAuthAgreementId: number | undefined;
  creditAuthAgreement: CreditAuthAgreement;
  consentDetailId: number | undefined;
  consentDetail: ConsentDetail;
  expenseId: number | undefined;
  expense: Expense;
  manualAssetEntries: ManualAssetEntry[] | undefined;
  borrowerEmploymentInformations: BorrowerEmploymentInformation[] | undefined;
  borrowerMonthlyIncomes: BorrowerMonthlyIncome[] | undefined;
  demographicsInformations:
    | DeclarationBorrowereDemographicsInformation[]
    | undefined;
  declarations: Declaration[] | undefined;
  additionalIncomes: AdditionalIncome[] | undefined;
  updatedOn: moment.Moment;

  constructor(data?: ILoanApplication) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.loanDetailId = _data["loanDetailId"];
      this.loanDetail = _data["loanDetail"]
        ? LoanDetail.fromJS(_data["loanDetail"])
        : <any>undefined;
      this.additionalDetailId = _data["additionalDetailId"];
      this.additionalDetail = _data["additionalDetail"]
        ? AdditionalDetail.fromJS(_data["additionalDetail"])
        : <any>undefined;
      this.personalDetailId = _data["personalDetailId"];
      this.personalDetail = _data["personalDetail"]
        ? PersonalDetail.fromJS(_data["personalDetail"])
        : <any>undefined;
      this.creditAuthAgreementId = _data["creditAuthAgreementId"];
      this.creditAuthAgreement = _data["creditAuthAgreement"]
        ? CreditAuthAgreement.fromJS(_data["creditAuthAgreement"])
        : <any>undefined;
      this.consentDetailId = _data["consentDetailId"];
      this.consentDetail = _data["consentDetail"]
        ? ConsentDetail.fromJS(_data["consentDetail"])
        : <any>undefined;
      this.expenseId = _data["expenseId"];
      this.expense = _data["expense"]
        ? Expense.fromJS(_data["expense"])
        : <any>undefined;
      if (Array.isArray(_data["manualAssetEntries"])) {
        this.manualAssetEntries = [] as any;
        for (let item of _data["manualAssetEntries"])
          this.manualAssetEntries.push(ManualAssetEntry.fromJS(item));
      }
      if (Array.isArray(_data["borrowerEmploymentInformations"])) {
        this.borrowerEmploymentInformations = [] as any;
        for (let item of _data["borrowerEmploymentInformations"])
          this.borrowerEmploymentInformations.push(
            BorrowerEmploymentInformation.fromJS(item)
          );
      }
      if (Array.isArray(_data["borrowerMonthlyIncomes"])) {
        this.borrowerMonthlyIncomes = [] as any;
        for (let item of _data["borrowerMonthlyIncomes"])
          this.borrowerMonthlyIncomes.push(BorrowerMonthlyIncome.fromJS(item));
      }
      if (Array.isArray(_data["demographicsInformations"])) {
        this.demographicsInformations = [] as any;
        for (let item of _data["demographicsInformations"])
          this.demographicsInformations.push(
            DeclarationBorrowereDemographicsInformation.fromJS(item)
          );
      }
      if (Array.isArray(_data["declarations"])) {
        this.declarations = [] as any;
        for (let item of _data["declarations"])
          this.declarations.push(Declaration.fromJS(item));
      }
      if (Array.isArray(_data["additionalIncomes"])) {
        this.additionalIncomes = [] as any;
        for (let item of _data["additionalIncomes"])
          this.additionalIncomes.push(AdditionalIncome.fromJS(item));
      }
      this.updatedOn = _data["updatedOn"]
        ? moment(_data["updatedOn"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): LoanApplication {
    data = typeof data === "object" ? data : {};
    let result = new LoanApplication();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["loanDetailId"] = this.loanDetailId;
    data["loanDetail"] = this.loanDetail
      ? this.loanDetail.toJSON()
      : <any>undefined;
    data["additionalDetailId"] = this.additionalDetailId;
    data["additionalDetail"] = this.additionalDetail
      ? this.additionalDetail.toJSON()
      : <any>undefined;
    data["personalDetailId"] = this.personalDetailId;
    data["personalDetail"] = this.personalDetail
      ? this.personalDetail.toJSON()
      : <any>undefined;
    data["creditAuthAgreementId"] = this.creditAuthAgreementId;
    data["creditAuthAgreement"] = this.creditAuthAgreement
      ? this.creditAuthAgreement.toJSON()
      : <any>undefined;
    data["consentDetailId"] = this.consentDetailId;
    data["consentDetail"] = this.consentDetail
      ? this.consentDetail.toJSON()
      : <any>undefined;
    data["expenseId"] = this.expenseId;
    data["expense"] = this.expense ? this.expense.toJSON() : <any>undefined;
    if (Array.isArray(this.manualAssetEntries)) {
      data["manualAssetEntries"] = [];
      for (let item of this.manualAssetEntries)
        data["manualAssetEntries"].push(item.toJSON());
    }
    if (Array.isArray(this.borrowerEmploymentInformations)) {
      data["borrowerEmploymentInformations"] = [];
      for (let item of this.borrowerEmploymentInformations)
        data["borrowerEmploymentInformations"].push(item.toJSON());
    }
    if (Array.isArray(this.borrowerMonthlyIncomes)) {
      data["borrowerMonthlyIncomes"] = [];
      for (let item of this.borrowerMonthlyIncomes)
        data["borrowerMonthlyIncomes"].push(item.toJSON());
    }
    if (Array.isArray(this.demographicsInformations)) {
      data["demographicsInformations"] = [];
      for (let item of this.demographicsInformations)
        data["demographicsInformations"].push(item.toJSON());
    }
    if (Array.isArray(this.declarations)) {
      data["declarations"] = [];
      for (let item of this.declarations)
        data["declarations"].push(item.toJSON());
    }
    if (Array.isArray(this.additionalIncomes)) {
      data["additionalIncomes"] = [];
      for (let item of this.additionalIncomes)
        data["additionalIncomes"].push(item.toJSON());
    }
    data["updatedOn"] = this.updatedOn
      ? this.updatedOn.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): LoanApplication {
    const json = this.toJSON();
    let result = new LoanApplication();
    result.init(json);
    return result;
  }
}

export interface ILoanApplication {
  id: number;
  loanDetailId: number | undefined;
  loanDetail: LoanDetail;
  additionalDetailId: number | undefined;
  additionalDetail: AdditionalDetail;
  personalDetailId: number | undefined;
  personalDetail: PersonalDetail;
  creditAuthAgreementId: number | undefined;
  creditAuthAgreement: CreditAuthAgreement;
  consentDetailId: number | undefined;
  consentDetail: ConsentDetail;
  expenseId: number | undefined;
  expense: Expense;
  manualAssetEntries: ManualAssetEntry[] | undefined;
  borrowerEmploymentInformations: BorrowerEmploymentInformation[] | undefined;
  borrowerMonthlyIncomes: BorrowerMonthlyIncome[] | undefined;
  demographicsInformations:
    | DeclarationBorrowereDemographicsInformation[]
    | undefined;
  declarations: Declaration[] | undefined;
  additionalIncomes: AdditionalIncome[] | undefined;
  updatedOn: moment.Moment;
}

export class LoanApplicationDto implements ILoanApplicationDto {
  id: number | undefined;
  loanDetails: LoanDetailDto;
  personalInformation: PersonalInformationDto;
  expenses: ExpensesDto;
  manualAssetEntries: ManualAssetEntryDto[] | undefined;
  employmentIncome: EmploymentIncomeDto;
  orderCredit: CreditAuthAgreementDto;
  additionalDetails: AdditionalDetailsDto;
  eConsent: EConsentDto;
  declaration: DeclarationDto;

  constructor(data?: ILoanApplicationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.loanDetails = _data["loanDetails"]
        ? LoanDetailDto.fromJS(_data["loanDetails"])
        : <any>undefined;
      this.personalInformation = _data["personalInformation"]
        ? PersonalInformationDto.fromJS(_data["personalInformation"])
        : <any>undefined;
      this.expenses = _data["expenses"]
        ? ExpensesDto.fromJS(_data["expenses"])
        : <any>undefined;
      if (Array.isArray(_data["manualAssetEntries"])) {
        this.manualAssetEntries = [] as any;
        for (let item of _data["manualAssetEntries"])
          this.manualAssetEntries.push(ManualAssetEntryDto.fromJS(item));
      }
      this.employmentIncome = _data["employmentIncome"]
        ? EmploymentIncomeDto.fromJS(_data["employmentIncome"])
        : <any>undefined;
      this.orderCredit = _data["orderCredit"]
        ? CreditAuthAgreementDto.fromJS(_data["orderCredit"])
        : <any>undefined;
      this.additionalDetails = _data["additionalDetails"]
        ? AdditionalDetailsDto.fromJS(_data["additionalDetails"])
        : <any>undefined;
      this.eConsent = _data["eConsent"]
        ? EConsentDto.fromJS(_data["eConsent"])
        : <any>undefined;
      this.declaration = _data["declaration"]
        ? DeclarationDto.fromJS(_data["declaration"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): LoanApplicationDto {
    data = typeof data === "object" ? data : {};
    let result = new LoanApplicationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["loanDetails"] = this.loanDetails
      ? this.loanDetails.toJSON()
      : <any>undefined;
    data["personalInformation"] = this.personalInformation
      ? this.personalInformation.toJSON()
      : <any>undefined;
    data["expenses"] = this.expenses ? this.expenses.toJSON() : <any>undefined;
    if (Array.isArray(this.manualAssetEntries)) {
      data["manualAssetEntries"] = [];
      for (let item of this.manualAssetEntries)
        data["manualAssetEntries"].push(item.toJSON());
    }
    data["employmentIncome"] = this.employmentIncome
      ? this.employmentIncome.toJSON()
      : <any>undefined;
    data["orderCredit"] = this.orderCredit
      ? this.orderCredit.toJSON()
      : <any>undefined;
    data["additionalDetails"] = this.additionalDetails
      ? this.additionalDetails.toJSON()
      : <any>undefined;
    data["eConsent"] = this.eConsent ? this.eConsent.toJSON() : <any>undefined;
    data["declaration"] = this.declaration
      ? this.declaration.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): LoanApplicationDto {
    const json = this.toJSON();
    let result = new LoanApplicationDto();
    result.init(json);
    return result;
  }
}

export interface ILoanApplicationDto {
  id: number | undefined;
  loanDetails: LoanDetailDto;
  personalInformation: PersonalInformationDto;
  expenses: ExpensesDto;
  manualAssetEntries: ManualAssetEntryDto[] | undefined;
  employmentIncome: EmploymentIncomeDto;
  orderCredit: CreditAuthAgreementDto;
  additionalDetails: AdditionalDetailsDto;
  eConsent: EConsentDto;
  declaration: DeclarationDto;
}

export class LoanApplicationDtoPagedResultDto
  implements ILoanApplicationDtoPagedResultDto {
  items: LoanApplicationDto[] | undefined;
  totalCount: number;

  constructor(data?: ILoanApplicationDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(LoanApplicationDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): LoanApplicationDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new LoanApplicationDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): LoanApplicationDtoPagedResultDto {
    const json = this.toJSON();
    let result = new LoanApplicationDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ILoanApplicationDtoPagedResultDto {
  items: LoanApplicationDto[] | undefined;
  totalCount: number;
}

export class LoanDetail implements ILoanDetail {
  id: number;
  isWorkingWithOfficer: boolean | undefined;
  loanOfficerId: string | undefined;
  whatStageAreyouIn: number | undefined;
  referredBy: string | undefined;
  purposeOfLoan: number | undefined;
  estimatedValue: number | undefined;
  currentLoanAmount: number | undefined;
  requestedLoanAmount: number | undefined;
  estimatedPurchasePrice: number | undefined;
  estimatedAnnualTaxes: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  sourceOfDownPayment: number | undefined;
  giftAmount: number | undefined;
  giftExplanation: string | undefined;
  haveSecondMortgage: boolean | undefined;
  hoaDues: number | undefined;
  secondMortgageAmount: number | undefined;
  payLoanWithNewLoan: boolean | undefined;
  refinancingCurrentHome: boolean | undefined;
  yearAcquired: string | undefined;
  originalPrice: number | undefined;
  address: string | undefined;
  unit: string | undefined;
  zipCode: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  propertyTypeId: number | undefined;
  propertyUseId: number | undefined;
  startedLookingForNewHome: boolean | undefined;
  newConstruction: boolean | undefined;
  bankOwned: boolean | undefined;
  contractDate: string | undefined;
  creditScore: string | undefined;
  firstName: string | undefined;
  middleName: string | undefined;
  lastName: string | undefined;
  phoneNumber: string | undefined;
  emailAddress: string | undefined;
  typeOfHome: number | undefined;

  constructor(data?: ILoanDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isWorkingWithOfficer = _data["isWorkingWithOfficer"];
      this.loanOfficerId = _data["loanOfficerId"];
      this.whatStageAreyouIn = _data["whatStageAreyouIn"];
      this.referredBy = _data["referredBy"];
      this.purposeOfLoan = _data["purposeOfLoan"];
      this.estimatedValue = _data["estimatedValue"];
      this.currentLoanAmount = _data["currentLoanAmount"];
      this.requestedLoanAmount = _data["requestedLoanAmount"];
      this.estimatedPurchasePrice = _data["estimatedPurchasePrice"];
      this.estimatedAnnualTaxes = _data["estimatedAnnualTaxes"];
      this.estimatedAnnualHomeInsurance = _data["estimatedAnnualHomeInsurance"];
      this.downPaymentAmount = _data["downPaymentAmount"];
      this.downPaymentPercentage = _data["downPaymentPercentage"];
      this.sourceOfDownPayment = _data["sourceOfDownPayment"];
      this.giftAmount = _data["giftAmount"];
      this.giftExplanation = _data["giftExplanation"];
      this.haveSecondMortgage = _data["haveSecondMortgage"];
      this.hoaDues = _data["hoaDues"];
      this.secondMortgageAmount = _data["secondMortgageAmount"];
      this.payLoanWithNewLoan = _data["payLoanWithNewLoan"];
      this.refinancingCurrentHome = _data["refinancingCurrentHome"];
      this.yearAcquired = _data["yearAcquired"];
      this.originalPrice = _data["originalPrice"];
      this.address = _data["address"];
      this.unit = _data["unit"];
      this.zipCode = _data["zipCode"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.propertyTypeId = _data["propertyTypeId"];
      this.propertyUseId = _data["propertyUseId"];
      this.startedLookingForNewHome = _data["startedLookingForNewHome"];
      this.newConstruction = _data["newConstruction"];
      this.bankOwned = _data["bankOwned"];
      this.contractDate = _data["contractDate"];
      this.creditScore = _data["creditScore"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.phoneNumber = _data["phoneNumber"];
      this.emailAddress = _data["emailAddress"];
      this.typeOfHome = _data["typeOfHome"];
    }
  }

  static fromJS(data: any): LoanDetail {
    data = typeof data === "object" ? data : {};
    let result = new LoanDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["isWorkingWithOfficer"] = this.isWorkingWithOfficer;
    data["loanOfficerId"] = this.loanOfficerId;
    data["whatStageAreyouIn"] = this.whatStageAreyouIn;
    data["referredBy"] = this.referredBy;
    data["purposeOfLoan"] = this.purposeOfLoan;
    data["estimatedValue"] = this.estimatedValue;
    data["currentLoanAmount"] = this.currentLoanAmount;
    data["requestedLoanAmount"] = this.requestedLoanAmount;
    data["estimatedPurchasePrice"] = this.estimatedPurchasePrice;
    data["estimatedAnnualTaxes"] = this.estimatedAnnualTaxes;
    data["estimatedAnnualHomeInsurance"] = this.estimatedAnnualHomeInsurance;
    data["downPaymentAmount"] = this.downPaymentAmount;
    data["downPaymentPercentage"] = this.downPaymentPercentage;
    data["sourceOfDownPayment"] = this.sourceOfDownPayment;
    data["giftAmount"] = this.giftAmount;
    data["giftExplanation"] = this.giftExplanation;
    data["haveSecondMortgage"] = this.haveSecondMortgage;
    data["hoaDues"] = this.hoaDues;
    data["secondMortgageAmount"] = this.secondMortgageAmount;
    data["payLoanWithNewLoan"] = this.payLoanWithNewLoan;
    data["refinancingCurrentHome"] = this.refinancingCurrentHome;
    data["yearAcquired"] = this.yearAcquired;
    data["originalPrice"] = this.originalPrice;
    data["address"] = this.address;
    data["unit"] = this.unit;
    data["zipCode"] = this.zipCode;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["propertyTypeId"] = this.propertyTypeId;
    data["propertyUseId"] = this.propertyUseId;
    data["startedLookingForNewHome"] = this.startedLookingForNewHome;
    data["newConstruction"] = this.newConstruction;
    data["bankOwned"] = this.bankOwned;
    data["contractDate"] = this.contractDate;
    data["creditScore"] = this.creditScore;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["phoneNumber"] = this.phoneNumber;
    data["emailAddress"] = this.emailAddress;
    data["typeOfHome"] = this.typeOfHome;
    return data;
  }

  clone(): LoanDetail {
    const json = this.toJSON();
    let result = new LoanDetail();
    result.init(json);
    return result;
  }
}

export interface ILoanDetail {
  id: number;
  isWorkingWithOfficer: boolean | undefined;
  loanOfficerId: string | undefined;
  whatStageAreyouIn: number | undefined;
  referredBy: string | undefined;
  purposeOfLoan: number | undefined;
  estimatedValue: number | undefined;
  currentLoanAmount: number | undefined;
  requestedLoanAmount: number | undefined;
  estimatedPurchasePrice: number | undefined;
  estimatedAnnualTaxes: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  sourceOfDownPayment: number | undefined;
  giftAmount: number | undefined;
  giftExplanation: string | undefined;
  haveSecondMortgage: boolean | undefined;
  hoaDues: number | undefined;
  secondMortgageAmount: number | undefined;
  payLoanWithNewLoan: boolean | undefined;
  refinancingCurrentHome: boolean | undefined;
  yearAcquired: string | undefined;
  originalPrice: number | undefined;
  address: string | undefined;
  unit: string | undefined;
  zipCode: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  propertyTypeId: number | undefined;
  propertyUseId: number | undefined;
  startedLookingForNewHome: boolean | undefined;
  newConstruction: boolean | undefined;
  bankOwned: boolean | undefined;
  contractDate: string | undefined;
  creditScore: string | undefined;
  firstName: string | undefined;
  middleName: string | undefined;
  lastName: string | undefined;
  phoneNumber: string | undefined;
  emailAddress: string | undefined;
  typeOfHome: number | undefined;
}

export class LoanDetailDto implements ILoanDetailDto {
  id: number | undefined;
  isWorkingWithOfficer: boolean | undefined;
  loanOfficerId: string | undefined;
  whatStageAreyouIn: number | undefined;
  referredBy: string | undefined;
  estimatedAnnualTaxes: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  purposeOfLoan: number | undefined;
  estimatedValue: number | undefined;
  currentLoanAmount: number | undefined;
  requestedLoanAmount: number | undefined;
  estimatedPurchasePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  sourceOfDownPayment: number | undefined;
  giftAmount: number | undefined;
  giftExplanation: string | undefined;
  haveSecondMortgage: boolean | undefined;
  secondMortgageAmount: number | undefined;
  payLoanWithNewLoan: boolean | undefined;
  refinancingCurrentHome: boolean | undefined;
  yearAcquired: string | undefined;
  originalPrice: number | undefined;
  address: string | undefined;
  unit: string | undefined;
  zipCode: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  propertyTypeId: number | undefined;
  propertyUseId: number | undefined;
  startedLookingForNewHome: boolean | undefined;
  newConstruction: boolean | undefined;
  bankOwned: boolean | undefined;
  contractDate: string | undefined;
  creditScore: string | undefined;
  firstName: string | undefined;
  middleName: string | undefined;
  lastName: string | undefined;
  phoneNumber: string | undefined;
  emailAddress: string | undefined;
  typeOfHome: number | undefined;
  hoaDues: number | undefined;

  constructor(data?: ILoanDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isWorkingWithOfficer = _data["isWorkingWithOfficer"];
      this.loanOfficerId = _data["loanOfficerId"];
      this.whatStageAreyouIn = _data["whatStageAreyouIn"];
      this.referredBy = _data["referredBy"];
      this.estimatedAnnualTaxes = _data["estimatedAnnualTaxes"];
      this.estimatedAnnualHomeInsurance = _data["estimatedAnnualHomeInsurance"];
      this.purposeOfLoan = _data["purposeOfLoan"];
      this.estimatedValue = _data["estimatedValue"];
      this.currentLoanAmount = _data["currentLoanAmount"];
      this.requestedLoanAmount = _data["requestedLoanAmount"];
      this.estimatedPurchasePrice = _data["estimatedPurchasePrice"];
      this.downPaymentAmount = _data["downPaymentAmount"];
      this.downPaymentPercentage = _data["downPaymentPercentage"];
      this.sourceOfDownPayment = _data["sourceOfDownPayment"];
      this.giftAmount = _data["giftAmount"];
      this.giftExplanation = _data["giftExplanation"];
      this.haveSecondMortgage = _data["haveSecondMortgage"];
      this.secondMortgageAmount = _data["secondMortgageAmount"];
      this.payLoanWithNewLoan = _data["payLoanWithNewLoan"];
      this.refinancingCurrentHome = _data["refinancingCurrentHome"];
      this.yearAcquired = _data["yearAcquired"];
      this.originalPrice = _data["originalPrice"];
      this.address = _data["address"];
      this.unit = _data["unit"];
      this.zipCode = _data["zipCode"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.propertyTypeId = _data["propertyTypeId"];
      this.propertyUseId = _data["propertyUseId"];
      this.startedLookingForNewHome = _data["startedLookingForNewHome"];
      this.newConstruction = _data["newConstruction"];
      this.bankOwned = _data["bankOwned"];
      this.contractDate = _data["contractDate"];
      this.creditScore = _data["creditScore"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.phoneNumber = _data["phoneNumber"];
      this.emailAddress = _data["emailAddress"];
      this.typeOfHome = _data["typeOfHome"];
      this.hoaDues = _data["hoaDues"];
    }
  }

  static fromJS(data: any): LoanDetailDto {
    data = typeof data === "object" ? data : {};
    let result = new LoanDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["isWorkingWithOfficer"] = this.isWorkingWithOfficer;
    data["loanOfficerId"] = this.loanOfficerId;
    data["whatStageAreyouIn"] = this.whatStageAreyouIn;
    data["referredBy"] = this.referredBy;
    data["estimatedAnnualTaxes"] = this.estimatedAnnualTaxes;
    data["estimatedAnnualHomeInsurance"] = this.estimatedAnnualHomeInsurance;
    data["purposeOfLoan"] = this.purposeOfLoan;
    data["estimatedValue"] = this.estimatedValue;
    data["currentLoanAmount"] = this.currentLoanAmount;
    data["requestedLoanAmount"] = this.requestedLoanAmount;
    data["estimatedPurchasePrice"] = this.estimatedPurchasePrice;
    data["downPaymentAmount"] = this.downPaymentAmount;
    data["downPaymentPercentage"] = this.downPaymentPercentage;
    data["sourceOfDownPayment"] = this.sourceOfDownPayment;
    data["giftAmount"] = this.giftAmount;
    data["giftExplanation"] = this.giftExplanation;
    data["haveSecondMortgage"] = this.haveSecondMortgage;
    data["secondMortgageAmount"] = this.secondMortgageAmount;
    data["payLoanWithNewLoan"] = this.payLoanWithNewLoan;
    data["refinancingCurrentHome"] = this.refinancingCurrentHome;
    data["yearAcquired"] = this.yearAcquired;
    data["originalPrice"] = this.originalPrice;
    data["address"] = this.address;
    data["unit"] = this.unit;
    data["zipCode"] = this.zipCode;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["propertyTypeId"] = this.propertyTypeId;
    data["propertyUseId"] = this.propertyUseId;
    data["startedLookingForNewHome"] = this.startedLookingForNewHome;
    data["newConstruction"] = this.newConstruction;
    data["bankOwned"] = this.bankOwned;
    data["contractDate"] = this.contractDate;
    data["creditScore"] = this.creditScore;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["phoneNumber"] = this.phoneNumber;
    data["emailAddress"] = this.emailAddress;
    data["typeOfHome"] = this.typeOfHome;
    data["hoaDues"] = this.hoaDues;
    return data;
  }

  clone(): LoanDetailDto {
    const json = this.toJSON();
    let result = new LoanDetailDto();
    result.init(json);
    return result;
  }
}

export interface ILoanDetailDto {
  id: number | undefined;
  isWorkingWithOfficer: boolean | undefined;
  loanOfficerId: string | undefined;
  whatStageAreyouIn: number | undefined;
  referredBy: string | undefined;
  estimatedAnnualTaxes: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  purposeOfLoan: number | undefined;
  estimatedValue: number | undefined;
  currentLoanAmount: number | undefined;
  requestedLoanAmount: number | undefined;
  estimatedPurchasePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  sourceOfDownPayment: number | undefined;
  giftAmount: number | undefined;
  giftExplanation: string | undefined;
  haveSecondMortgage: boolean | undefined;
  secondMortgageAmount: number | undefined;
  payLoanWithNewLoan: boolean | undefined;
  refinancingCurrentHome: boolean | undefined;
  yearAcquired: string | undefined;
  originalPrice: number | undefined;
  address: string | undefined;
  unit: string | undefined;
  zipCode: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  propertyTypeId: number | undefined;
  propertyUseId: number | undefined;
  startedLookingForNewHome: boolean | undefined;
  newConstruction: boolean | undefined;
  bankOwned: boolean | undefined;
  contractDate: string | undefined;
  creditScore: string | undefined;
  firstName: string | undefined;
  middleName: string | undefined;
  lastName: string | undefined;
  phoneNumber: string | undefined;
  emailAddress: string | undefined;
  typeOfHome: number | undefined;
  hoaDues: number | undefined;
}

export class LoanDetailDtoPagedResultDto
  implements ILoanDetailDtoPagedResultDto {
  items: LoanDetailDto[] | undefined;
  totalCount: number;

  constructor(data?: ILoanDetailDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(LoanDetailDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): LoanDetailDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new LoanDetailDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): LoanDetailDtoPagedResultDto {
    const json = this.toJSON();
    let result = new LoanDetailDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ILoanDetailDtoPagedResultDto {
  items: LoanDetailDto[] | undefined;
  totalCount: number;
}

export class LoanListDto implements ILoanListDto {
  id: number;
  borrower: string | undefined;
  fileName: string | undefined;
  loanStatus: string | undefined;
  statusDate: string | undefined;
  estClose: string | undefined;
  rateLoc: string | undefined;
  processor: string | undefined;
  originator: string | undefined;
  contact: string | undefined;

  constructor(data?: ILoanListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.borrower = _data["borrower"];
      this.fileName = _data["fileName"];
      this.loanStatus = _data["loanStatus"];
      this.statusDate = _data["statusDate"];
      this.estClose = _data["estClose"];
      this.rateLoc = _data["rateLoc"];
      this.processor = _data["processor"];
      this.originator = _data["originator"];
      this.contact = _data["contact"];
    }
  }

  static fromJS(data: any): LoanListDto {
    data = typeof data === "object" ? data : {};
    let result = new LoanListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["borrower"] = this.borrower;
    data["fileName"] = this.fileName;
    data["loanStatus"] = this.loanStatus;
    data["statusDate"] = this.statusDate;
    data["estClose"] = this.estClose;
    data["rateLoc"] = this.rateLoc;
    data["processor"] = this.processor;
    data["originator"] = this.originator;
    data["contact"] = this.contact;
    return data;
  }

  clone(): LoanListDto {
    const json = this.toJSON();
    let result = new LoanListDto();
    result.init(json);
    return result;
  }
}

export interface ILoanListDto {
  id: number;
  borrower: string | undefined;
  fileName: string | undefined;
  loanStatus: string | undefined;
  statusDate: string | undefined;
  estClose: string | undefined;
  rateLoc: string | undefined;
  processor: string | undefined;
  originator: string | undefined;
  contact: string | undefined;
}

export class LoanListDtoPagedResultDto implements ILoanListDtoPagedResultDto {
  items: LoanListDto[] | undefined;
  totalCount: number;

  constructor(data?: ILoanListDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(LoanListDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): LoanListDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new LoanListDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): LoanListDtoPagedResultDto {
    const json = this.toJSON();
    let result = new LoanListDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ILoanListDtoPagedResultDto {
  items: LoanListDto[] | undefined;
  totalCount: number;
}

export class LoanOptionHomeBuying implements ILoanOptionHomeBuying {
  id: number | undefined;
  propertyUse: string | undefined;
  propertyType: string | undefined;
  zipCode: string | undefined;
  howLongPlan: string | undefined;
  estimatePrice: number;
  downPayment: number;
  downPaymentPercent: number;
  firstTimeHomeBuying: boolean;
  militarySevice: boolean;
  important_to_you: string | undefined;
  rateCredit: string | undefined;
  workingWithLoanOfficer: boolean;
  plan_page11: string | undefined;
  plan_page12: string | undefined;
  page_13: string | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;

  constructor(data?: ILoanOptionHomeBuying) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.propertyUse = _data["propertyUse"];
      this.propertyType = _data["propertyType"];
      this.zipCode = _data["zipCode"];
      this.howLongPlan = _data["howLongPlan"];
      this.estimatePrice = _data["estimatePrice"];
      this.downPayment = _data["downPayment"];
      this.downPaymentPercent = _data["downPaymentPercent"];
      this.firstTimeHomeBuying = _data["firstTimeHomeBuying"];
      this.militarySevice = _data["militarySevice"];
      this.important_to_you = _data["important_to_you"];
      this.rateCredit = _data["rateCredit"];
      this.workingWithLoanOfficer = _data["workingWithLoanOfficer"];
      this.plan_page11 = _data["plan_page11"];
      this.plan_page12 = _data["plan_page12"];
      this.page_13 = _data["page_13"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.emailAddress = _data["emailAddress"];
      this.phoneNumber = _data["phoneNumber"];
    }
  }

  static fromJS(data: any): LoanOptionHomeBuying {
    data = typeof data === "object" ? data : {};
    let result = new LoanOptionHomeBuying();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["propertyUse"] = this.propertyUse;
    data["propertyType"] = this.propertyType;
    data["zipCode"] = this.zipCode;
    data["howLongPlan"] = this.howLongPlan;
    data["estimatePrice"] = this.estimatePrice;
    data["downPayment"] = this.downPayment;
    data["downPaymentPercent"] = this.downPaymentPercent;
    data["firstTimeHomeBuying"] = this.firstTimeHomeBuying;
    data["militarySevice"] = this.militarySevice;
    data["important_to_you"] = this.important_to_you;
    data["rateCredit"] = this.rateCredit;
    data["workingWithLoanOfficer"] = this.workingWithLoanOfficer;
    data["plan_page11"] = this.plan_page11;
    data["plan_page12"] = this.plan_page12;
    data["page_13"] = this.page_13;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["emailAddress"] = this.emailAddress;
    data["phoneNumber"] = this.phoneNumber;
    return data;
  }

  clone(): LoanOptionHomeBuying {
    const json = this.toJSON();
    let result = new LoanOptionHomeBuying();
    result.init(json);
    return result;
  }
}

export interface ILoanOptionHomeBuying {
  id: number | undefined;
  propertyUse: string | undefined;
  propertyType: string | undefined;
  zipCode: string | undefined;
  howLongPlan: string | undefined;
  estimatePrice: number;
  downPayment: number;
  downPaymentPercent: number;
  firstTimeHomeBuying: boolean;
  militarySevice: boolean;
  important_to_you: string | undefined;
  rateCredit: string | undefined;
  workingWithLoanOfficer: boolean;
  plan_page11: string | undefined;
  plan_page12: string | undefined;
  page_13: string | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;
}

export class ManualAssetEntry implements IManualAssetEntry {
  id: number;
  assetTypeId: number;
  accountNumber: string | undefined;
  cashValue: number | undefined;
  address: string | undefined;
  address2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: string | undefined;
  description: string | undefined;
  name: string | undefined;
  bankName: string | undefined;
  propertyStatus: string | undefined;
  propertyIsUsedAs: string | undefined;
  propertyType: string | undefined;
  presentMarketValue: number | undefined;
  outstandingMortgageBalance: number | undefined;
  monthlyMortgagePayment: number | undefined;
  purchasePrice: number | undefined;
  grossRentalIncome: number | undefined;
  taxesInsuranceAndOther: number | undefined;
  loanApplicationId: number;
  borrowerTypeId: number;
  state: State;
  assetType: AssetType;
  loanApplication: LoanApplication;
  stockAndBonds: StockAndBond[] | undefined;
  borrowerType: BorrowerType;

  constructor(data?: IManualAssetEntry) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.assetTypeId = _data["assetTypeId"];
      this.accountNumber = _data["accountNumber"];
      this.cashValue = _data["cashValue"];
      this.address = _data["address"];
      this.address2 = _data["address2"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.zipCode = _data["zipCode"];
      this.description = _data["description"];
      this.name = _data["name"];
      this.bankName = _data["bankName"];
      this.propertyStatus = _data["propertyStatus"];
      this.propertyIsUsedAs = _data["propertyIsUsedAs"];
      this.propertyType = _data["propertyType"];
      this.presentMarketValue = _data["presentMarketValue"];
      this.outstandingMortgageBalance = _data["outstandingMortgageBalance"];
      this.monthlyMortgagePayment = _data["monthlyMortgagePayment"];
      this.purchasePrice = _data["purchasePrice"];
      this.grossRentalIncome = _data["grossRentalIncome"];
      this.taxesInsuranceAndOther = _data["taxesInsuranceAndOther"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.state = _data["state"]
        ? State.fromJS(_data["state"])
        : <any>undefined;
      this.assetType = _data["assetType"]
        ? AssetType.fromJS(_data["assetType"])
        : <any>undefined;
      this.loanApplication = _data["loanApplication"]
        ? LoanApplication.fromJS(_data["loanApplication"])
        : <any>undefined;
      if (Array.isArray(_data["stockAndBonds"])) {
        this.stockAndBonds = [] as any;
        for (let item of _data["stockAndBonds"])
          this.stockAndBonds.push(StockAndBond.fromJS(item));
      }
      this.borrowerType = _data["borrowerType"]
        ? BorrowerType.fromJS(_data["borrowerType"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ManualAssetEntry {
    data = typeof data === "object" ? data : {};
    let result = new ManualAssetEntry();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["assetTypeId"] = this.assetTypeId;
    data["accountNumber"] = this.accountNumber;
    data["cashValue"] = this.cashValue;
    data["address"] = this.address;
    data["address2"] = this.address2;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["zipCode"] = this.zipCode;
    data["description"] = this.description;
    data["name"] = this.name;
    data["bankName"] = this.bankName;
    data["propertyStatus"] = this.propertyStatus;
    data["propertyIsUsedAs"] = this.propertyIsUsedAs;
    data["propertyType"] = this.propertyType;
    data["presentMarketValue"] = this.presentMarketValue;
    data["outstandingMortgageBalance"] = this.outstandingMortgageBalance;
    data["monthlyMortgagePayment"] = this.monthlyMortgagePayment;
    data["purchasePrice"] = this.purchasePrice;
    data["grossRentalIncome"] = this.grossRentalIncome;
    data["taxesInsuranceAndOther"] = this.taxesInsuranceAndOther;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["state"] = this.state ? this.state.toJSON() : <any>undefined;
    data["assetType"] = this.assetType
      ? this.assetType.toJSON()
      : <any>undefined;
    data["loanApplication"] = this.loanApplication
      ? this.loanApplication.toJSON()
      : <any>undefined;
    if (Array.isArray(this.stockAndBonds)) {
      data["stockAndBonds"] = [];
      for (let item of this.stockAndBonds)
        data["stockAndBonds"].push(item.toJSON());
    }
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): ManualAssetEntry {
    const json = this.toJSON();
    let result = new ManualAssetEntry();
    result.init(json);
    return result;
  }
}

export interface IManualAssetEntry {
  id: number;
  assetTypeId: number;
  accountNumber: string | undefined;
  cashValue: number | undefined;
  address: string | undefined;
  address2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: string | undefined;
  description: string | undefined;
  name: string | undefined;
  bankName: string | undefined;
  propertyStatus: string | undefined;
  propertyIsUsedAs: string | undefined;
  propertyType: string | undefined;
  presentMarketValue: number | undefined;
  outstandingMortgageBalance: number | undefined;
  monthlyMortgagePayment: number | undefined;
  purchasePrice: number | undefined;
  grossRentalIncome: number | undefined;
  taxesInsuranceAndOther: number | undefined;
  loanApplicationId: number;
  borrowerTypeId: number;
  state: State;
  assetType: AssetType;
  loanApplication: LoanApplication;
  stockAndBonds: StockAndBond[] | undefined;
  borrowerType: BorrowerType;
}

export class ManualAssetEntryDto implements IManualAssetEntryDto {
  id: number | undefined;
  assetTypeId: number;
  accountNumber: string | undefined;
  cashValue: number | undefined;
  address: string | undefined;
  address2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: string | undefined;
  description: string | undefined;
  name: string | undefined;
  bankName: string | undefined;
  propertyStatus: string | undefined;
  propertyIsUsedAs: string | undefined;
  propertyType: string | undefined;
  presentMarketValue: number | undefined;
  outstandingMortgageBalance: number | undefined;
  monthlyMortgagePayment: number | undefined;
  purchasePrice: number | undefined;
  grossRentalIncome: number | undefined;
  taxesInsuranceAndOther: number | undefined;
  loanApplicationId: number;
  borrowerTypeId: number;
  stockAndBonds: StockAndBondViewModel[] | undefined;

  constructor(data?: IManualAssetEntryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.assetTypeId = _data["assetTypeId"];
      this.accountNumber = _data["accountNumber"];
      this.cashValue = _data["cashValue"];
      this.address = _data["address"];
      this.address2 = _data["address2"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.zipCode = _data["zipCode"];
      this.description = _data["description"];
      this.name = _data["name"];
      this.bankName = _data["bankName"];
      this.propertyStatus = _data["propertyStatus"];
      this.propertyIsUsedAs = _data["propertyIsUsedAs"];
      this.propertyType = _data["propertyType"];
      this.presentMarketValue = _data["presentMarketValue"];
      this.outstandingMortgageBalance = _data["outstandingMortgageBalance"];
      this.monthlyMortgagePayment = _data["monthlyMortgagePayment"];
      this.purchasePrice = _data["purchasePrice"];
      this.grossRentalIncome = _data["grossRentalIncome"];
      this.taxesInsuranceAndOther = _data["taxesInsuranceAndOther"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      if (Array.isArray(_data["stockAndBonds"])) {
        this.stockAndBonds = [] as any;
        for (let item of _data["stockAndBonds"])
          this.stockAndBonds.push(StockAndBondViewModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ManualAssetEntryDto {
    data = typeof data === "object" ? data : {};
    let result = new ManualAssetEntryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["assetTypeId"] = this.assetTypeId;
    data["accountNumber"] = this.accountNumber;
    data["cashValue"] = this.cashValue;
    data["address"] = this.address;
    data["address2"] = this.address2;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["zipCode"] = this.zipCode;
    data["description"] = this.description;
    data["name"] = this.name;
    data["bankName"] = this.bankName;
    data["propertyStatus"] = this.propertyStatus;
    data["propertyIsUsedAs"] = this.propertyIsUsedAs;
    data["propertyType"] = this.propertyType;
    data["presentMarketValue"] = this.presentMarketValue;
    data["outstandingMortgageBalance"] = this.outstandingMortgageBalance;
    data["monthlyMortgagePayment"] = this.monthlyMortgagePayment;
    data["purchasePrice"] = this.purchasePrice;
    data["grossRentalIncome"] = this.grossRentalIncome;
    data["taxesInsuranceAndOther"] = this.taxesInsuranceAndOther;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    if (Array.isArray(this.stockAndBonds)) {
      data["stockAndBonds"] = [];
      for (let item of this.stockAndBonds)
        data["stockAndBonds"].push(item.toJSON());
    }
    return data;
  }

  clone(): ManualAssetEntryDto {
    const json = this.toJSON();
    let result = new ManualAssetEntryDto();
    result.init(json);
    return result;
  }
}

export interface IManualAssetEntryDto {
  id: number | undefined;
  assetTypeId: number;
  accountNumber: string | undefined;
  cashValue: number | undefined;
  address: string | undefined;
  address2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: string | undefined;
  description: string | undefined;
  name: string | undefined;
  bankName: string | undefined;
  propertyStatus: string | undefined;
  propertyIsUsedAs: string | undefined;
  propertyType: string | undefined;
  presentMarketValue: number | undefined;
  outstandingMortgageBalance: number | undefined;
  monthlyMortgagePayment: number | undefined;
  purchasePrice: number | undefined;
  grossRentalIncome: number | undefined;
  taxesInsuranceAndOther: number | undefined;
  loanApplicationId: number;
  borrowerTypeId: number;
  stockAndBonds: StockAndBondViewModel[] | undefined;
}

export class ManualAssetEntryDtoPagedResultDto
  implements IManualAssetEntryDtoPagedResultDto {
  items: ManualAssetEntryDto[] | undefined;
  totalCount: number;

  constructor(data?: IManualAssetEntryDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(ManualAssetEntryDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): ManualAssetEntryDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new ManualAssetEntryDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): ManualAssetEntryDtoPagedResultDto {
    const json = this.toJSON();
    let result = new ManualAssetEntryDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IManualAssetEntryDtoPagedResultDto {
  items: ManualAssetEntryDto[] | undefined;
  totalCount: number;
}

export class PagedLoanApplicationResultRequestDto
  implements IPagedLoanApplicationResultRequestDto {
  maxResultCount: number;
  skipCount: number;
  keyword: string | undefined;

  constructor(data?: IPagedLoanApplicationResultRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.maxResultCount = _data["maxResultCount"];
      this.skipCount = _data["skipCount"];
      this.keyword = _data["keyword"];
    }
  }

  static fromJS(data: any): PagedLoanApplicationResultRequestDto {
    data = typeof data === "object" ? data : {};
    let result = new PagedLoanApplicationResultRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["maxResultCount"] = this.maxResultCount;
    data["skipCount"] = this.skipCount;
    data["keyword"] = this.keyword;
    return data;
  }

  clone(): PagedLoanApplicationResultRequestDto {
    const json = this.toJSON();
    let result = new PagedLoanApplicationResultRequestDto();
    result.init(json);
    return result;
  }
}

export interface IPagedLoanApplicationResultRequestDto {
  maxResultCount: number;
  skipCount: number;
  keyword: string | undefined;
}

export class PermissionDto implements IPermissionDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;

  constructor(data?: IPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): PermissionDto {
    data = typeof data === "object" ? data : {};
    let result = new PermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    return data;
  }

  clone(): PermissionDto {
    const json = this.toJSON();
    let result = new PermissionDto();
    result.init(json);
    return result;
  }
}

export interface IPermissionDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
  items: PermissionDto[] | undefined;

  constructor(data?: IPermissionDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(PermissionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PermissionDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new PermissionDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PermissionDtoListResultDto {
    const json = this.toJSON();
    let result = new PermissionDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IPermissionDtoListResultDto {
  items: PermissionDto[] | undefined;
}

export class PersonalDetail implements IPersonalDetail {
  id: number;
  isApplyingWithCoBorrower: boolean | undefined;
  useIncomeOfPersonOtherThanBorrower: boolean | undefined;
  agreePrivacyPolicy: boolean | undefined;
  borrowerId: number | undefined;
  coBorrowerId: number | undefined;
  isMailingAddressSameAsResidential: boolean | undefined;
  coBorrowerIsMailingAddressSameAsResidential: boolean | undefined;
  coBorrowerResidentialAddressSameAsBorrowerResidential: boolean | undefined;
  borrower: Borrower;
  coBorrower: Borrower;
  addresses: Address[] | undefined;
  loanApplication: LoanApplication;

  constructor(data?: IPersonalDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isApplyingWithCoBorrower = _data["isApplyingWithCoBorrower"];
      this.useIncomeOfPersonOtherThanBorrower =
        _data["useIncomeOfPersonOtherThanBorrower"];
      this.agreePrivacyPolicy = _data["agreePrivacyPolicy"];
      this.borrowerId = _data["borrowerId"];
      this.coBorrowerId = _data["coBorrowerId"];
      this.isMailingAddressSameAsResidential =
        _data["isMailingAddressSameAsResidential"];
      this.coBorrowerIsMailingAddressSameAsResidential =
        _data["coBorrowerIsMailingAddressSameAsResidential"];
      this.coBorrowerResidentialAddressSameAsBorrowerResidential =
        _data["coBorrowerResidentialAddressSameAsBorrowerResidential"];
      this.borrower = _data["borrower"]
        ? Borrower.fromJS(_data["borrower"])
        : <any>undefined;
      this.coBorrower = _data["coBorrower"]
        ? Borrower.fromJS(_data["coBorrower"])
        : <any>undefined;
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"])
          this.addresses.push(Address.fromJS(item));
      }
      this.loanApplication = _data["loanApplication"]
        ? LoanApplication.fromJS(_data["loanApplication"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PersonalDetail {
    data = typeof data === "object" ? data : {};
    let result = new PersonalDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["isApplyingWithCoBorrower"] = this.isApplyingWithCoBorrower;
    data[
      "useIncomeOfPersonOtherThanBorrower"
    ] = this.useIncomeOfPersonOtherThanBorrower;
    data["agreePrivacyPolicy"] = this.agreePrivacyPolicy;
    data["borrowerId"] = this.borrowerId;
    data["coBorrowerId"] = this.coBorrowerId;
    data[
      "isMailingAddressSameAsResidential"
    ] = this.isMailingAddressSameAsResidential;
    data[
      "coBorrowerIsMailingAddressSameAsResidential"
    ] = this.coBorrowerIsMailingAddressSameAsResidential;
    data[
      "coBorrowerResidentialAddressSameAsBorrowerResidential"
    ] = this.coBorrowerResidentialAddressSameAsBorrowerResidential;
    data["borrower"] = this.borrower ? this.borrower.toJSON() : <any>undefined;
    data["coBorrower"] = this.coBorrower
      ? this.coBorrower.toJSON()
      : <any>undefined;
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item.toJSON());
    }
    data["loanApplication"] = this.loanApplication
      ? this.loanApplication.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): PersonalDetail {
    const json = this.toJSON();
    let result = new PersonalDetail();
    result.init(json);
    return result;
  }
}

export interface IPersonalDetail {
  id: number;
  isApplyingWithCoBorrower: boolean | undefined;
  useIncomeOfPersonOtherThanBorrower: boolean | undefined;
  agreePrivacyPolicy: boolean | undefined;
  borrowerId: number | undefined;
  coBorrowerId: number | undefined;
  isMailingAddressSameAsResidential: boolean | undefined;
  coBorrowerIsMailingAddressSameAsResidential: boolean | undefined;
  coBorrowerResidentialAddressSameAsBorrowerResidential: boolean | undefined;
  borrower: Borrower;
  coBorrower: Borrower;
  addresses: Address[] | undefined;
  loanApplication: LoanApplication;
}

export class PersonalInformationDto implements IPersonalInformationDto {
  id: number | undefined;
  isApplyingWithCoBorrower: boolean | undefined;
  useIncomeOfPersonOtherThanBorrower: boolean | undefined;
  agreePrivacyPolicy: boolean | undefined;
  borrower: BorrowerDto;
  coBorrower: BorrowerDto;
  residentialAddress: AddressDto;
  coBorrowerResidentialAddress: AddressDto;
  previousAddresses: AddressDto[] | undefined;
  mailingAddress: AddressDto;
  isMailingAddressSameAsResidential: boolean | undefined;
  coBorrowerPreviousAddresses: AddressDto[] | undefined;
  coBorrowerMailingAddress: AddressDto;
  coBorrowerIsMailingAddressSameAsResidential: boolean | undefined;
  loanApplicationId: number;
  coBorrowerResidentialAddressSameAsBorrowerResidential: boolean | undefined;

  constructor(data?: IPersonalInformationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isApplyingWithCoBorrower = _data["isApplyingWithCoBorrower"];
      this.useIncomeOfPersonOtherThanBorrower =
        _data["useIncomeOfPersonOtherThanBorrower"];
      this.agreePrivacyPolicy = _data["agreePrivacyPolicy"];
      this.borrower = _data["borrower"]
        ? BorrowerDto.fromJS(_data["borrower"])
        : <any>undefined;
      this.coBorrower = _data["coBorrower"]
        ? BorrowerDto.fromJS(_data["coBorrower"])
        : <any>undefined;
      this.residentialAddress = _data["residentialAddress"]
        ? AddressDto.fromJS(_data["residentialAddress"])
        : <any>undefined;
      this.coBorrowerResidentialAddress = _data["coBorrowerResidentialAddress"]
        ? AddressDto.fromJS(_data["coBorrowerResidentialAddress"])
        : <any>undefined;
      if (Array.isArray(_data["previousAddresses"])) {
        this.previousAddresses = [] as any;
        for (let item of _data["previousAddresses"])
          this.previousAddresses.push(AddressDto.fromJS(item));
      }
      this.mailingAddress = _data["mailingAddress"]
        ? AddressDto.fromJS(_data["mailingAddress"])
        : <any>undefined;
      this.isMailingAddressSameAsResidential =
        _data["isMailingAddressSameAsResidential"];
      if (Array.isArray(_data["coBorrowerPreviousAddresses"])) {
        this.coBorrowerPreviousAddresses = [] as any;
        for (let item of _data["coBorrowerPreviousAddresses"])
          this.coBorrowerPreviousAddresses.push(AddressDto.fromJS(item));
      }
      this.coBorrowerMailingAddress = _data["coBorrowerMailingAddress"]
        ? AddressDto.fromJS(_data["coBorrowerMailingAddress"])
        : <any>undefined;
      this.coBorrowerIsMailingAddressSameAsResidential =
        _data["coBorrowerIsMailingAddressSameAsResidential"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.coBorrowerResidentialAddressSameAsBorrowerResidential =
        _data["coBorrowerResidentialAddressSameAsBorrowerResidential"];
    }
  }

  static fromJS(data: any): PersonalInformationDto {
    data = typeof data === "object" ? data : {};
    let result = new PersonalInformationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["isApplyingWithCoBorrower"] = this.isApplyingWithCoBorrower;
    data[
      "useIncomeOfPersonOtherThanBorrower"
    ] = this.useIncomeOfPersonOtherThanBorrower;
    data["agreePrivacyPolicy"] = this.agreePrivacyPolicy;
    data["borrower"] = this.borrower ? this.borrower.toJSON() : <any>undefined;
    data["coBorrower"] = this.coBorrower
      ? this.coBorrower.toJSON()
      : <any>undefined;
    data["residentialAddress"] = this.residentialAddress
      ? this.residentialAddress.toJSON()
      : <any>undefined;
    data["coBorrowerResidentialAddress"] = this.coBorrowerResidentialAddress
      ? this.coBorrowerResidentialAddress.toJSON()
      : <any>undefined;
    if (Array.isArray(this.previousAddresses)) {
      data["previousAddresses"] = [];
      for (let item of this.previousAddresses)
        data["previousAddresses"].push(item.toJSON());
    }
    data["mailingAddress"] = this.mailingAddress
      ? this.mailingAddress.toJSON()
      : <any>undefined;
    data[
      "isMailingAddressSameAsResidential"
    ] = this.isMailingAddressSameAsResidential;
    if (Array.isArray(this.coBorrowerPreviousAddresses)) {
      data["coBorrowerPreviousAddresses"] = [];
      for (let item of this.coBorrowerPreviousAddresses)
        data["coBorrowerPreviousAddresses"].push(item.toJSON());
    }
    data["coBorrowerMailingAddress"] = this.coBorrowerMailingAddress
      ? this.coBorrowerMailingAddress.toJSON()
      : <any>undefined;
    data[
      "coBorrowerIsMailingAddressSameAsResidential"
    ] = this.coBorrowerIsMailingAddressSameAsResidential;
    data["loanApplicationId"] = this.loanApplicationId;
    data[
      "coBorrowerResidentialAddressSameAsBorrowerResidential"
    ] = this.coBorrowerResidentialAddressSameAsBorrowerResidential;
    return data;
  }

  clone(): PersonalInformationDto {
    const json = this.toJSON();
    let result = new PersonalInformationDto();
    result.init(json);
    return result;
  }
}

export interface IPersonalInformationDto {
  id: number | undefined;
  isApplyingWithCoBorrower: boolean | undefined;
  useIncomeOfPersonOtherThanBorrower: boolean | undefined;
  agreePrivacyPolicy: boolean | undefined;
  borrower: BorrowerDto;
  coBorrower: BorrowerDto;
  residentialAddress: AddressDto;
  coBorrowerResidentialAddress: AddressDto;
  previousAddresses: AddressDto[] | undefined;
  mailingAddress: AddressDto;
  isMailingAddressSameAsResidential: boolean | undefined;
  coBorrowerPreviousAddresses: AddressDto[] | undefined;
  coBorrowerMailingAddress: AddressDto;
  coBorrowerIsMailingAddressSameAsResidential: boolean | undefined;
  loanApplicationId: number;
  coBorrowerResidentialAddressSameAsBorrowerResidential: boolean | undefined;
}

export class PersonalInformationDtoPagedResultDto
  implements IPersonalInformationDtoPagedResultDto {
  items: PersonalInformationDto[] | undefined;
  totalCount: number;

  constructor(data?: IPersonalInformationDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(PersonalInformationDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): PersonalInformationDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new PersonalInformationDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): PersonalInformationDtoPagedResultDto {
    const json = this.toJSON();
    let result = new PersonalInformationDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IPersonalInformationDtoPagedResultDto {
  items: PersonalInformationDto[] | undefined;
  totalCount: number;
}

export class RefinanceHomeBuyingDto implements IRefinanceHomeBuyingDto {
  id: number | undefined;
  propertyLocated: string | undefined;
  propertyType: string | undefined;
  propertyUse: string | undefined;
  wantRefinance: string | undefined;
  homePrice: number;
  owe: number;
  cashBorrow: number;
  fhaLoan: string | undefined;
  militarySevice: boolean;
  foreclosurePastTwoYears: boolean;
  bankruptcyPastThreeYears: boolean;
  lateMortgagePayments: string | undefined;
  currentEmployed: string | undefined;
  houseHoldIncome: string | undefined;
  proofOfincome: boolean;
  rateCredit: string | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;
  refferedBy: string | undefined;

  constructor(data?: IRefinanceHomeBuyingDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.propertyLocated = _data["propertyLocated"];
      this.propertyType = _data["propertyType"];
      this.propertyUse = _data["propertyUse"];
      this.wantRefinance = _data["wantRefinance"];
      this.homePrice = _data["homePrice"];
      this.owe = _data["owe"];
      this.cashBorrow = _data["cashBorrow"];
      this.fhaLoan = _data["fhaLoan"];
      this.militarySevice = _data["militarySevice"];
      this.foreclosurePastTwoYears = _data["foreclosurePastTwoYears"];
      this.bankruptcyPastThreeYears = _data["bankruptcyPastThreeYears"];
      this.lateMortgagePayments = _data["lateMortgagePayments"];
      this.currentEmployed = _data["currentEmployed"];
      this.houseHoldIncome = _data["houseHoldIncome"];
      this.proofOfincome = _data["proofOfincome"];
      this.rateCredit = _data["rateCredit"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.emailAddress = _data["emailAddress"];
      this.phoneNumber = _data["phoneNumber"];
      this.refferedBy = _data["refferedBy"];
    }
  }

  static fromJS(data: any): RefinanceHomeBuyingDto {
    data = typeof data === "object" ? data : {};
    let result = new RefinanceHomeBuyingDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["propertyLocated"] = this.propertyLocated;
    data["propertyType"] = this.propertyType;
    data["propertyUse"] = this.propertyUse;
    data["wantRefinance"] = this.wantRefinance;
    data["homePrice"] = this.homePrice;
    data["owe"] = this.owe;
    data["cashBorrow"] = this.cashBorrow;
    data["fhaLoan"] = this.fhaLoan;
    data["militarySevice"] = this.militarySevice;
    data["foreclosurePastTwoYears"] = this.foreclosurePastTwoYears;
    data["bankruptcyPastThreeYears"] = this.bankruptcyPastThreeYears;
    data["lateMortgagePayments"] = this.lateMortgagePayments;
    data["currentEmployed"] = this.currentEmployed;
    data["houseHoldIncome"] = this.houseHoldIncome;
    data["proofOfincome"] = this.proofOfincome;
    data["rateCredit"] = this.rateCredit;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["emailAddress"] = this.emailAddress;
    data["phoneNumber"] = this.phoneNumber;
    data["refferedBy"] = this.refferedBy;
    return data;
  }

  clone(): RefinanceHomeBuyingDto {
    const json = this.toJSON();
    let result = new RefinanceHomeBuyingDto();
    result.init(json);
    return result;
  }
}

export interface IRefinanceHomeBuyingDto {
  id: number | undefined;
  propertyLocated: string | undefined;
  propertyType: string | undefined;
  propertyUse: string | undefined;
  wantRefinance: string | undefined;
  homePrice: number;
  owe: number;
  cashBorrow: number;
  fhaLoan: string | undefined;
  militarySevice: boolean;
  foreclosurePastTwoYears: boolean;
  bankruptcyPastThreeYears: boolean;
  lateMortgagePayments: string | undefined;
  currentEmployed: string | undefined;
  houseHoldIncome: string | undefined;
  proofOfincome: boolean;
  rateCredit: string | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;
  refferedBy: string | undefined;
}

export class RefinanceHomeBuyingDtoPagedResultDto
  implements IRefinanceHomeBuyingDtoPagedResultDto {
  items: RefinanceHomeBuyingDto[] | undefined;
  totalCount: number;

  constructor(data?: IRefinanceHomeBuyingDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(RefinanceHomeBuyingDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): RefinanceHomeBuyingDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RefinanceHomeBuyingDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): RefinanceHomeBuyingDtoPagedResultDto {
    const json = this.toJSON();
    let result = new RefinanceHomeBuyingDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IRefinanceHomeBuyingDtoPagedResultDto {
  items: RefinanceHomeBuyingDto[] | undefined;
  totalCount: number;
}

export class RefinanceLoanOption implements IRefinanceLoanOption {
  id: number | undefined;
  important_to_you: string | undefined;
  propertyUse: string | undefined;
  propertyType: string | undefined;
  zipCode: string | undefined;
  estimatePrice: number;
  remainingBalalnce: number;
  haveAnyOtherLoanForThisProperty: boolean;
  loanHomeEquity: boolean;
  payThatOff: boolean;
  balanceOfHomeEquity: number;
  homeEquityPurchase: boolean;
  borrowAdditionalCash: number;
  howLongPlan: string | undefined;
  militarySevice: boolean;
  rateCredit: string | undefined;
  workingWithLoanOfficer: boolean;
  officerName: string | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;

  constructor(data?: IRefinanceLoanOption) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.important_to_you = _data["important_to_you"];
      this.propertyUse = _data["propertyUse"];
      this.propertyType = _data["propertyType"];
      this.zipCode = _data["zipCode"];
      this.estimatePrice = _data["estimatePrice"];
      this.remainingBalalnce = _data["remainingBalalnce"];
      this.haveAnyOtherLoanForThisProperty =
        _data["haveAnyOtherLoanForThisProperty"];
      this.loanHomeEquity = _data["loanHomeEquity"];
      this.payThatOff = _data["payThatOff"];
      this.balanceOfHomeEquity = _data["balanceOfHomeEquity"];
      this.homeEquityPurchase = _data["homeEquityPurchase"];
      this.borrowAdditionalCash = _data["borrowAdditionalCash"];
      this.howLongPlan = _data["howLongPlan"];
      this.militarySevice = _data["militarySevice"];
      this.rateCredit = _data["rateCredit"];
      this.workingWithLoanOfficer = _data["workingWithLoanOfficer"];
      this.officerName = _data["officerName"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.emailAddress = _data["emailAddress"];
      this.phoneNumber = _data["phoneNumber"];
    }
  }

  static fromJS(data: any): RefinanceLoanOption {
    data = typeof data === "object" ? data : {};
    let result = new RefinanceLoanOption();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["important_to_you"] = this.important_to_you;
    data["propertyUse"] = this.propertyUse;
    data["propertyType"] = this.propertyType;
    data["zipCode"] = this.zipCode;
    data["estimatePrice"] = this.estimatePrice;
    data["remainingBalalnce"] = this.remainingBalalnce;
    data[
      "haveAnyOtherLoanForThisProperty"
    ] = this.haveAnyOtherLoanForThisProperty;
    data["loanHomeEquity"] = this.loanHomeEquity;
    data["payThatOff"] = this.payThatOff;
    data["balanceOfHomeEquity"] = this.balanceOfHomeEquity;
    data["homeEquityPurchase"] = this.homeEquityPurchase;
    data["borrowAdditionalCash"] = this.borrowAdditionalCash;
    data["howLongPlan"] = this.howLongPlan;
    data["militarySevice"] = this.militarySevice;
    data["rateCredit"] = this.rateCredit;
    data["workingWithLoanOfficer"] = this.workingWithLoanOfficer;
    data["officerName"] = this.officerName;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["emailAddress"] = this.emailAddress;
    data["phoneNumber"] = this.phoneNumber;
    return data;
  }

  clone(): RefinanceLoanOption {
    const json = this.toJSON();
    let result = new RefinanceLoanOption();
    result.init(json);
    return result;
  }
}

export interface IRefinanceLoanOption {
  id: number | undefined;
  important_to_you: string | undefined;
  propertyUse: string | undefined;
  propertyType: string | undefined;
  zipCode: string | undefined;
  estimatePrice: number;
  remainingBalalnce: number;
  haveAnyOtherLoanForThisProperty: boolean;
  loanHomeEquity: boolean;
  payThatOff: boolean;
  balanceOfHomeEquity: number;
  homeEquityPurchase: boolean;
  borrowAdditionalCash: number;
  howLongPlan: string | undefined;
  militarySevice: boolean;
  rateCredit: string | undefined;
  workingWithLoanOfficer: boolean;
  officerName: string | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;
}

export class RegisterInput implements IRegisterInput {
  name: string;
  surname: string;
  userName: string;
  emailAddress: string;
  password: string;
  captchaResponse: string | undefined;

  constructor(data?: IRegisterInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.userName = _data["userName"];
      this.emailAddress = _data["emailAddress"];
      this.password = _data["password"];
      this.captchaResponse = _data["captchaResponse"];
    }
  }

  static fromJS(data: any): RegisterInput {
    data = typeof data === "object" ? data : {};
    let result = new RegisterInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["userName"] = this.userName;
    data["emailAddress"] = this.emailAddress;
    data["password"] = this.password;
    data["captchaResponse"] = this.captchaResponse;
    return data;
  }

  clone(): RegisterInput {
    const json = this.toJSON();
    let result = new RegisterInput();
    result.init(json);
    return result;
  }
}

export interface IRegisterInput {
  name: string;
  surname: string;
  userName: string;
  emailAddress: string;
  password: string;
  captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
  canLogin: boolean;

  constructor(data?: IRegisterOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.canLogin = _data["canLogin"];
    }
  }

  static fromJS(data: any): RegisterOutput {
    data = typeof data === "object" ? data : {};
    let result = new RegisterOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["canLogin"] = this.canLogin;
    return data;
  }

  clone(): RegisterOutput {
    const json = this.toJSON();
    let result = new RegisterOutput();
    result.init(json);
    return result;
  }
}

export interface IRegisterOutput {
  canLogin: boolean;
}

export class ResetPasswordDto implements IResetPasswordDto {
  adminPassword: string;
  userId: number;
  newPassword: string;

  constructor(data?: IResetPasswordDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.adminPassword = _data["adminPassword"];
      this.userId = _data["userId"];
      this.newPassword = _data["newPassword"];
    }
  }

  static fromJS(data: any): ResetPasswordDto {
    data = typeof data === "object" ? data : {};
    let result = new ResetPasswordDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["adminPassword"] = this.adminPassword;
    data["userId"] = this.userId;
    data["newPassword"] = this.newPassword;
    return data;
  }

  clone(): ResetPasswordDto {
    const json = this.toJSON();
    let result = new ResetPasswordDto();
    result.init(json);
    return result;
  }
}

export interface IResetPasswordDto {
  adminPassword: string;
  userId: number;
  newPassword: string;
}

export class RoleDto implements IRoleDto {
  id: number;
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;

  constructor(data?: IRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.normalizedName = _data["normalizedName"];
      this.description = _data["description"];
      if (Array.isArray(_data["grantedPermissions"])) {
        this.grantedPermissions = [] as any;
        for (let item of _data["grantedPermissions"])
          this.grantedPermissions.push(item);
      }
    }
  }

  static fromJS(data: any): RoleDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["normalizedName"] = this.normalizedName;
    data["description"] = this.description;
    if (Array.isArray(this.grantedPermissions)) {
      data["grantedPermissions"] = [];
      for (let item of this.grantedPermissions)
        data["grantedPermissions"].push(item);
    }
    return data;
  }

  clone(): RoleDto {
    const json = this.toJSON();
    let result = new RoleDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDto {
  id: number;
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
  items: RoleDto[] | undefined;

  constructor(data?: IRoleDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(RoleDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): RoleDtoListResultDto {
    const json = this.toJSON();
    let result = new RoleDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDtoListResultDto {
  items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
  items: RoleDto[] | undefined;
  totalCount: number;

  constructor(data?: IRoleDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(RoleDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): RoleDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): RoleDtoPagedResultDto {
    const json = this.toJSON();
    let result = new RoleDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDtoPagedResultDto {
  items: RoleDto[] | undefined;
  totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
  id: number;
  name: string;
  displayName: string;
  description: string | undefined;
  isStatic: boolean;

  constructor(data?: IRoleEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.description = _data["description"];
      this.isStatic = _data["isStatic"];
    }
  }

  static fromJS(data: any): RoleEditDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    data["isStatic"] = this.isStatic;
    return data;
  }

  clone(): RoleEditDto {
    const json = this.toJSON();
    let result = new RoleEditDto();
    result.init(json);
    return result;
  }
}

export interface IRoleEditDto {
  id: number;
  name: string;
  displayName: string;
  description: string | undefined;
  isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  isStatic: boolean;
  isDefault: boolean;
  creationTime: moment.Moment;

  constructor(data?: IRoleListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.isStatic = _data["isStatic"];
      this.isDefault = _data["isDefault"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): RoleListDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["isStatic"] = this.isStatic;
    data["isDefault"] = this.isDefault;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): RoleListDto {
    const json = this.toJSON();
    let result = new RoleListDto();
    result.init(json);
    return result;
  }
}

export interface IRoleListDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  isStatic: boolean;
  isDefault: boolean;
  creationTime: moment.Moment;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
  items: RoleListDto[] | undefined;

  constructor(data?: IRoleListDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(RoleListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleListDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleListDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): RoleListDtoListResultDto {
    const json = this.toJSON();
    let result = new RoleListDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleListDtoListResultDto {
  items: RoleListDto[] | undefined;
}

export class SiteSettingDto implements ISiteSettingDto {
  id: number;
  pageIdentifier: string | undefined;
  pageName: string | undefined;
  pageSetting: string | undefined;

  constructor(data?: ISiteSettingDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.pageIdentifier = _data["pageIdentifier"];
      this.pageName = _data["pageName"];
      this.pageSetting = _data["pageSetting"];
    }
  }

  static fromJS(data: any): SiteSettingDto {
    data = typeof data === "object" ? data : {};
    let result = new SiteSettingDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["pageIdentifier"] = this.pageIdentifier;
    data["pageName"] = this.pageName;
    data["pageSetting"] = this.pageSetting;
    return data;
  }

  clone(): SiteSettingDto {
    const json = this.toJSON();
    let result = new SiteSettingDto();
    result.init(json);
    return result;
  }
}

export interface ISiteSettingDto {
  id: number;
  pageIdentifier: string | undefined;
  pageName: string | undefined;
  pageSetting: string | undefined;
}

export class SiteSettingDtoPagedResultDto
  implements ISiteSettingDtoPagedResultDto {
  items: SiteSettingDto[] | undefined;
  totalCount: number;

  constructor(data?: ISiteSettingDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(SiteSettingDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): SiteSettingDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new SiteSettingDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): SiteSettingDtoPagedResultDto {
    const json = this.toJSON();
    let result = new SiteSettingDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ISiteSettingDtoPagedResultDto {
  items: SiteSettingDto[] | undefined;
  totalCount: number;
}

export class State implements IState {
  id: number;
  name: string | undefined;
  manualAssetEntries: ManualAssetEntry[] | undefined;

  constructor(data?: IState) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      if (Array.isArray(_data["manualAssetEntries"])) {
        this.manualAssetEntries = [] as any;
        for (let item of _data["manualAssetEntries"])
          this.manualAssetEntries.push(ManualAssetEntry.fromJS(item));
      }
    }
  }

  static fromJS(data: any): State {
    data = typeof data === "object" ? data : {};
    let result = new State();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    if (Array.isArray(this.manualAssetEntries)) {
      data["manualAssetEntries"] = [];
      for (let item of this.manualAssetEntries)
        data["manualAssetEntries"].push(item.toJSON());
    }
    return data;
  }

  clone(): State {
    const json = this.toJSON();
    let result = new State();
    result.init(json);
    return result;
  }
}

export interface IState {
  id: number;
  name: string | undefined;
  manualAssetEntries: ManualAssetEntry[] | undefined;
}

export class StockAndBond implements IStockAndBond {
  id: number;
  companyName: string | undefined;
  accountNumber: string | undefined;
  value: number | undefined;
  manualAssetEntryId: number;
  manualAssetEntry: ManualAssetEntry;

  constructor(data?: IStockAndBond) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.companyName = _data["companyName"];
      this.accountNumber = _data["accountNumber"];
      this.value = _data["value"];
      this.manualAssetEntryId = _data["manualAssetEntryId"];
      this.manualAssetEntry = _data["manualAssetEntry"]
        ? ManualAssetEntry.fromJS(_data["manualAssetEntry"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): StockAndBond {
    data = typeof data === "object" ? data : {};
    let result = new StockAndBond();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["companyName"] = this.companyName;
    data["accountNumber"] = this.accountNumber;
    data["value"] = this.value;
    data["manualAssetEntryId"] = this.manualAssetEntryId;
    data["manualAssetEntry"] = this.manualAssetEntry
      ? this.manualAssetEntry.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): StockAndBond {
    const json = this.toJSON();
    let result = new StockAndBond();
    result.init(json);
    return result;
  }
}

export interface IStockAndBond {
  id: number;
  companyName: string | undefined;
  accountNumber: string | undefined;
  value: number | undefined;
  manualAssetEntryId: number;
  manualAssetEntry: ManualAssetEntry;
}

export class StockAndBondViewModel implements IStockAndBondViewModel {
  id: number | undefined;
  companyName: string | undefined;
  accountNumber: string | undefined;
  value: number | undefined;
  manualAssetEntryId: number;

  constructor(data?: IStockAndBondViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.companyName = _data["companyName"];
      this.accountNumber = _data["accountNumber"];
      this.value = _data["value"];
      this.manualAssetEntryId = _data["manualAssetEntryId"];
    }
  }

  static fromJS(data: any): StockAndBondViewModel {
    data = typeof data === "object" ? data : {};
    let result = new StockAndBondViewModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["companyName"] = this.companyName;
    data["accountNumber"] = this.accountNumber;
    data["value"] = this.value;
    data["manualAssetEntryId"] = this.manualAssetEntryId;
    return data;
  }

  clone(): StockAndBondViewModel {
    const json = this.toJSON();
    let result = new StockAndBondViewModel();
    result.init(json);
    return result;
  }
}

export interface IStockAndBondViewModel {
  id: number | undefined;
  companyName: string | undefined;
  accountNumber: string | undefined;
  value: number | undefined;
  manualAssetEntryId: number;
}

export enum TenantAvailabilityState {
  _1 = 1,
  _2 = 2,
  _3 = 3,
}

export class TenantDto implements ITenantDto {
  id: number;
  tenancyName: string;
  name: string;
  isActive: boolean;

  constructor(data?: ITenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.tenancyName = _data["tenancyName"];
      this.name = _data["name"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): TenantDto {
    data = typeof data === "object" ? data : {};
    let result = new TenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    data["isActive"] = this.isActive;
    return data;
  }

  clone(): TenantDto {
    const json = this.toJSON();
    let result = new TenantDto();
    result.init(json);
    return result;
  }
}

export interface ITenantDto {
  id: number;
  tenancyName: string;
  name: string;
  isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
  items: TenantDto[] | undefined;
  totalCount: number;

  constructor(data?: ITenantDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(TenantDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): TenantDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new TenantDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): TenantDtoPagedResultDto {
    const json = this.toJSON();
    let result = new TenantDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ITenantDtoPagedResultDto {
  items: TenantDto[] | undefined;
  totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
  id: number;
  tenancyName: string | undefined;
  name: string | undefined;

  constructor(data?: ITenantLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.tenancyName = _data["tenancyName"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): TenantLoginInfoDto {
    data = typeof data === "object" ? data : {};
    let result = new TenantLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    return data;
  }

  clone(): TenantLoginInfoDto {
    const json = this.toJSON();
    let result = new TenantLoginInfoDto();
    result.init(json);
    return result;
  }
}

export interface ITenantLoginInfoDto {
  id: number;
  tenancyName: string | undefined;
  name: string | undefined;
}

export class UpdateAccountTypeRequest implements IUpdateAccountTypeRequest {
  financialAccountType1: string | undefined;
  id: number;

  constructor(data?: IUpdateAccountTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialAccountType1 = _data["financialAccountType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAccountTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAccountTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialAccountType1"] = this.financialAccountType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAccountTypeRequest {
    const json = this.toJSON();
    let result = new UpdateAccountTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateAccountTypeRequest {
  financialAccountType1: string | undefined;
  id: number;
}

export class UpdateAdditionalEmployementIncomeDetailRequest
  implements IUpdateAdditionalEmployementIncomeDetailRequest {
  applicationAdditionalEmployementDetails: number;
  incomeTypeId: number;
  amount: number | undefined;
  id: number;

  constructor(data?: IUpdateAdditionalEmployementIncomeDetailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationAdditionalEmployementDetails =
        _data["applicationAdditionalEmployementDetails"];
      this.incomeTypeId = _data["incomeTypeId"];
      this.amount = _data["amount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdditionalEmployementIncomeDetailRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdditionalEmployementIncomeDetailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationAdditionalEmployementDetails"
    ] = this.applicationAdditionalEmployementDetails;
    data["incomeTypeId"] = this.incomeTypeId;
    data["amount"] = this.amount;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdditionalEmployementIncomeDetailRequest {
    const json = this.toJSON();
    let result = new UpdateAdditionalEmployementIncomeDetailRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdditionalEmployementIncomeDetailRequest {
  applicationAdditionalEmployementDetails: number;
  incomeTypeId: number;
  amount: number | undefined;
  id: number;
}

export class UpdateAdditionalEmploymentDetailRequest
  implements IUpdateAdditionalEmploymentDetailRequest {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName: string | undefined;
  phone: string | undefined;
  street: string | undefined;
  unit: string | undefined;
  zip: string | undefined;
  countryId: number;
  stateId: number;
  cityId: number;
  positionTitle: string | undefined;
  startDate: moment.Moment | undefined;
  workingYears: number | undefined;
  workingMonths: number | undefined;
  isEmployedBySomeone: number | undefined;
  isSelfEmployed: number | undefined;
  isOwnershipLessThan25: number | undefined;
  monthlyIncome: number | undefined;
  id: number;

  constructor(data?: IUpdateAdditionalEmploymentDetailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.employerBusinessName = _data["employerBusinessName"];
      this.phone = _data["phone"];
      this.street = _data["street"];
      this.unit = _data["unit"];
      this.zip = _data["zip"];
      this.countryId = _data["countryId"];
      this.stateId = _data["stateId"];
      this.cityId = _data["cityId"];
      this.positionTitle = _data["positionTitle"];
      this.startDate = _data["startDate"]
        ? moment(_data["startDate"].toString())
        : <any>undefined;
      this.workingYears = _data["workingYears"];
      this.workingMonths = _data["workingMonths"];
      this.isEmployedBySomeone = _data["isEmployedBySomeone"];
      this.isSelfEmployed = _data["isSelfEmployed"];
      this.isOwnershipLessThan25 = _data["isOwnershipLessThan25"];
      this.monthlyIncome = _data["monthlyIncome"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdditionalEmploymentDetailRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdditionalEmploymentDetailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["employerBusinessName"] = this.employerBusinessName;
    data["phone"] = this.phone;
    data["street"] = this.street;
    data["unit"] = this.unit;
    data["zip"] = this.zip;
    data["countryId"] = this.countryId;
    data["stateId"] = this.stateId;
    data["cityId"] = this.cityId;
    data["positionTitle"] = this.positionTitle;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["workingYears"] = this.workingYears;
    data["workingMonths"] = this.workingMonths;
    data["isEmployedBySomeone"] = this.isEmployedBySomeone;
    data["isSelfEmployed"] = this.isSelfEmployed;
    data["isOwnershipLessThan25"] = this.isOwnershipLessThan25;
    data["monthlyIncome"] = this.monthlyIncome;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdditionalEmploymentDetailRequest {
    const json = this.toJSON();
    let result = new UpdateAdditionalEmploymentDetailRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdditionalEmploymentDetailRequest {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName: string | undefined;
  phone: string | undefined;
  street: string | undefined;
  unit: string | undefined;
  zip: string | undefined;
  countryId: number;
  stateId: number;
  cityId: number;
  positionTitle: string | undefined;
  startDate: moment.Moment | undefined;
  workingYears: number | undefined;
  workingMonths: number | undefined;
  isEmployedBySomeone: number | undefined;
  isSelfEmployed: number | undefined;
  isOwnershipLessThan25: number | undefined;
  monthlyIncome: number | undefined;
  id: number;
}

export class UpdateAdminDisclosure implements IUpdateAdminDisclosure {
  title: string | undefined;
  id: number;

  constructor(data?: IUpdateAdminDisclosure) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["title"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminDisclosure {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminDisclosure();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["title"] = this.title;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminDisclosure {
    const json = this.toJSON();
    let result = new UpdateAdminDisclosure();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminDisclosure {
  title: string | undefined;
  id: number;
}

export class UpdateAdminLoanApplicationDocument
  implements IUpdateAdminLoanApplicationDocument {
  loanId: number;
  disclosureId: number;
  userId: number;
  updatedOn: moment.Moment | undefined;
  documentPath: string | undefined;
  id: number;

  constructor(data?: IUpdateAdminLoanApplicationDocument) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanId = _data["loanId"];
      this.disclosureId = _data["disclosureId"];
      this.userId = _data["userId"];
      this.updatedOn = _data["updatedOn"]
        ? moment(_data["updatedOn"].toString())
        : <any>undefined;
      this.documentPath = _data["documentPath"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminLoanApplicationDocument {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminLoanApplicationDocument();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanId"] = this.loanId;
    data["disclosureId"] = this.disclosureId;
    data["userId"] = this.userId;
    data["updatedOn"] = this.updatedOn
      ? this.updatedOn.toISOString()
      : <any>undefined;
    data["documentPath"] = this.documentPath;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminLoanApplicationDocument {
    const json = this.toJSON();
    let result = new UpdateAdminLoanApplicationDocument();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminLoanApplicationDocument {
  loanId: number;
  disclosureId: number;
  userId: number;
  updatedOn: moment.Moment | undefined;
  documentPath: string | undefined;
  id: number;
}

export class UpdateAdminLoanDetail implements IUpdateAdminLoanDetail {
  userId: number;
  loanApplicationId: number;
  loanNo: string | undefined;
  mortageConsultant: string | undefined;
  nmlsId: string | undefined;
  borrowerName: string | undefined;
  propertyAddress: string | undefined;
  loanProgramId: number;
  loanAmount: number | undefined;
  loanPurpose: string | undefined;
  interestRate: number | undefined;
  applicationDate: moment.Moment | undefined;
  rateLockDate: moment.Moment | undefined;
  rateLockExpirationDate: moment.Moment | undefined;
  id: number;

  constructor(data?: IUpdateAdminLoanDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data["userId"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.loanNo = _data["loanNo"];
      this.mortageConsultant = _data["mortageConsultant"];
      this.nmlsId = _data["nmlsId"];
      this.borrowerName = _data["borrowerName"];
      this.propertyAddress = _data["propertyAddress"];
      this.loanProgramId = _data["loanProgramId"];
      this.loanAmount = _data["loanAmount"];
      this.loanPurpose = _data["loanPurpose"];
      this.interestRate = _data["interestRate"];
      this.applicationDate = _data["applicationDate"]
        ? moment(_data["applicationDate"].toString())
        : <any>undefined;
      this.rateLockDate = _data["rateLockDate"]
        ? moment(_data["rateLockDate"].toString())
        : <any>undefined;
      this.rateLockExpirationDate = _data["rateLockExpirationDate"]
        ? moment(_data["rateLockExpirationDate"].toString())
        : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminLoanDetail {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminLoanDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userId"] = this.userId;
    data["loanApplicationId"] = this.loanApplicationId;
    data["loanNo"] = this.loanNo;
    data["mortageConsultant"] = this.mortageConsultant;
    data["nmlsId"] = this.nmlsId;
    data["borrowerName"] = this.borrowerName;
    data["propertyAddress"] = this.propertyAddress;
    data["loanProgramId"] = this.loanProgramId;
    data["loanAmount"] = this.loanAmount;
    data["loanPurpose"] = this.loanPurpose;
    data["interestRate"] = this.interestRate;
    data["applicationDate"] = this.applicationDate
      ? this.applicationDate.toISOString()
      : <any>undefined;
    data["rateLockDate"] = this.rateLockDate
      ? this.rateLockDate.toISOString()
      : <any>undefined;
    data["rateLockExpirationDate"] = this.rateLockExpirationDate
      ? this.rateLockExpirationDate.toISOString()
      : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminLoanDetail {
    const json = this.toJSON();
    let result = new UpdateAdminLoanDetail();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminLoanDetail {
  userId: number;
  loanApplicationId: number;
  loanNo: string | undefined;
  mortageConsultant: string | undefined;
  nmlsId: string | undefined;
  borrowerName: string | undefined;
  propertyAddress: string | undefined;
  loanProgramId: number;
  loanAmount: number | undefined;
  loanPurpose: string | undefined;
  interestRate: number | undefined;
  applicationDate: moment.Moment | undefined;
  rateLockDate: moment.Moment | undefined;
  rateLockExpirationDate: moment.Moment | undefined;
  id: number;
}

export class UpdateAdminLoanProgram implements IUpdateAdminLoanProgram {
  loanProgram: string | undefined;
  id: number;

  constructor(data?: IUpdateAdminLoanProgram) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanProgram = _data["loanProgram"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminLoanProgram {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminLoanProgram();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanProgram"] = this.loanProgram;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminLoanProgram {
    const json = this.toJSON();
    let result = new UpdateAdminLoanProgram();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminLoanProgram {
  loanProgram: string | undefined;
  id: number;
}

export class UpdateAdminLoanStatus implements IUpdateAdminLoanStatus {
  status: string | undefined;
  id: number;

  constructor(data?: IUpdateAdminLoanStatus) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.status = _data["status"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminLoanStatus {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminLoanStatus();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["status"] = this.status;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminLoanStatus {
    const json = this.toJSON();
    let result = new UpdateAdminLoanStatus();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminLoanStatus {
  status: string | undefined;
  id: number;
}

export class UpdateAdminLoanSummaryStatus
  implements IUpdateAdminLoanSummaryStatus {
  loanId: number;
  statusId: number;
  updatedOn: moment.Moment | undefined;
  id: number;

  constructor(data?: IUpdateAdminLoanSummaryStatus) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanId = _data["loanId"];
      this.statusId = _data["statusId"];
      this.updatedOn = _data["updatedOn"]
        ? moment(_data["updatedOn"].toString())
        : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminLoanSummaryStatus {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminLoanSummaryStatus();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanId"] = this.loanId;
    data["statusId"] = this.statusId;
    data["updatedOn"] = this.updatedOn
      ? this.updatedOn.toISOString()
      : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminLoanSummaryStatus {
    const json = this.toJSON();
    let result = new UpdateAdminLoanSummaryStatus();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminLoanSummaryStatus {
  loanId: number;
  statusId: number;
  updatedOn: moment.Moment | undefined;
  id: number;
}

export class UpdateAdminNotificationType
  implements IUpdateAdminNotificationType {
  type: string | undefined;
  id: number;

  constructor(data?: IUpdateAdminNotificationType) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminNotificationType {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminNotificationType();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["type"] = this.type;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminNotificationType {
    const json = this.toJSON();
    let result = new UpdateAdminNotificationType();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminNotificationType {
  type: string | undefined;
  id: number;
}

export class UpdateAdminUser implements IUpdateAdminUser {
  userName: string | undefined;
  email: string | undefined;
  password: string | undefined;
  isActive: number | undefined;
  createdOn: moment.Moment | undefined;
  id: number;

  constructor(data?: IUpdateAdminUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data["userName"];
      this.email = _data["email"];
      this.password = _data["password"];
      this.isActive = _data["isActive"];
      this.createdOn = _data["createdOn"]
        ? moment(_data["createdOn"].toString())
        : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminUser {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminUser();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userName"] = this.userName;
    data["email"] = this.email;
    data["password"] = this.password;
    data["isActive"] = this.isActive;
    data["createdOn"] = this.createdOn
      ? this.createdOn.toISOString()
      : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminUser {
    const json = this.toJSON();
    let result = new UpdateAdminUser();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminUser {
  userName: string | undefined;
  email: string | undefined;
  password: string | undefined;
  isActive: number | undefined;
  createdOn: moment.Moment | undefined;
  id: number;
}

export class UpdateAdminUserEnabledDevice
  implements IUpdateAdminUserEnabledDevice {
  userId: number;
  deviceId: string | undefined;
  bioMetricData: string | undefined;
  isEnabled: number | undefined;
  id: number;

  constructor(data?: IUpdateAdminUserEnabledDevice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data["userId"];
      this.deviceId = _data["deviceId"];
      this.bioMetricData = _data["bioMetricData"];
      this.isEnabled = _data["isEnabled"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminUserEnabledDevice {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminUserEnabledDevice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userId"] = this.userId;
    data["deviceId"] = this.deviceId;
    data["bioMetricData"] = this.bioMetricData;
    data["isEnabled"] = this.isEnabled;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminUserEnabledDevice {
    const json = this.toJSON();
    let result = new UpdateAdminUserEnabledDevice();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminUserEnabledDevice {
  userId: number;
  deviceId: string | undefined;
  bioMetricData: string | undefined;
  isEnabled: number | undefined;
  id: number;
}

export class UpdateAdminUserNotification
  implements IUpdateAdminUserNotification {
  userId: number;
  notificationTypeId: number;
  date: moment.Moment | undefined;
  subject: string | undefined;
  content: string | undefined;
  isSeen: number | undefined;
  id: number;

  constructor(data?: IUpdateAdminUserNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data["userId"];
      this.notificationTypeId = _data["notificationTypeId"];
      this.date = _data["date"]
        ? moment(_data["date"].toString())
        : <any>undefined;
      this.subject = _data["subject"];
      this.content = _data["content"];
      this.isSeen = _data["isSeen"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminUserNotification {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminUserNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userId"] = this.userId;
    data["notificationTypeId"] = this.notificationTypeId;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["subject"] = this.subject;
    data["content"] = this.content;
    data["isSeen"] = this.isSeen;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminUserNotification {
    const json = this.toJSON();
    let result = new UpdateAdminUserNotification();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminUserNotification {
  userId: number;
  notificationTypeId: number;
  date: moment.Moment | undefined;
  subject: string | undefined;
  content: string | undefined;
  isSeen: number | undefined;
  id: number;
}

export class UpdateApplicationDeclarationQuestionRequest
  implements IUpdateApplicationDeclarationQuestionRequest {
  applicationPersonalInformationId: number | undefined;
  declarationQuestionId: number | undefined;
  yesNo: number | undefined;
  description5a: string | undefined;
  id: number;

  constructor(data?: IUpdateApplicationDeclarationQuestionRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.declarationQuestionId = _data["declarationQuestionId"];
      this.yesNo = _data["yesNo"];
      this.description5a = _data["description5a"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateApplicationDeclarationQuestionRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateApplicationDeclarationQuestionRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["declarationQuestionId"] = this.declarationQuestionId;
    data["yesNo"] = this.yesNo;
    data["description5a"] = this.description5a;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateApplicationDeclarationQuestionRequest {
    const json = this.toJSON();
    let result = new UpdateApplicationDeclarationQuestionRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateApplicationDeclarationQuestionRequest {
  applicationPersonalInformationId: number | undefined;
  declarationQuestionId: number | undefined;
  yesNo: number | undefined;
  description5a: string | undefined;
  id: number;
}

export class UpdateApplicationFinancialAssetRequest
  implements IUpdateApplicationFinancialAssetRequest {
  applicationPersonalInformationId: number | undefined;
  financialAccountTypeId2a1: number;
  financialInstitution2a2: string | undefined;
  accountNumber2a3: string | undefined;
  value2a4: number | undefined;
  id: number;

  constructor(data?: IUpdateApplicationFinancialAssetRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.financialAccountTypeId2a1 = _data["financialAccountTypeId2a1"];
      this.financialInstitution2a2 = _data["financialInstitution2a2"];
      this.accountNumber2a3 = _data["accountNumber2a3"];
      this.value2a4 = _data["value2a4"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateApplicationFinancialAssetRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateApplicationFinancialAssetRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["financialAccountTypeId2a1"] = this.financialAccountTypeId2a1;
    data["financialInstitution2a2"] = this.financialInstitution2a2;
    data["accountNumber2a3"] = this.accountNumber2a3;
    data["value2a4"] = this.value2a4;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateApplicationFinancialAssetRequest {
    const json = this.toJSON();
    let result = new UpdateApplicationFinancialAssetRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateApplicationFinancialAssetRequest {
  applicationPersonalInformationId: number | undefined;
  financialAccountTypeId2a1: number;
  financialInstitution2a2: string | undefined;
  accountNumber2a3: string | undefined;
  value2a4: number | undefined;
  id: number;
}

export class UpdateApplicationFinancialLiabilityRequest
  implements IUpdateApplicationFinancialLiabilityRequest {
  applicationPersonalInformationId: number | undefined;
  financialLaibilitiesType2c1: number;
  companyName2c2: string | undefined;
  accountNumber2c3: string | undefined;
  unpaidBalance2c4: number | undefined;
  paidOff2c5: number | undefined;
  monthlyValue2c6: number | undefined;
  id: number;

  constructor(data?: IUpdateApplicationFinancialLiabilityRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.financialLaibilitiesType2c1 = _data["financialLaibilitiesType2c1"];
      this.companyName2c2 = _data["companyName2c2"];
      this.accountNumber2c3 = _data["accountNumber2c3"];
      this.unpaidBalance2c4 = _data["unpaidBalance2c4"];
      this.paidOff2c5 = _data["paidOff2c5"];
      this.monthlyValue2c6 = _data["monthlyValue2c6"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateApplicationFinancialLiabilityRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateApplicationFinancialLiabilityRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["financialLaibilitiesType2c1"] = this.financialLaibilitiesType2c1;
    data["companyName2c2"] = this.companyName2c2;
    data["accountNumber2c3"] = this.accountNumber2c3;
    data["unpaidBalance2c4"] = this.unpaidBalance2c4;
    data["paidOff2c5"] = this.paidOff2c5;
    data["monthlyValue2c6"] = this.monthlyValue2c6;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateApplicationFinancialLiabilityRequest {
    const json = this.toJSON();
    let result = new UpdateApplicationFinancialLiabilityRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateApplicationFinancialLiabilityRequest {
  applicationPersonalInformationId: number | undefined;
  financialLaibilitiesType2c1: number;
  companyName2c2: string | undefined;
  accountNumber2c3: string | undefined;
  unpaidBalance2c4: number | undefined;
  paidOff2c5: number | undefined;
  monthlyValue2c6: number | undefined;
  id: number;
}

export class UpdateApplicationFinancialOtherAssetRequest
  implements IUpdateApplicationFinancialOtherAssetRequest {
  applicationPersonalInformationId: number | undefined;
  financialAssetsTypesId2b1: number;
  value2b2: number | undefined;
  id: number;

  constructor(data?: IUpdateApplicationFinancialOtherAssetRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.financialAssetsTypesId2b1 = _data["financialAssetsTypesId2b1"];
      this.value2b2 = _data["value2b2"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateApplicationFinancialOtherAssetRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateApplicationFinancialOtherAssetRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["financialAssetsTypesId2b1"] = this.financialAssetsTypesId2b1;
    data["value2b2"] = this.value2b2;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateApplicationFinancialOtherAssetRequest {
    const json = this.toJSON();
    let result = new UpdateApplicationFinancialOtherAssetRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateApplicationFinancialOtherAssetRequest {
  applicationPersonalInformationId: number | undefined;
  financialAssetsTypesId2b1: number;
  value2b2: number | undefined;
  id: number;
}

export class UpdateApplicationFinancialOtherLaibilityRequest
  implements IUpdateApplicationFinancialOtherLaibilityRequest {
  applicationPersonalInformationId: number | undefined;
  financialOtherLaibilitiesTypeId2d1: number;
  monthlyPayment2d2: number | undefined;
  id: number;

  constructor(data?: IUpdateApplicationFinancialOtherLaibilityRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.financialOtherLaibilitiesTypeId2d1 =
        _data["financialOtherLaibilitiesTypeId2d1"];
      this.monthlyPayment2d2 = _data["monthlyPayment2d2"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateApplicationFinancialOtherLaibilityRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateApplicationFinancialOtherLaibilityRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data[
      "financialOtherLaibilitiesTypeId2d1"
    ] = this.financialOtherLaibilitiesTypeId2d1;
    data["monthlyPayment2d2"] = this.monthlyPayment2d2;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateApplicationFinancialOtherLaibilityRequest {
    const json = this.toJSON();
    let result = new UpdateApplicationFinancialOtherLaibilityRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateApplicationFinancialOtherLaibilityRequest {
  applicationPersonalInformationId: number | undefined;
  financialOtherLaibilitiesTypeId2d1: number;
  monthlyPayment2d2: number | undefined;
  id: number;
}

export class UpdateApplicationIncomeSourceRequest
  implements IUpdateApplicationIncomeSourceRequest {
  applicationPersonalInformationId: number | undefined;
  incomeSourceId1e1: number;
  amount1e2: number | undefined;
  id: number;

  constructor(data?: IUpdateApplicationIncomeSourceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.incomeSourceId1e1 = _data["incomeSourceId1e1"];
      this.amount1e2 = _data["amount1e2"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateApplicationIncomeSourceRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateApplicationIncomeSourceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["incomeSourceId1e1"] = this.incomeSourceId1e1;
    data["amount1e2"] = this.amount1e2;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateApplicationIncomeSourceRequest {
    const json = this.toJSON();
    let result = new UpdateApplicationIncomeSourceRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateApplicationIncomeSourceRequest {
  applicationPersonalInformationId: number | undefined;
  incomeSourceId1e1: number;
  amount1e2: number | undefined;
  id: number;
}

export class UpdateApplicationRequest implements IUpdateApplicationRequest {
  date: moment.Moment;
  loanNoIdentifierB1B3: string | undefined;
  agencyCaseNoB2: string | undefined;
  creditTypeId: number;
  totalBorrowers1a6: number | undefined;
  initials: string | undefined;
  id: number;

  constructor(data?: IUpdateApplicationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data["date"]
        ? moment(_data["date"].toString())
        : <any>undefined;
      this.loanNoIdentifierB1B3 = _data["loanNoIdentifierB1B3"];
      this.agencyCaseNoB2 = _data["agencyCaseNoB2"];
      this.creditTypeId = _data["creditTypeId"];
      this.totalBorrowers1a6 = _data["totalBorrowers1a6"];
      this.initials = _data["initials"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateApplicationRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateApplicationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["loanNoIdentifierB1B3"] = this.loanNoIdentifierB1B3;
    data["agencyCaseNoB2"] = this.agencyCaseNoB2;
    data["creditTypeId"] = this.creditTypeId;
    data["totalBorrowers1a6"] = this.totalBorrowers1a6;
    data["initials"] = this.initials;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateApplicationRequest {
    const json = this.toJSON();
    let result = new UpdateApplicationRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateApplicationRequest {
  date: moment.Moment;
  loanNoIdentifierB1B3: string | undefined;
  agencyCaseNoB2: string | undefined;
  creditTypeId: number;
  totalBorrowers1a6: number | undefined;
  initials: string | undefined;
  id: number;
}

export class UpdateCitizenshipTypeRequest
  implements IUpdateCitizenshipTypeRequest {
  citizenshipType1: string | undefined;
  id: number;

  constructor(data?: IUpdateCitizenshipTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.citizenshipType1 = _data["citizenshipType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateCitizenshipTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateCitizenshipTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["citizenshipType1"] = this.citizenshipType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateCitizenshipTypeRequest {
    const json = this.toJSON();
    let result = new UpdateCitizenshipTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateCitizenshipTypeRequest {
  citizenshipType1: string | undefined;
  id: number;
}

export class UpdateCityRequest implements IUpdateCityRequest {
  stateId: number;
  cityName: string | undefined;
  id: number;

  constructor(data?: IUpdateCityRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.stateId = _data["stateId"];
      this.cityName = _data["cityName"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateCityRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateCityRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["stateId"] = this.stateId;
    data["cityName"] = this.cityName;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateCityRequest {
    const json = this.toJSON();
    let result = new UpdateCityRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateCityRequest {
  stateId: number;
  cityName: string | undefined;
  id: number;
}

export class UpdateCountryRequest implements IUpdateCountryRequest {
  countryName: string | undefined;
  id: number;

  constructor(data?: IUpdateCountryRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.countryName = _data["countryName"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateCountryRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateCountryRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["countryName"] = this.countryName;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateCountryRequest {
    const json = this.toJSON();
    let result = new UpdateCountryRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateCountryRequest {
  countryName: string | undefined;
  id: number;
}

export class UpdateCreditTypeRequest implements IUpdateCreditTypeRequest {
  creditType1: string | undefined;
  id: number;

  constructor(data?: IUpdateCreditTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.creditType1 = _data["creditType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateCreditTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateCreditTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["creditType1"] = this.creditType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateCreditTypeRequest {
    const json = this.toJSON();
    let result = new UpdateCreditTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateCreditTypeRequest {
  creditType1: string | undefined;
  id: number;
}

export class UpdateDeclarationCategoryRequest
  implements IUpdateDeclarationCategoryRequest {
  declarationCategory1: string | undefined;
  id: number;

  constructor(data?: IUpdateDeclarationCategoryRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationCategory1 = _data["declarationCategory1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateDeclarationCategoryRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateDeclarationCategoryRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationCategory1"] = this.declarationCategory1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateDeclarationCategoryRequest {
    const json = this.toJSON();
    let result = new UpdateDeclarationCategoryRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateDeclarationCategoryRequest {
  declarationCategory1: string | undefined;
  id: number;
}

export class UpdateDeclarationQuestionRequest
  implements IUpdateDeclarationQuestionRequest {
  declarationCategoryId: number | undefined;
  parentQuestionId: number | undefined;
  question: string | undefined;
  isActive: number | undefined;
  id: number;

  constructor(data?: IUpdateDeclarationQuestionRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationCategoryId = _data["declarationCategoryId"];
      this.parentQuestionId = _data["parentQuestionId"];
      this.question = _data["question"];
      this.isActive = _data["isActive"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateDeclarationQuestionRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateDeclarationQuestionRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationCategoryId"] = this.declarationCategoryId;
    data["parentQuestionId"] = this.parentQuestionId;
    data["question"] = this.question;
    data["isActive"] = this.isActive;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateDeclarationQuestionRequest {
    const json = this.toJSON();
    let result = new UpdateDeclarationQuestionRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateDeclarationQuestionRequest {
  declarationCategoryId: number | undefined;
  parentQuestionId: number | undefined;
  question: string | undefined;
  isActive: number | undefined;
  id: number;
}

export class UpdateDemographicInfoSourceRequest
  implements IUpdateDemographicInfoSourceRequest {
  value: string | undefined;
  id: number;

  constructor(data?: IUpdateDemographicInfoSourceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateDemographicInfoSourceRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateDemographicInfoSourceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateDemographicInfoSourceRequest {
    const json = this.toJSON();
    let result = new UpdateDemographicInfoSourceRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateDemographicInfoSourceRequest {
  value: string | undefined;
  id: number;
}

export class UpdateDemographicInformationRequest
  implements IUpdateDemographicInformationRequest {
  applicationPersonalInformationId: number | undefined;
  ethnicity81: string | undefined;
  gender82: string | undefined;
  race83: string | undefined;
  isEthnicityByObservation84: number | undefined;
  isGenderByObservation85: number | undefined;
  isRaceByObservation86: number | undefined;
  demographicInfoSourceId87: number | undefined;
  id: number;

  constructor(data?: IUpdateDemographicInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.ethnicity81 = _data["ethnicity81"];
      this.gender82 = _data["gender82"];
      this.race83 = _data["race83"];
      this.isEthnicityByObservation84 = _data["isEthnicityByObservation84"];
      this.isGenderByObservation85 = _data["isGenderByObservation85"];
      this.isRaceByObservation86 = _data["isRaceByObservation86"];
      this.demographicInfoSourceId87 = _data["demographicInfoSourceId87"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateDemographicInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateDemographicInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["ethnicity81"] = this.ethnicity81;
    data["gender82"] = this.gender82;
    data["race83"] = this.race83;
    data["isEthnicityByObservation84"] = this.isEthnicityByObservation84;
    data["isGenderByObservation85"] = this.isGenderByObservation85;
    data["isRaceByObservation86"] = this.isRaceByObservation86;
    data["demographicInfoSourceId87"] = this.demographicInfoSourceId87;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateDemographicInformationRequest {
    const json = this.toJSON();
    let result = new UpdateDemographicInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateDemographicInformationRequest {
  applicationPersonalInformationId: number | undefined;
  ethnicity81: string | undefined;
  gender82: string | undefined;
  race83: string | undefined;
  isEthnicityByObservation84: number | undefined;
  isGenderByObservation85: number | undefined;
  isRaceByObservation86: number | undefined;
  demographicInfoSourceId87: number | undefined;
  id: number;
}

export class UpdateEmployementIncomeDetailRequest
  implements IUpdateEmployementIncomeDetailRequest {
  applicationEmployementDetailsId: number;
  incomeTypeId1b101: number;
  amount1b10: number | undefined;
  id: number;

  constructor(data?: IUpdateEmployementIncomeDetailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationEmployementDetailsId =
        _data["applicationEmployementDetailsId"];
      this.incomeTypeId1b101 = _data["incomeTypeId1b101"];
      this.amount1b10 = _data["amount1b10"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateEmployementIncomeDetailRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateEmployementIncomeDetailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationEmployementDetailsId"
    ] = this.applicationEmployementDetailsId;
    data["incomeTypeId1b101"] = this.incomeTypeId1b101;
    data["amount1b10"] = this.amount1b10;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateEmployementIncomeDetailRequest {
    const json = this.toJSON();
    let result = new UpdateEmployementIncomeDetailRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateEmployementIncomeDetailRequest {
  applicationEmployementDetailsId: number;
  incomeTypeId1b101: number;
  amount1b10: number | undefined;
  id: number;
}

export class UpdateEmploymentDetailRequest
  implements IUpdateEmploymentDetailRequest {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName1b2: string | undefined;
  phone1b3: string | undefined;
  street1b41: string | undefined;
  unit1b42: string | undefined;
  zip1b45: string | undefined;
  countryId1b46: number;
  stateId1b44: number;
  cityId1b43: number;
  positionTitle1b5: string | undefined;
  startDate1b6: moment.Moment | undefined;
  workingYears1b7: number | undefined;
  workingMonths: number | undefined;
  isEmployedBySomeone1b8: number | undefined;
  isSelfEmployed1b9: number | undefined;
  isOwnershipLessThan251b91: number | undefined;
  monthlyIncome1b92: number | undefined;
  id: number;

  constructor(data?: IUpdateEmploymentDetailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.employerBusinessName1b2 = _data["employerBusinessName1b2"];
      this.phone1b3 = _data["phone1b3"];
      this.street1b41 = _data["street1b41"];
      this.unit1b42 = _data["unit1b42"];
      this.zip1b45 = _data["zip1b45"];
      this.countryId1b46 = _data["countryId1b46"];
      this.stateId1b44 = _data["stateId1b44"];
      this.cityId1b43 = _data["cityId1b43"];
      this.positionTitle1b5 = _data["positionTitle1b5"];
      this.startDate1b6 = _data["startDate1b6"]
        ? moment(_data["startDate1b6"].toString())
        : <any>undefined;
      this.workingYears1b7 = _data["workingYears1b7"];
      this.workingMonths = _data["workingMonths"];
      this.isEmployedBySomeone1b8 = _data["isEmployedBySomeone1b8"];
      this.isSelfEmployed1b9 = _data["isSelfEmployed1b9"];
      this.isOwnershipLessThan251b91 = _data["isOwnershipLessThan251b91"];
      this.monthlyIncome1b92 = _data["monthlyIncome1b92"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateEmploymentDetailRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateEmploymentDetailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["employerBusinessName1b2"] = this.employerBusinessName1b2;
    data["phone1b3"] = this.phone1b3;
    data["street1b41"] = this.street1b41;
    data["unit1b42"] = this.unit1b42;
    data["zip1b45"] = this.zip1b45;
    data["countryId1b46"] = this.countryId1b46;
    data["stateId1b44"] = this.stateId1b44;
    data["cityId1b43"] = this.cityId1b43;
    data["positionTitle1b5"] = this.positionTitle1b5;
    data["startDate1b6"] = this.startDate1b6
      ? this.startDate1b6.toISOString()
      : <any>undefined;
    data["workingYears1b7"] = this.workingYears1b7;
    data["workingMonths"] = this.workingMonths;
    data["isEmployedBySomeone1b8"] = this.isEmployedBySomeone1b8;
    data["isSelfEmployed1b9"] = this.isSelfEmployed1b9;
    data["isOwnershipLessThan251b91"] = this.isOwnershipLessThan251b91;
    data["monthlyIncome1b92"] = this.monthlyIncome1b92;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateEmploymentDetailRequest {
    const json = this.toJSON();
    let result = new UpdateEmploymentDetailRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateEmploymentDetailRequest {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName1b2: string | undefined;
  phone1b3: string | undefined;
  street1b41: string | undefined;
  unit1b42: string | undefined;
  zip1b45: string | undefined;
  countryId1b46: number;
  stateId1b44: number;
  cityId1b43: number;
  positionTitle1b5: string | undefined;
  startDate1b6: moment.Moment | undefined;
  workingYears1b7: number | undefined;
  workingMonths: number | undefined;
  isEmployedBySomeone1b8: number | undefined;
  isSelfEmployed1b9: number | undefined;
  isOwnershipLessThan251b91: number | undefined;
  monthlyIncome1b92: number | undefined;
  id: number;
}

export class UpdateFinancialRealEstateRequest
  implements IUpdateFinancialRealEstateRequest {
  applicationPersonalInformationId: number | undefined;
  street3a21: string | undefined;
  unitNo3a22: string | undefined;
  zip3a25: string | undefined;
  countryId3a26: number;
  stateId3a24: number;
  cityId3a23: number;
  propertyValue3a3: number | undefined;
  financialPropertyStatusId3a4: number;
  financialPropertyIntendedOccupancyId3a5: number;
  monthlyMortagePayment3a6: number | undefined;
  monthlyRentalIncome3a7: number | undefined;
  netMonthlyRentalIncome3a8: number | undefined;
  id: number;

  constructor(data?: IUpdateFinancialRealEstateRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.street3a21 = _data["street3a21"];
      this.unitNo3a22 = _data["unitNo3a22"];
      this.zip3a25 = _data["zip3a25"];
      this.countryId3a26 = _data["countryId3a26"];
      this.stateId3a24 = _data["stateId3a24"];
      this.cityId3a23 = _data["cityId3a23"];
      this.propertyValue3a3 = _data["propertyValue3a3"];
      this.financialPropertyStatusId3a4 = _data["financialPropertyStatusId3a4"];
      this.financialPropertyIntendedOccupancyId3a5 =
        _data["financialPropertyIntendedOccupancyId3a5"];
      this.monthlyMortagePayment3a6 = _data["monthlyMortagePayment3a6"];
      this.monthlyRentalIncome3a7 = _data["monthlyRentalIncome3a7"];
      this.netMonthlyRentalIncome3a8 = _data["netMonthlyRentalIncome3a8"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateFinancialRealEstateRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateFinancialRealEstateRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["street3a21"] = this.street3a21;
    data["unitNo3a22"] = this.unitNo3a22;
    data["zip3a25"] = this.zip3a25;
    data["countryId3a26"] = this.countryId3a26;
    data["stateId3a24"] = this.stateId3a24;
    data["cityId3a23"] = this.cityId3a23;
    data["propertyValue3a3"] = this.propertyValue3a3;
    data["financialPropertyStatusId3a4"] = this.financialPropertyStatusId3a4;
    data[
      "financialPropertyIntendedOccupancyId3a5"
    ] = this.financialPropertyIntendedOccupancyId3a5;
    data["monthlyMortagePayment3a6"] = this.monthlyMortagePayment3a6;
    data["monthlyRentalIncome3a7"] = this.monthlyRentalIncome3a7;
    data["netMonthlyRentalIncome3a8"] = this.netMonthlyRentalIncome3a8;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateFinancialRealEstateRequest {
    const json = this.toJSON();
    let result = new UpdateFinancialRealEstateRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateFinancialRealEstateRequest {
  applicationPersonalInformationId: number | undefined;
  street3a21: string | undefined;
  unitNo3a22: string | undefined;
  zip3a25: string | undefined;
  countryId3a26: number;
  stateId3a24: number;
  cityId3a23: number;
  propertyValue3a3: number | undefined;
  financialPropertyStatusId3a4: number;
  financialPropertyIntendedOccupancyId3a5: number;
  monthlyMortagePayment3a6: number | undefined;
  monthlyRentalIncome3a7: number | undefined;
  netMonthlyRentalIncome3a8: number | undefined;
  id: number;
}

export class UpdateHousingTypeRequest implements IUpdateHousingTypeRequest {
  housingType1: string | undefined;
  id: number;

  constructor(data?: IUpdateHousingTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.housingType1 = _data["housingType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateHousingTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateHousingTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["housingType1"] = this.housingType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateHousingTypeRequest {
    const json = this.toJSON();
    let result = new UpdateHousingTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateHousingTypeRequest {
  housingType1: string | undefined;
  id: number;
}

export class UpdateIncomeSourceRequest implements IUpdateIncomeSourceRequest {
  incomeSource1: string | undefined;
  id: number;

  constructor(data?: IUpdateIncomeSourceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.incomeSource1 = _data["incomeSource1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateIncomeSourceRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateIncomeSourceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["incomeSource1"] = this.incomeSource1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateIncomeSourceRequest {
    const json = this.toJSON();
    let result = new UpdateIncomeSourceRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateIncomeSourceRequest {
  incomeSource1: string | undefined;
  id: number;
}

export class UpdateIncomeTypeRequest implements IUpdateIncomeTypeRequest {
  incomeType1: string | undefined;
  id: number;

  constructor(data?: IUpdateIncomeTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.incomeType1 = _data["incomeType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateIncomeTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateIncomeTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["incomeType1"] = this.incomeType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateIncomeTypeRequest {
    const json = this.toJSON();
    let result = new UpdateIncomeTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateIncomeTypeRequest {
  incomeType1: string | undefined;
  id: number;
}

export class UpdateLaibilitiesTypeRequest
  implements IUpdateLaibilitiesTypeRequest {
  financialLaibilitiesType1: string | undefined;
  id: number;

  constructor(data?: IUpdateLaibilitiesTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialLaibilitiesType1 = _data["financialLaibilitiesType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLaibilitiesTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLaibilitiesTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialLaibilitiesType1"] = this.financialLaibilitiesType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLaibilitiesTypeRequest {
    const json = this.toJSON();
    let result = new UpdateLaibilitiesTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLaibilitiesTypeRequest {
  financialLaibilitiesType1: string | undefined;
  id: number;
}

export class UpdateLeadApplicationQuestions
  implements IUpdateLeadApplicationQuestions {
  question: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadApplicationQuestions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.question = _data["question"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadApplicationQuestions {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadApplicationQuestions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["question"] = this.question;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadApplicationQuestions {
    const json = this.toJSON();
    let result = new UpdateLeadApplicationQuestions();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadApplicationQuestions {
  question: string | undefined;
  id: number;
}

export class UpdateLeadApplicationType implements IUpdateLeadApplicationType {
  applicationType: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadApplicationType) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationType = _data["applicationType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadApplicationType {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadApplicationType();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["applicationType"] = this.applicationType;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadApplicationType {
    const json = this.toJSON();
    let result = new UpdateLeadApplicationType();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadApplicationType {
  applicationType: string | undefined;
  id: number;
}

export class UpdateLeadAssetDetails implements IUpdateLeadAssetDetails {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  assetTypeId: number;
  leadApplicationTypeId: number;
  financialInstitution: string | undefined;
  balance: number | undefined;
  ownerTypeId: number;
  id: number;

  constructor(data?: IUpdateLeadAssetDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.leadApplicationDetailPurchasingId =
        _data["leadApplicationDetailPurchasingId"];
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.assetTypeId = _data["assetTypeId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.financialInstitution = _data["financialInstitution"];
      this.balance = _data["balance"];
      this.ownerTypeId = _data["ownerTypeId"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadAssetDetails {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadAssetDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "leadApplicationDetailPurchasingId"
    ] = this.leadApplicationDetailPurchasingId;
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["assetTypeId"] = this.assetTypeId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["financialInstitution"] = this.financialInstitution;
    data["balance"] = this.balance;
    data["ownerTypeId"] = this.ownerTypeId;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadAssetDetails {
    const json = this.toJSON();
    let result = new UpdateLeadAssetDetails();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadAssetDetails {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  assetTypeId: number;
  leadApplicationTypeId: number;
  financialInstitution: string | undefined;
  balance: number | undefined;
  ownerTypeId: number;
  id: number;
}

export class UpdateLeadAssetTypes implements IUpdateLeadAssetTypes {
  assetsType: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadAssetTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.assetsType = _data["assetsType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadAssetTypes {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadAssetTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["assetsType"] = this.assetsType;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadAssetTypes {
    const json = this.toJSON();
    let result = new UpdateLeadAssetTypes();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadAssetTypes {
  assetsType: string | undefined;
  id: number;
}

export class UpdateLeadEmploymentDetails
  implements IUpdateLeadEmploymentDetails {
  employeeTypeId: number;
  leadApplicationDetailPurchasingId: number | undefined;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number;
  employerName: string | undefined;
  employementAddress: string | undefined;
  employementSuite: string | undefined;
  employementCity: string | undefined;
  employementTaxeId: number;
  employementZip: string | undefined;
  employerPhoneNumber: string | undefined;
  isCurrentJob: number | undefined;
  estimatedStartDate: moment.Moment | undefined;
  jobTitle: string | undefined;
  estimatedAnnualBaseSalary: number | undefined;
  estimatedAnnualBonus: number | undefined;
  estimatedAnnualCommission: number | undefined;
  estimatedAnnualOvertime: number | undefined;
  isCoBorrower: number | undefined;
  id: number;

  constructor(data?: IUpdateLeadEmploymentDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.employeeTypeId = _data["employeeTypeId"];
      this.leadApplicationDetailPurchasingId =
        _data["leadApplicationDetailPurchasingId"];
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.employerName = _data["employerName"];
      this.employementAddress = _data["employementAddress"];
      this.employementSuite = _data["employementSuite"];
      this.employementCity = _data["employementCity"];
      this.employementTaxeId = _data["employementTaxeId"];
      this.employementZip = _data["employementZip"];
      this.employerPhoneNumber = _data["employerPhoneNumber"];
      this.isCurrentJob = _data["isCurrentJob"];
      this.estimatedStartDate = _data["estimatedStartDate"]
        ? moment(_data["estimatedStartDate"].toString())
        : <any>undefined;
      this.jobTitle = _data["jobTitle"];
      this.estimatedAnnualBaseSalary = _data["estimatedAnnualBaseSalary"];
      this.estimatedAnnualBonus = _data["estimatedAnnualBonus"];
      this.estimatedAnnualCommission = _data["estimatedAnnualCommission"];
      this.estimatedAnnualOvertime = _data["estimatedAnnualOvertime"];
      this.isCoBorrower = _data["isCoBorrower"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadEmploymentDetails {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadEmploymentDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["employeeTypeId"] = this.employeeTypeId;
    data[
      "leadApplicationDetailPurchasingId"
    ] = this.leadApplicationDetailPurchasingId;
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["employerName"] = this.employerName;
    data["employementAddress"] = this.employementAddress;
    data["employementSuite"] = this.employementSuite;
    data["employementCity"] = this.employementCity;
    data["employementTaxeId"] = this.employementTaxeId;
    data["employementZip"] = this.employementZip;
    data["employerPhoneNumber"] = this.employerPhoneNumber;
    data["isCurrentJob"] = this.isCurrentJob;
    data["estimatedStartDate"] = this.estimatedStartDate
      ? this.estimatedStartDate.toISOString()
      : <any>undefined;
    data["jobTitle"] = this.jobTitle;
    data["estimatedAnnualBaseSalary"] = this.estimatedAnnualBaseSalary;
    data["estimatedAnnualBonus"] = this.estimatedAnnualBonus;
    data["estimatedAnnualCommission"] = this.estimatedAnnualCommission;
    data["estimatedAnnualOvertime"] = this.estimatedAnnualOvertime;
    data["isCoBorrower"] = this.isCoBorrower;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadEmploymentDetails {
    const json = this.toJSON();
    let result = new UpdateLeadEmploymentDetails();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadEmploymentDetails {
  employeeTypeId: number;
  leadApplicationDetailPurchasingId: number | undefined;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number;
  employerName: string | undefined;
  employementAddress: string | undefined;
  employementSuite: string | undefined;
  employementCity: string | undefined;
  employementTaxeId: number;
  employementZip: string | undefined;
  employerPhoneNumber: string | undefined;
  isCurrentJob: number | undefined;
  estimatedStartDate: moment.Moment | undefined;
  jobTitle: string | undefined;
  estimatedAnnualBaseSalary: number | undefined;
  estimatedAnnualBonus: number | undefined;
  estimatedAnnualCommission: number | undefined;
  estimatedAnnualOvertime: number | undefined;
  isCoBorrower: number | undefined;
  id: number;
}

export class UpdateLeadEmploymentTypes implements IUpdateLeadEmploymentTypes {
  employementType: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadEmploymentTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.employementType = _data["employementType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadEmploymentTypes {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadEmploymentTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["employementType"] = this.employementType;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadEmploymentTypes {
    const json = this.toJSON();
    let result = new UpdateLeadEmploymentTypes();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadEmploymentTypes {
  employementType: string | undefined;
  id: number;
}

export class UpdateLeadIncomeTypes implements IUpdateLeadIncomeTypes {
  incomeType: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadIncomeTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.incomeType = _data["incomeType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadIncomeTypes {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadIncomeTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["incomeType"] = this.incomeType;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadIncomeTypes {
    const json = this.toJSON();
    let result = new UpdateLeadIncomeTypes();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadIncomeTypes {
  incomeType: string | undefined;
  id: number;
}

export class UpdateLeadOwnerTypes implements IUpdateLeadOwnerTypes {
  ownerType: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadOwnerTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ownerType = _data["ownerType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadOwnerTypes {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadOwnerTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ownerType"] = this.ownerType;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadOwnerTypes {
    const json = this.toJSON();
    let result = new UpdateLeadOwnerTypes();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadOwnerTypes {
  ownerType: string | undefined;
  id: number;
}

export class UpdateLeadPurchasingDetail implements IUpdateLeadPurchasingDetail {
  stage: string | undefined;
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  newHomeAddress: string | undefined;
  newHomeUnit: string | undefined;
  newHomeCity: string | undefined;
  newHomeStateId: number;
  newHomeZipCode: string | undefined;
  contractClosingDate: moment.Moment | undefined;
  contractType: string | undefined;
  estimatedHomePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  creditScore: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  typeOfNewHome: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isSomeOneRefer: number | undefined;
  isApplyOwn: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  isEmployementHistory: number | undefined;
  isOtherSourceOfIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;
  id: number;

  constructor(data?: IUpdateLeadPurchasingDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.stage = _data["stage"];
      this.isWorkingWithEzalready = _data["isWorkingWithEzalready"];
      this.workingOfficerName = _data["workingOfficerName"];
      this.newHomeAddress = _data["newHomeAddress"];
      this.newHomeUnit = _data["newHomeUnit"];
      this.newHomeCity = _data["newHomeCity"];
      this.newHomeStateId = _data["newHomeStateId"];
      this.newHomeZipCode = _data["newHomeZipCode"];
      this.contractClosingDate = _data["contractClosingDate"]
        ? moment(_data["contractClosingDate"].toString())
        : <any>undefined;
      this.contractType = _data["contractType"];
      this.estimatedHomePrice = _data["estimatedHomePrice"];
      this.downPaymentAmount = _data["downPaymentAmount"];
      this.downPaymentPercentage = _data["downPaymentPercentage"];
      this.estimatedAnnualTax = _data["estimatedAnnualTax"];
      this.estimatedAnnualHomeInsurance = _data["estimatedAnnualHomeInsurance"];
      this.creditScore = _data["creditScore"];
      this.propertyLegalFirstName = _data["propertyLegalFirstName"];
      this.propertyMiddleInitial = _data["propertyMiddleInitial"];
      this.propertyLegalLastName = _data["propertyLegalLastName"];
      this.propertyPhoneNumber = _data["propertyPhoneNumber"];
      this.propertyEmailAddress = _data["propertyEmailAddress"];
      this.typeOfHome = _data["typeOfHome"];
      this.monthlyHoadues = _data["monthlyHoadues"];
      this.typeOfNewHome = _data["typeOfNewHome"];
      this.isMilitaryMember = _data["isMilitaryMember"];
      this.currentMilitaryStatus = _data["currentMilitaryStatus"];
      this.militaryBranch = _data["militaryBranch"];
      this.isEtsdateinYear = _data["isEtsdateinYear"];
      this.etsdate = _data["etsdate"]
        ? moment(_data["etsdate"].toString())
        : <any>undefined;
      this.isValoanPreviously = _data["isValoanPreviously"];
      this.whoLivingInHome = _data["whoLivingInHome"];
      this.personalLegalFirstName = _data["personalLegalFirstName"];
      this.personalMiddleInitial = _data["personalMiddleInitial"];
      this.personalLegalLastName = _data["personalLegalLastName"];
      this.personalPhoneNumber = _data["personalPhoneNumber"];
      this.personalEmailAddress = _data["personalEmailAddress"];
      this.personalPassword = _data["personalPassword"];
      this.isSomeOneRefer = _data["isSomeOneRefer"];
      this.isApplyOwn = _data["isApplyOwn"];
      this.maritialStatus = _data["maritialStatus"];
      this.numberOfDependents = _data["numberOfDependents"];
      this.currentAddress = _data["currentAddress"];
      this.currentUnit = _data["currentUnit"];
      this.currentCity = _data["currentCity"];
      this.currentStateId = _data["currentStateId"];
      this.currentZipCode = _data["currentZipCode"];
      this.currentStartLivingDate = _data["currentStartLivingDate"]
        ? moment(_data["currentStartLivingDate"].toString())
        : <any>undefined;
      this.currentReantingType = _data["currentReantingType"];
      this.estimatedMonthlyExpenses = _data["estimatedMonthlyExpenses"];
      this.isEmployementHistory = _data["isEmployementHistory"];
      this.isOtherSourceOfIncome = _data["isOtherSourceOfIncome"];
      this.sex = _data["sex"];
      this.ethnicity = _data["ethnicity"];
      this.race = _data["race"];
      this.citizenshipId = _data["citizenshipId"];
      this.isCertify = _data["isCertify"];
      this.isReadEconsent = _data["isReadEconsent"];
      this.isReadThirdPartyConsent = _data["isReadThirdPartyConsent"];
      this.socialSecurityNumber = _data["socialSecurityNumber"];
      this.conformSsn = _data["conformSsn"];
      this.birthDate = _data["birthDate"]
        ? moment(_data["birthDate"].toString())
        : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadPurchasingDetail {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadPurchasingDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["stage"] = this.stage;
    data["isWorkingWithEzalready"] = this.isWorkingWithEzalready;
    data["workingOfficerName"] = this.workingOfficerName;
    data["newHomeAddress"] = this.newHomeAddress;
    data["newHomeUnit"] = this.newHomeUnit;
    data["newHomeCity"] = this.newHomeCity;
    data["newHomeStateId"] = this.newHomeStateId;
    data["newHomeZipCode"] = this.newHomeZipCode;
    data["contractClosingDate"] = this.contractClosingDate
      ? this.contractClosingDate.toISOString()
      : <any>undefined;
    data["contractType"] = this.contractType;
    data["estimatedHomePrice"] = this.estimatedHomePrice;
    data["downPaymentAmount"] = this.downPaymentAmount;
    data["downPaymentPercentage"] = this.downPaymentPercentage;
    data["estimatedAnnualTax"] = this.estimatedAnnualTax;
    data["estimatedAnnualHomeInsurance"] = this.estimatedAnnualHomeInsurance;
    data["creditScore"] = this.creditScore;
    data["propertyLegalFirstName"] = this.propertyLegalFirstName;
    data["propertyMiddleInitial"] = this.propertyMiddleInitial;
    data["propertyLegalLastName"] = this.propertyLegalLastName;
    data["propertyPhoneNumber"] = this.propertyPhoneNumber;
    data["propertyEmailAddress"] = this.propertyEmailAddress;
    data["typeOfHome"] = this.typeOfHome;
    data["monthlyHoadues"] = this.monthlyHoadues;
    data["typeOfNewHome"] = this.typeOfNewHome;
    data["isMilitaryMember"] = this.isMilitaryMember;
    data["currentMilitaryStatus"] = this.currentMilitaryStatus;
    data["militaryBranch"] = this.militaryBranch;
    data["isEtsdateinYear"] = this.isEtsdateinYear;
    data["etsdate"] = this.etsdate
      ? this.etsdate.toISOString()
      : <any>undefined;
    data["isValoanPreviously"] = this.isValoanPreviously;
    data["whoLivingInHome"] = this.whoLivingInHome;
    data["personalLegalFirstName"] = this.personalLegalFirstName;
    data["personalMiddleInitial"] = this.personalMiddleInitial;
    data["personalLegalLastName"] = this.personalLegalLastName;
    data["personalPhoneNumber"] = this.personalPhoneNumber;
    data["personalEmailAddress"] = this.personalEmailAddress;
    data["personalPassword"] = this.personalPassword;
    data["isSomeOneRefer"] = this.isSomeOneRefer;
    data["isApplyOwn"] = this.isApplyOwn;
    data["maritialStatus"] = this.maritialStatus;
    data["numberOfDependents"] = this.numberOfDependents;
    data["currentAddress"] = this.currentAddress;
    data["currentUnit"] = this.currentUnit;
    data["currentCity"] = this.currentCity;
    data["currentStateId"] = this.currentStateId;
    data["currentZipCode"] = this.currentZipCode;
    data["currentStartLivingDate"] = this.currentStartLivingDate
      ? this.currentStartLivingDate.toISOString()
      : <any>undefined;
    data["currentReantingType"] = this.currentReantingType;
    data["estimatedMonthlyExpenses"] = this.estimatedMonthlyExpenses;
    data["isEmployementHistory"] = this.isEmployementHistory;
    data["isOtherSourceOfIncome"] = this.isOtherSourceOfIncome;
    data["sex"] = this.sex;
    data["ethnicity"] = this.ethnicity;
    data["race"] = this.race;
    data["citizenshipId"] = this.citizenshipId;
    data["isCertify"] = this.isCertify;
    data["isReadEconsent"] = this.isReadEconsent;
    data["isReadThirdPartyConsent"] = this.isReadThirdPartyConsent;
    data["socialSecurityNumber"] = this.socialSecurityNumber;
    data["conformSsn"] = this.conformSsn;
    data["birthDate"] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadPurchasingDetail {
    const json = this.toJSON();
    let result = new UpdateLeadPurchasingDetail();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadPurchasingDetail {
  stage: string | undefined;
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  newHomeAddress: string | undefined;
  newHomeUnit: string | undefined;
  newHomeCity: string | undefined;
  newHomeStateId: number;
  newHomeZipCode: string | undefined;
  contractClosingDate: moment.Moment | undefined;
  contractType: string | undefined;
  estimatedHomePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  creditScore: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  typeOfNewHome: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isSomeOneRefer: number | undefined;
  isApplyOwn: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  isEmployementHistory: number | undefined;
  isOtherSourceOfIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;
  id: number;
}

export class UpdateLeadQuestionAnswers implements IUpdateLeadQuestionAnswers {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  questionId: number;
  isYes: number | undefined;
  id: number;

  constructor(data?: IUpdateLeadQuestionAnswers) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.leadApplicationDetailPurchasingId =
        _data["leadApplicationDetailPurchasingId"];
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.questionId = _data["questionId"];
      this.isYes = _data["isYes"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadQuestionAnswers {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadQuestionAnswers();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "leadApplicationDetailPurchasingId"
    ] = this.leadApplicationDetailPurchasingId;
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["questionId"] = this.questionId;
    data["isYes"] = this.isYes;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadQuestionAnswers {
    const json = this.toJSON();
    let result = new UpdateLeadQuestionAnswers();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadQuestionAnswers {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  questionId: number;
  isYes: number | undefined;
  id: number;
}

export class UpdateLeadRefinancingDetails
  implements IUpdateLeadRefinancingDetails {
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  objectiveReason: string | undefined;
  propertyAddress: string | undefined;
  propertyUnit: string | undefined;
  propertyCity: string | undefined;
  propertyZip: string | undefined;
  propertyStateId: number;
  propertyCountryId: number;
  propertyEstimatedValue: number | undefined;
  propertyLoanBalance: number | undefined;
  propertCashOutAmount: number | undefined;
  newLoanEstimateAmount: number | undefined;
  creditScore: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  yearHomePurchased: number | undefined;
  orignalPurchasedPrice: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  currentlyUsingHomeAs: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  propertyPassword: string | undefined;
  isSomeoneRefer: number | undefined;
  refferedBy: string | undefined;
  isApplyOwn: number | undefined;
  isLegalSpouse: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  firstDependantAge: number | undefined;
  isCurrentlyLivingOnRefinancingProperty: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isAddressSameAsPrimaryBorrower: number | undefined;
  personalAddress: string | undefined;
  personalUnit: string | undefined;
  personalCity: string | undefined;
  personalStateId: number;
  personalZipCode: string | undefined;
  personalStartLivingDate: moment.Moment | undefined;
  personalReantingType: string | undefined;
  isEmployementHistory: number | undefined;
  isCoBorrowerHaveShareIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;
  id: number;

  constructor(data?: IUpdateLeadRefinancingDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isWorkingWithEzalready = _data["isWorkingWithEzalready"];
      this.workingOfficerName = _data["workingOfficerName"];
      this.objectiveReason = _data["objectiveReason"];
      this.propertyAddress = _data["propertyAddress"];
      this.propertyUnit = _data["propertyUnit"];
      this.propertyCity = _data["propertyCity"];
      this.propertyZip = _data["propertyZip"];
      this.propertyStateId = _data["propertyStateId"];
      this.propertyCountryId = _data["propertyCountryId"];
      this.propertyEstimatedValue = _data["propertyEstimatedValue"];
      this.propertyLoanBalance = _data["propertyLoanBalance"];
      this.propertCashOutAmount = _data["propertCashOutAmount"];
      this.newLoanEstimateAmount = _data["newLoanEstimateAmount"];
      this.creditScore = _data["creditScore"];
      this.typeOfHome = _data["typeOfHome"];
      this.monthlyHoadues = _data["monthlyHoadues"];
      this.yearHomePurchased = _data["yearHomePurchased"];
      this.orignalPurchasedPrice = _data["orignalPurchasedPrice"];
      this.estimatedAnnualTax = _data["estimatedAnnualTax"];
      this.estimatedAnnualHomeInsurance = _data["estimatedAnnualHomeInsurance"];
      this.currentlyUsingHomeAs = _data["currentlyUsingHomeAs"];
      this.isMilitaryMember = _data["isMilitaryMember"];
      this.currentMilitaryStatus = _data["currentMilitaryStatus"];
      this.militaryBranch = _data["militaryBranch"];
      this.isEtsdateinYear = _data["isEtsdateinYear"];
      this.etsdate = _data["etsdate"]
        ? moment(_data["etsdate"].toString())
        : <any>undefined;
      this.isValoanPreviously = _data["isValoanPreviously"];
      this.whoLivingInHome = _data["whoLivingInHome"];
      this.propertyLegalFirstName = _data["propertyLegalFirstName"];
      this.propertyMiddleInitial = _data["propertyMiddleInitial"];
      this.propertyLegalLastName = _data["propertyLegalLastName"];
      this.propertyPhoneNumber = _data["propertyPhoneNumber"];
      this.propertyEmailAddress = _data["propertyEmailAddress"];
      this.propertyPassword = _data["propertyPassword"];
      this.isSomeoneRefer = _data["isSomeoneRefer"];
      this.refferedBy = _data["refferedBy"];
      this.isApplyOwn = _data["isApplyOwn"];
      this.isLegalSpouse = _data["isLegalSpouse"];
      this.maritialStatus = _data["maritialStatus"];
      this.numberOfDependents = _data["numberOfDependents"];
      this.firstDependantAge = _data["firstDependantAge"];
      this.isCurrentlyLivingOnRefinancingProperty =
        _data["isCurrentlyLivingOnRefinancingProperty"];
      this.currentAddress = _data["currentAddress"];
      this.currentUnit = _data["currentUnit"];
      this.currentCity = _data["currentCity"];
      this.currentStateId = _data["currentStateId"];
      this.currentZipCode = _data["currentZipCode"];
      this.currentStartLivingDate = _data["currentStartLivingDate"]
        ? moment(_data["currentStartLivingDate"].toString())
        : <any>undefined;
      this.currentReantingType = _data["currentReantingType"];
      this.estimatedMonthlyExpenses = _data["estimatedMonthlyExpenses"];
      this.personalLegalFirstName = _data["personalLegalFirstName"];
      this.personalMiddleInitial = _data["personalMiddleInitial"];
      this.personalLegalLastName = _data["personalLegalLastName"];
      this.personalPhoneNumber = _data["personalPhoneNumber"];
      this.personalEmailAddress = _data["personalEmailAddress"];
      this.personalPassword = _data["personalPassword"];
      this.isAddressSameAsPrimaryBorrower =
        _data["isAddressSameAsPrimaryBorrower"];
      this.personalAddress = _data["personalAddress"];
      this.personalUnit = _data["personalUnit"];
      this.personalCity = _data["personalCity"];
      this.personalStateId = _data["personalStateId"];
      this.personalZipCode = _data["personalZipCode"];
      this.personalStartLivingDate = _data["personalStartLivingDate"]
        ? moment(_data["personalStartLivingDate"].toString())
        : <any>undefined;
      this.personalReantingType = _data["personalReantingType"];
      this.isEmployementHistory = _data["isEmployementHistory"];
      this.isCoBorrowerHaveShareIncome = _data["isCoBorrowerHaveShareIncome"];
      this.sex = _data["sex"];
      this.ethnicity = _data["ethnicity"];
      this.race = _data["race"];
      this.citizenshipId = _data["citizenshipId"];
      this.isCertify = _data["isCertify"];
      this.isReadEconsent = _data["isReadEconsent"];
      this.isReadThirdPartyConsent = _data["isReadThirdPartyConsent"];
      this.socialSecurityNumber = _data["socialSecurityNumber"];
      this.conformSsn = _data["conformSsn"];
      this.birthDate = _data["birthDate"]
        ? moment(_data["birthDate"].toString())
        : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadRefinancingDetails {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadRefinancingDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["isWorkingWithEzalready"] = this.isWorkingWithEzalready;
    data["workingOfficerName"] = this.workingOfficerName;
    data["objectiveReason"] = this.objectiveReason;
    data["propertyAddress"] = this.propertyAddress;
    data["propertyUnit"] = this.propertyUnit;
    data["propertyCity"] = this.propertyCity;
    data["propertyZip"] = this.propertyZip;
    data["propertyStateId"] = this.propertyStateId;
    data["propertyCountryId"] = this.propertyCountryId;
    data["propertyEstimatedValue"] = this.propertyEstimatedValue;
    data["propertyLoanBalance"] = this.propertyLoanBalance;
    data["propertCashOutAmount"] = this.propertCashOutAmount;
    data["newLoanEstimateAmount"] = this.newLoanEstimateAmount;
    data["creditScore"] = this.creditScore;
    data["typeOfHome"] = this.typeOfHome;
    data["monthlyHoadues"] = this.monthlyHoadues;
    data["yearHomePurchased"] = this.yearHomePurchased;
    data["orignalPurchasedPrice"] = this.orignalPurchasedPrice;
    data["estimatedAnnualTax"] = this.estimatedAnnualTax;
    data["estimatedAnnualHomeInsurance"] = this.estimatedAnnualHomeInsurance;
    data["currentlyUsingHomeAs"] = this.currentlyUsingHomeAs;
    data["isMilitaryMember"] = this.isMilitaryMember;
    data["currentMilitaryStatus"] = this.currentMilitaryStatus;
    data["militaryBranch"] = this.militaryBranch;
    data["isEtsdateinYear"] = this.isEtsdateinYear;
    data["etsdate"] = this.etsdate
      ? this.etsdate.toISOString()
      : <any>undefined;
    data["isValoanPreviously"] = this.isValoanPreviously;
    data["whoLivingInHome"] = this.whoLivingInHome;
    data["propertyLegalFirstName"] = this.propertyLegalFirstName;
    data["propertyMiddleInitial"] = this.propertyMiddleInitial;
    data["propertyLegalLastName"] = this.propertyLegalLastName;
    data["propertyPhoneNumber"] = this.propertyPhoneNumber;
    data["propertyEmailAddress"] = this.propertyEmailAddress;
    data["propertyPassword"] = this.propertyPassword;
    data["isSomeoneRefer"] = this.isSomeoneRefer;
    data["refferedBy"] = this.refferedBy;
    data["isApplyOwn"] = this.isApplyOwn;
    data["isLegalSpouse"] = this.isLegalSpouse;
    data["maritialStatus"] = this.maritialStatus;
    data["numberOfDependents"] = this.numberOfDependents;
    data["firstDependantAge"] = this.firstDependantAge;
    data[
      "isCurrentlyLivingOnRefinancingProperty"
    ] = this.isCurrentlyLivingOnRefinancingProperty;
    data["currentAddress"] = this.currentAddress;
    data["currentUnit"] = this.currentUnit;
    data["currentCity"] = this.currentCity;
    data["currentStateId"] = this.currentStateId;
    data["currentZipCode"] = this.currentZipCode;
    data["currentStartLivingDate"] = this.currentStartLivingDate
      ? this.currentStartLivingDate.toISOString()
      : <any>undefined;
    data["currentReantingType"] = this.currentReantingType;
    data["estimatedMonthlyExpenses"] = this.estimatedMonthlyExpenses;
    data["personalLegalFirstName"] = this.personalLegalFirstName;
    data["personalMiddleInitial"] = this.personalMiddleInitial;
    data["personalLegalLastName"] = this.personalLegalLastName;
    data["personalPhoneNumber"] = this.personalPhoneNumber;
    data["personalEmailAddress"] = this.personalEmailAddress;
    data["personalPassword"] = this.personalPassword;
    data[
      "isAddressSameAsPrimaryBorrower"
    ] = this.isAddressSameAsPrimaryBorrower;
    data["personalAddress"] = this.personalAddress;
    data["personalUnit"] = this.personalUnit;
    data["personalCity"] = this.personalCity;
    data["personalStateId"] = this.personalStateId;
    data["personalZipCode"] = this.personalZipCode;
    data["personalStartLivingDate"] = this.personalStartLivingDate
      ? this.personalStartLivingDate.toISOString()
      : <any>undefined;
    data["personalReantingType"] = this.personalReantingType;
    data["isEmployementHistory"] = this.isEmployementHistory;
    data["isCoBorrowerHaveShareIncome"] = this.isCoBorrowerHaveShareIncome;
    data["sex"] = this.sex;
    data["ethnicity"] = this.ethnicity;
    data["race"] = this.race;
    data["citizenshipId"] = this.citizenshipId;
    data["isCertify"] = this.isCertify;
    data["isReadEconsent"] = this.isReadEconsent;
    data["isReadThirdPartyConsent"] = this.isReadThirdPartyConsent;
    data["socialSecurityNumber"] = this.socialSecurityNumber;
    data["conformSsn"] = this.conformSsn;
    data["birthDate"] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadRefinancingDetails {
    const json = this.toJSON();
    let result = new UpdateLeadRefinancingDetails();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadRefinancingDetails {
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  objectiveReason: string | undefined;
  propertyAddress: string | undefined;
  propertyUnit: string | undefined;
  propertyCity: string | undefined;
  propertyZip: string | undefined;
  propertyStateId: number;
  propertyCountryId: number;
  propertyEstimatedValue: number | undefined;
  propertyLoanBalance: number | undefined;
  propertCashOutAmount: number | undefined;
  newLoanEstimateAmount: number | undefined;
  creditScore: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  yearHomePurchased: number | undefined;
  orignalPurchasedPrice: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  currentlyUsingHomeAs: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  propertyPassword: string | undefined;
  isSomeoneRefer: number | undefined;
  refferedBy: string | undefined;
  isApplyOwn: number | undefined;
  isLegalSpouse: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  firstDependantAge: number | undefined;
  isCurrentlyLivingOnRefinancingProperty: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isAddressSameAsPrimaryBorrower: number | undefined;
  personalAddress: string | undefined;
  personalUnit: string | undefined;
  personalCity: string | undefined;
  personalStateId: number;
  personalZipCode: string | undefined;
  personalStartLivingDate: moment.Moment | undefined;
  personalReantingType: string | undefined;
  isEmployementHistory: number | undefined;
  isCoBorrowerHaveShareIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;
  id: number;
}

export class UpdateLeadRefinancingIncomeDetails
  implements IUpdateLeadRefinancingIncomeDetails {
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  incomeTypeId: number;
  monthlyAmount: number | undefined;
  id: number;

  constructor(data?: IUpdateLeadRefinancingIncomeDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.incomeTypeId = _data["incomeTypeId"];
      this.monthlyAmount = _data["monthlyAmount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadRefinancingIncomeDetails {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadRefinancingIncomeDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["incomeTypeId"] = this.incomeTypeId;
    data["monthlyAmount"] = this.monthlyAmount;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadRefinancingIncomeDetails {
    const json = this.toJSON();
    let result = new UpdateLeadRefinancingIncomeDetails();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadRefinancingIncomeDetails {
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  incomeTypeId: number;
  monthlyAmount: number | undefined;
  id: number;
}

export class UpdateLeadTaxTypes implements IUpdateLeadTaxTypes {
  taxesType: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadTaxTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.taxesType = _data["taxesType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadTaxTypes {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadTaxTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["taxesType"] = this.taxesType;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadTaxTypes {
    const json = this.toJSON();
    let result = new UpdateLeadTaxTypes();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadTaxTypes {
  taxesType: string | undefined;
  id: number;
}

export class UpdateLoanAndPropertyInformationGiftRequest
  implements IUpdateLoanAndPropertyInformationGiftRequest {
  applicationPersonalInformationId: number | undefined;
  loanPropertyGiftTypeId4d1: number | undefined;
  deposited4d2: number | undefined;
  source4d3: string | undefined;
  value4d4: number | undefined;
  id: number;

  constructor(data?: IUpdateLoanAndPropertyInformationGiftRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.loanPropertyGiftTypeId4d1 = _data["loanPropertyGiftTypeId4d1"];
      this.deposited4d2 = _data["deposited4d2"];
      this.source4d3 = _data["source4d3"];
      this.value4d4 = _data["value4d4"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLoanAndPropertyInformationGiftRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanAndPropertyInformationGiftRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["loanPropertyGiftTypeId4d1"] = this.loanPropertyGiftTypeId4d1;
    data["deposited4d2"] = this.deposited4d2;
    data["source4d3"] = this.source4d3;
    data["value4d4"] = this.value4d4;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanAndPropertyInformationGiftRequest {
    const json = this.toJSON();
    let result = new UpdateLoanAndPropertyInformationGiftRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanAndPropertyInformationGiftRequest {
  applicationPersonalInformationId: number | undefined;
  loanPropertyGiftTypeId4d1: number | undefined;
  deposited4d2: number | undefined;
  source4d3: string | undefined;
  value4d4: number | undefined;
  id: number;
}

export class UpdateLoanAndPropertyInformationOtherMortageLoanRequest
  implements IUpdateLoanAndPropertyInformationOtherMortageLoanRequest {
  applicationPersonalInformationId: number | undefined;
  creditorName4b1: string | undefined;
  lienType4b2: string | undefined;
  monthlyPayment4b3: number | undefined;
  loanAmount4b4: number | undefined;
  creditAmount4b5: number | undefined;
  id: number;

  constructor(data?: IUpdateLoanAndPropertyInformationOtherMortageLoanRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.creditorName4b1 = _data["creditorName4b1"];
      this.lienType4b2 = _data["lienType4b2"];
      this.monthlyPayment4b3 = _data["monthlyPayment4b3"];
      this.loanAmount4b4 = _data["loanAmount4b4"];
      this.creditAmount4b5 = _data["creditAmount4b5"];
      this.id = _data["id"];
    }
  }

  static fromJS(
    data: any
  ): UpdateLoanAndPropertyInformationOtherMortageLoanRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanAndPropertyInformationOtherMortageLoanRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["creditorName4b1"] = this.creditorName4b1;
    data["lienType4b2"] = this.lienType4b2;
    data["monthlyPayment4b3"] = this.monthlyPayment4b3;
    data["loanAmount4b4"] = this.loanAmount4b4;
    data["creditAmount4b5"] = this.creditAmount4b5;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanAndPropertyInformationOtherMortageLoanRequest {
    const json = this.toJSON();
    let result = new UpdateLoanAndPropertyInformationOtherMortageLoanRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanAndPropertyInformationOtherMortageLoanRequest {
  applicationPersonalInformationId: number | undefined;
  creditorName4b1: string | undefined;
  lienType4b2: string | undefined;
  monthlyPayment4b3: number | undefined;
  loanAmount4b4: number | undefined;
  creditAmount4b5: number | undefined;
  id: number;
}

export class UpdateLoanAndPropertyInformationRentalIncomeRequest
  implements IUpdateLoanAndPropertyInformationRentalIncomeRequest {
  applicationPersonalInformationId: number | undefined;
  expectedMonthlyIncome4c1: number | undefined;
  lenderExpectedMonthlyIncome4c2: number | undefined;
  id: number;

  constructor(data?: IUpdateLoanAndPropertyInformationRentalIncomeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.expectedMonthlyIncome4c1 = _data["expectedMonthlyIncome4c1"];
      this.lenderExpectedMonthlyIncome4c2 =
        _data["lenderExpectedMonthlyIncome4c2"];
      this.id = _data["id"];
    }
  }

  static fromJS(
    data: any
  ): UpdateLoanAndPropertyInformationRentalIncomeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanAndPropertyInformationRentalIncomeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["expectedMonthlyIncome4c1"] = this.expectedMonthlyIncome4c1;
    data[
      "lenderExpectedMonthlyIncome4c2"
    ] = this.lenderExpectedMonthlyIncome4c2;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanAndPropertyInformationRentalIncomeRequest {
    const json = this.toJSON();
    let result = new UpdateLoanAndPropertyInformationRentalIncomeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanAndPropertyInformationRentalIncomeRequest {
  applicationPersonalInformationId: number | undefined;
  expectedMonthlyIncome4c1: number | undefined;
  lenderExpectedMonthlyIncome4c2: number | undefined;
  id: number;
}

export class UpdateLoanAndPropertyInformationRequest
  implements IUpdateLoanAndPropertyInformationRequest {
  applicationPersonalInformationId: number | undefined;
  loanAmount4a1: number | undefined;
  loanPurpose4a2: string | undefined;
  propertyStreet4a31: string | undefined;
  propertyUnitNo4a32: string | undefined;
  propertyZip4a35: string | undefined;
  countryId4a36: number;
  stateId4a34: number;
  cityId4a33: number;
  propertyNumberUnits4a4: number | undefined;
  propertyValue4a5: number | undefined;
  loanPropertyOccupancyId4a6: number | undefined;
  fhaSecondaryResidance4a61: number | undefined;
  isMixedUseProperty4a7: number | undefined;
  isManufacturedHome4a8: number | undefined;
  id: number;

  constructor(data?: IUpdateLoanAndPropertyInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.loanAmount4a1 = _data["loanAmount4a1"];
      this.loanPurpose4a2 = _data["loanPurpose4a2"];
      this.propertyStreet4a31 = _data["propertyStreet4a31"];
      this.propertyUnitNo4a32 = _data["propertyUnitNo4a32"];
      this.propertyZip4a35 = _data["propertyZip4a35"];
      this.countryId4a36 = _data["countryId4a36"];
      this.stateId4a34 = _data["stateId4a34"];
      this.cityId4a33 = _data["cityId4a33"];
      this.propertyNumberUnits4a4 = _data["propertyNumberUnits4a4"];
      this.propertyValue4a5 = _data["propertyValue4a5"];
      this.loanPropertyOccupancyId4a6 = _data["loanPropertyOccupancyId4a6"];
      this.fhaSecondaryResidance4a61 = _data["fhaSecondaryResidance4a61"];
      this.isMixedUseProperty4a7 = _data["isMixedUseProperty4a7"];
      this.isManufacturedHome4a8 = _data["isManufacturedHome4a8"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLoanAndPropertyInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanAndPropertyInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["loanAmount4a1"] = this.loanAmount4a1;
    data["loanPurpose4a2"] = this.loanPurpose4a2;
    data["propertyStreet4a31"] = this.propertyStreet4a31;
    data["propertyUnitNo4a32"] = this.propertyUnitNo4a32;
    data["propertyZip4a35"] = this.propertyZip4a35;
    data["countryId4a36"] = this.countryId4a36;
    data["stateId4a34"] = this.stateId4a34;
    data["cityId4a33"] = this.cityId4a33;
    data["propertyNumberUnits4a4"] = this.propertyNumberUnits4a4;
    data["propertyValue4a5"] = this.propertyValue4a5;
    data["loanPropertyOccupancyId4a6"] = this.loanPropertyOccupancyId4a6;
    data["fhaSecondaryResidance4a61"] = this.fhaSecondaryResidance4a61;
    data["isMixedUseProperty4a7"] = this.isMixedUseProperty4a7;
    data["isManufacturedHome4a8"] = this.isManufacturedHome4a8;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanAndPropertyInformationRequest {
    const json = this.toJSON();
    let result = new UpdateLoanAndPropertyInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanAndPropertyInformationRequest {
  applicationPersonalInformationId: number | undefined;
  loanAmount4a1: number | undefined;
  loanPurpose4a2: string | undefined;
  propertyStreet4a31: string | undefined;
  propertyUnitNo4a32: string | undefined;
  propertyZip4a35: string | undefined;
  countryId4a36: number;
  stateId4a34: number;
  cityId4a33: number;
  propertyNumberUnits4a4: number | undefined;
  propertyValue4a5: number | undefined;
  loanPropertyOccupancyId4a6: number | undefined;
  fhaSecondaryResidance4a61: number | undefined;
  isMixedUseProperty4a7: number | undefined;
  isManufacturedHome4a8: number | undefined;
  id: number;
}

export class UpdateLoanOriginatorInformationRequest
  implements IUpdateLoanOriginatorInformationRequest {
  applicationPersonalInformationId: number | undefined;
  organizationName91: string | undefined;
  address92: string | undefined;
  organizationNmlsrId93: string | undefined;
  organizationStateLicence94: string | undefined;
  originatorName95: string | undefined;
  originatorNmlsrId96: string | undefined;
  originatorStateLicense97: string | undefined;
  email98: string | undefined;
  phone99: string | undefined;
  date910: moment.Moment | undefined;
  id: number;

  constructor(data?: IUpdateLoanOriginatorInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.organizationName91 = _data["organizationName91"];
      this.address92 = _data["address92"];
      this.organizationNmlsrId93 = _data["organizationNmlsrId93"];
      this.organizationStateLicence94 = _data["organizationStateLicence94"];
      this.originatorName95 = _data["originatorName95"];
      this.originatorNmlsrId96 = _data["originatorNmlsrId96"];
      this.originatorStateLicense97 = _data["originatorStateLicense97"];
      this.email98 = _data["email98"];
      this.phone99 = _data["phone99"];
      this.date910 = _data["date910"]
        ? moment(_data["date910"].toString())
        : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLoanOriginatorInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanOriginatorInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["organizationName91"] = this.organizationName91;
    data["address92"] = this.address92;
    data["organizationNmlsrId93"] = this.organizationNmlsrId93;
    data["organizationStateLicence94"] = this.organizationStateLicence94;
    data["originatorName95"] = this.originatorName95;
    data["originatorNmlsrId96"] = this.originatorNmlsrId96;
    data["originatorStateLicense97"] = this.originatorStateLicense97;
    data["email98"] = this.email98;
    data["phone99"] = this.phone99;
    data["date910"] = this.date910
      ? this.date910.toISOString()
      : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanOriginatorInformationRequest {
    const json = this.toJSON();
    let result = new UpdateLoanOriginatorInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanOriginatorInformationRequest {
  applicationPersonalInformationId: number | undefined;
  organizationName91: string | undefined;
  address92: string | undefined;
  organizationNmlsrId93: string | undefined;
  organizationStateLicence94: string | undefined;
  originatorName95: string | undefined;
  originatorNmlsrId96: string | undefined;
  originatorStateLicense97: string | undefined;
  email98: string | undefined;
  phone99: string | undefined;
  date910: moment.Moment | undefined;
  id: number;
}

export class UpdateLoanPropertyGiftTypeRequest
  implements IUpdateLoanPropertyGiftTypeRequest {
  loanPropertyGiftType1: string | undefined;
  id: number;

  constructor(data?: IUpdateLoanPropertyGiftTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanPropertyGiftType1 = _data["loanPropertyGiftType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLoanPropertyGiftTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanPropertyGiftTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanPropertyGiftType1"] = this.loanPropertyGiftType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanPropertyGiftTypeRequest {
    const json = this.toJSON();
    let result = new UpdateLoanPropertyGiftTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanPropertyGiftTypeRequest {
  loanPropertyGiftType1: string | undefined;
  id: number;
}

export class UpdateLoanPropertyOccupancyRequest
  implements IUpdateLoanPropertyOccupancyRequest {
  loanPropertyOccupancy1: string | undefined;
  id: number;

  constructor(data?: IUpdateLoanPropertyOccupancyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanPropertyOccupancy1 = _data["loanPropertyOccupancy1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLoanPropertyOccupancyRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanPropertyOccupancyRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanPropertyOccupancy1"] = this.loanPropertyOccupancy1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanPropertyOccupancyRequest {
    const json = this.toJSON();
    let result = new UpdateLoanPropertyOccupancyRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanPropertyOccupancyRequest {
  loanPropertyOccupancy1: string | undefined;
  id: number;
}

export class UpdateMaritalStatusRequest implements IUpdateMaritalStatusRequest {
  maritialStatus1: string | undefined;
  id: number;

  constructor(data?: IUpdateMaritalStatusRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.maritialStatus1 = _data["maritialStatus1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateMaritalStatusRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateMaritalStatusRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["maritialStatus1"] = this.maritialStatus1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateMaritalStatusRequest {
    const json = this.toJSON();
    let result = new UpdateMaritalStatusRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateMaritalStatusRequest {
  maritialStatus1: string | undefined;
  id: number;
}

export class UpdateMilitaryServiceRequest
  implements IUpdateMilitaryServiceRequest {
  applicationPersonalInformationId: number | undefined;
  servedInForces7a1: number | undefined;
  currentlyServing7a2: number | undefined;
  dateOfServiceExpiration7a3: moment.Moment | undefined;
  retired7a2: number | undefined;
  nonActivatedMember7a2: number | undefined;
  survivingSpouse7a21: number | undefined;
  id: number;

  constructor(data?: IUpdateMilitaryServiceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.servedInForces7a1 = _data["servedInForces7a1"];
      this.currentlyServing7a2 = _data["currentlyServing7a2"];
      this.dateOfServiceExpiration7a3 = _data["dateOfServiceExpiration7a3"]
        ? moment(_data["dateOfServiceExpiration7a3"].toString())
        : <any>undefined;
      this.retired7a2 = _data["retired7a2"];
      this.nonActivatedMember7a2 = _data["nonActivatedMember7a2"];
      this.survivingSpouse7a21 = _data["survivingSpouse7a21"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateMilitaryServiceRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateMilitaryServiceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["servedInForces7a1"] = this.servedInForces7a1;
    data["currentlyServing7a2"] = this.currentlyServing7a2;
    data["dateOfServiceExpiration7a3"] = this.dateOfServiceExpiration7a3
      ? this.dateOfServiceExpiration7a3.toISOString()
      : <any>undefined;
    data["retired7a2"] = this.retired7a2;
    data["nonActivatedMember7a2"] = this.nonActivatedMember7a2;
    data["survivingSpouse7a21"] = this.survivingSpouse7a21;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateMilitaryServiceRequest {
    const json = this.toJSON();
    let result = new UpdateMilitaryServiceRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateMilitaryServiceRequest {
  applicationPersonalInformationId: number | undefined;
  servedInForces7a1: number | undefined;
  currentlyServing7a2: number | undefined;
  dateOfServiceExpiration7a3: moment.Moment | undefined;
  retired7a2: number | undefined;
  nonActivatedMember7a2: number | undefined;
  survivingSpouse7a21: number | undefined;
  id: number;
}

export class UpdateMortageLoanOnPropertyRequest
  implements IUpdateMortageLoanOnPropertyRequest {
  applicationFinancialRealEstateId: number | undefined;
  creditorName3a9: string | undefined;
  accountNumber3a10: string | undefined;
  monthlyMortagePayment3a11: number | undefined;
  unpaidBalance3a12: number | undefined;
  paidOff3a13: number | undefined;
  mortageLoanTypesId3a14: number;
  creditLimit3a15: number | undefined;
  id: number;

  constructor(data?: IUpdateMortageLoanOnPropertyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationFinancialRealEstateId =
        _data["applicationFinancialRealEstateId"];
      this.creditorName3a9 = _data["creditorName3a9"];
      this.accountNumber3a10 = _data["accountNumber3a10"];
      this.monthlyMortagePayment3a11 = _data["monthlyMortagePayment3a11"];
      this.unpaidBalance3a12 = _data["unpaidBalance3a12"];
      this.paidOff3a13 = _data["paidOff3a13"];
      this.mortageLoanTypesId3a14 = _data["mortageLoanTypesId3a14"];
      this.creditLimit3a15 = _data["creditLimit3a15"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateMortageLoanOnPropertyRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateMortageLoanOnPropertyRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationFinancialRealEstateId"
    ] = this.applicationFinancialRealEstateId;
    data["creditorName3a9"] = this.creditorName3a9;
    data["accountNumber3a10"] = this.accountNumber3a10;
    data["monthlyMortagePayment3a11"] = this.monthlyMortagePayment3a11;
    data["unpaidBalance3a12"] = this.unpaidBalance3a12;
    data["paidOff3a13"] = this.paidOff3a13;
    data["mortageLoanTypesId3a14"] = this.mortageLoanTypesId3a14;
    data["creditLimit3a15"] = this.creditLimit3a15;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateMortageLoanOnPropertyRequest {
    const json = this.toJSON();
    let result = new UpdateMortageLoanOnPropertyRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateMortageLoanOnPropertyRequest {
  applicationFinancialRealEstateId: number | undefined;
  creditorName3a9: string | undefined;
  accountNumber3a10: string | undefined;
  monthlyMortagePayment3a11: number | undefined;
  unpaidBalance3a12: number | undefined;
  paidOff3a13: number | undefined;
  mortageLoanTypesId3a14: number;
  creditLimit3a15: number | undefined;
  id: number;
}

export class UpdateMortageLoanTypeRequest
  implements IUpdateMortageLoanTypeRequest {
  mortageLoanTypesId: string | undefined;
  id: number;

  constructor(data?: IUpdateMortageLoanTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.mortageLoanTypesId = _data["mortageLoanTypesId"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateMortageLoanTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateMortageLoanTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["mortageLoanTypesId"] = this.mortageLoanTypesId;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateMortageLoanTypeRequest {
    const json = this.toJSON();
    let result = new UpdateMortageLoanTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateMortageLoanTypeRequest {
  mortageLoanTypesId: string | undefined;
  id: number;
}

export class UpdateOtherLaibilitiesTypeRequest
  implements IUpdateOtherLaibilitiesTypeRequest {
  financialOtherLaibilitiesType1: string | undefined;
  id: number;

  constructor(data?: IUpdateOtherLaibilitiesTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialOtherLaibilitiesType1 =
        _data["financialOtherLaibilitiesType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateOtherLaibilitiesTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateOtherLaibilitiesTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "financialOtherLaibilitiesType1"
    ] = this.financialOtherLaibilitiesType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateOtherLaibilitiesTypeRequest {
    const json = this.toJSON();
    let result = new UpdateOtherLaibilitiesTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateOtherLaibilitiesTypeRequest {
  financialOtherLaibilitiesType1: string | undefined;
  id: number;
}

export class UpdatePersonalInformationRequest
  implements IUpdatePersonalInformationRequest {
  applicationId: number;
  firstName1a1: string | undefined;
  middleName1a2: string | undefined;
  lastName1a3: string | undefined;
  suffix1a4: string | undefined;
  alternateFirstName1a21: string | undefined;
  alternateMiddleName1a22: string | undefined;
  alternateLastName1a23: string | undefined;
  alternateSuffix1a24: string | undefined;
  ssn1a3: string | undefined;
  dob1a4: moment.Moment | undefined;
  citizenshipTypeId1a5: number;
  maritialStatusId1a7: number;
  dependents1a8: number | undefined;
  ages1a81: string | undefined;
  homePhone1a9: string | undefined;
  cellPhone1a10: string | undefined;
  workPhone1a11: string | undefined;
  ext1a111: string | undefined;
  email1a12: string | undefined;
  currentStreet1a131: string | undefined;
  currentUnit1a132: string | undefined;
  currentZip1a135: string | undefined;
  currentCountryId1a136: number;
  currentStateId1a134: number;
  currentCityId1a133: number;
  currentYears1a14: number | undefined;
  currentMonths1a15: number | undefined;
  currentHousingTypeId1a141: number;
  currentRent1a142: number | undefined;
  formerStreet1a151: string | undefined;
  formerUnit1a152: string | undefined;
  formerZip1a155: string | undefined;
  formerCountryId1a156: number;
  formerStateId1a154: number;
  formerCityId1a153: number;
  formerYears1a16: number | undefined;
  formerMonths1a161: number | undefined;
  formerHousingTypeId1a161: number;
  formerRent1a162: number | undefined;
  mailingStreet1a171: string | undefined;
  mailingUnit1a172: string | undefined;
  mailingZip1a175: string | undefined;
  mailingCountryId1a176: number;
  mailingStateId1a174: number;
  mailingCityId1a173: number;
  id: number;

  constructor(data?: IUpdatePersonalInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationId = _data["applicationId"];
      this.firstName1a1 = _data["firstName1a1"];
      this.middleName1a2 = _data["middleName1a2"];
      this.lastName1a3 = _data["lastName1a3"];
      this.suffix1a4 = _data["suffix1a4"];
      this.alternateFirstName1a21 = _data["alternateFirstName1a21"];
      this.alternateMiddleName1a22 = _data["alternateMiddleName1a22"];
      this.alternateLastName1a23 = _data["alternateLastName1a23"];
      this.alternateSuffix1a24 = _data["alternateSuffix1a24"];
      this.ssn1a3 = _data["ssn1a3"];
      this.dob1a4 = _data["dob1a4"]
        ? moment(_data["dob1a4"].toString())
        : <any>undefined;
      this.citizenshipTypeId1a5 = _data["citizenshipTypeId1a5"];
      this.maritialStatusId1a7 = _data["maritialStatusId1a7"];
      this.dependents1a8 = _data["dependents1a8"];
      this.ages1a81 = _data["ages1a81"];
      this.homePhone1a9 = _data["homePhone1a9"];
      this.cellPhone1a10 = _data["cellPhone1a10"];
      this.workPhone1a11 = _data["workPhone1a11"];
      this.ext1a111 = _data["ext1a111"];
      this.email1a12 = _data["email1a12"];
      this.currentStreet1a131 = _data["currentStreet1a131"];
      this.currentUnit1a132 = _data["currentUnit1a132"];
      this.currentZip1a135 = _data["currentZip1a135"];
      this.currentCountryId1a136 = _data["currentCountryId1a136"];
      this.currentStateId1a134 = _data["currentStateId1a134"];
      this.currentCityId1a133 = _data["currentCityId1a133"];
      this.currentYears1a14 = _data["currentYears1a14"];
      this.currentMonths1a15 = _data["currentMonths1a15"];
      this.currentHousingTypeId1a141 = _data["currentHousingTypeId1a141"];
      this.currentRent1a142 = _data["currentRent1a142"];
      this.formerStreet1a151 = _data["formerStreet1a151"];
      this.formerUnit1a152 = _data["formerUnit1a152"];
      this.formerZip1a155 = _data["formerZip1a155"];
      this.formerCountryId1a156 = _data["formerCountryId1a156"];
      this.formerStateId1a154 = _data["formerStateId1a154"];
      this.formerCityId1a153 = _data["formerCityId1a153"];
      this.formerYears1a16 = _data["formerYears1a16"];
      this.formerMonths1a161 = _data["formerMonths1a161"];
      this.formerHousingTypeId1a161 = _data["formerHousingTypeId1a161"];
      this.formerRent1a162 = _data["formerRent1a162"];
      this.mailingStreet1a171 = _data["mailingStreet1a171"];
      this.mailingUnit1a172 = _data["mailingUnit1a172"];
      this.mailingZip1a175 = _data["mailingZip1a175"];
      this.mailingCountryId1a176 = _data["mailingCountryId1a176"];
      this.mailingStateId1a174 = _data["mailingStateId1a174"];
      this.mailingCityId1a173 = _data["mailingCityId1a173"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdatePersonalInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdatePersonalInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["applicationId"] = this.applicationId;
    data["firstName1a1"] = this.firstName1a1;
    data["middleName1a2"] = this.middleName1a2;
    data["lastName1a3"] = this.lastName1a3;
    data["suffix1a4"] = this.suffix1a4;
    data["alternateFirstName1a21"] = this.alternateFirstName1a21;
    data["alternateMiddleName1a22"] = this.alternateMiddleName1a22;
    data["alternateLastName1a23"] = this.alternateLastName1a23;
    data["alternateSuffix1a24"] = this.alternateSuffix1a24;
    data["ssn1a3"] = this.ssn1a3;
    data["dob1a4"] = this.dob1a4 ? this.dob1a4.toISOString() : <any>undefined;
    data["citizenshipTypeId1a5"] = this.citizenshipTypeId1a5;
    data["maritialStatusId1a7"] = this.maritialStatusId1a7;
    data["dependents1a8"] = this.dependents1a8;
    data["ages1a81"] = this.ages1a81;
    data["homePhone1a9"] = this.homePhone1a9;
    data["cellPhone1a10"] = this.cellPhone1a10;
    data["workPhone1a11"] = this.workPhone1a11;
    data["ext1a111"] = this.ext1a111;
    data["email1a12"] = this.email1a12;
    data["currentStreet1a131"] = this.currentStreet1a131;
    data["currentUnit1a132"] = this.currentUnit1a132;
    data["currentZip1a135"] = this.currentZip1a135;
    data["currentCountryId1a136"] = this.currentCountryId1a136;
    data["currentStateId1a134"] = this.currentStateId1a134;
    data["currentCityId1a133"] = this.currentCityId1a133;
    data["currentYears1a14"] = this.currentYears1a14;
    data["currentMonths1a15"] = this.currentMonths1a15;
    data["currentHousingTypeId1a141"] = this.currentHousingTypeId1a141;
    data["currentRent1a142"] = this.currentRent1a142;
    data["formerStreet1a151"] = this.formerStreet1a151;
    data["formerUnit1a152"] = this.formerUnit1a152;
    data["formerZip1a155"] = this.formerZip1a155;
    data["formerCountryId1a156"] = this.formerCountryId1a156;
    data["formerStateId1a154"] = this.formerStateId1a154;
    data["formerCityId1a153"] = this.formerCityId1a153;
    data["formerYears1a16"] = this.formerYears1a16;
    data["formerMonths1a161"] = this.formerMonths1a161;
    data["formerHousingTypeId1a161"] = this.formerHousingTypeId1a161;
    data["formerRent1a162"] = this.formerRent1a162;
    data["mailingStreet1a171"] = this.mailingStreet1a171;
    data["mailingUnit1a172"] = this.mailingUnit1a172;
    data["mailingZip1a175"] = this.mailingZip1a175;
    data["mailingCountryId1a176"] = this.mailingCountryId1a176;
    data["mailingStateId1a174"] = this.mailingStateId1a174;
    data["mailingCityId1a173"] = this.mailingCityId1a173;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdatePersonalInformationRequest {
    const json = this.toJSON();
    let result = new UpdatePersonalInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdatePersonalInformationRequest {
  applicationId: number;
  firstName1a1: string | undefined;
  middleName1a2: string | undefined;
  lastName1a3: string | undefined;
  suffix1a4: string | undefined;
  alternateFirstName1a21: string | undefined;
  alternateMiddleName1a22: string | undefined;
  alternateLastName1a23: string | undefined;
  alternateSuffix1a24: string | undefined;
  ssn1a3: string | undefined;
  dob1a4: moment.Moment | undefined;
  citizenshipTypeId1a5: number;
  maritialStatusId1a7: number;
  dependents1a8: number | undefined;
  ages1a81: string | undefined;
  homePhone1a9: string | undefined;
  cellPhone1a10: string | undefined;
  workPhone1a11: string | undefined;
  ext1a111: string | undefined;
  email1a12: string | undefined;
  currentStreet1a131: string | undefined;
  currentUnit1a132: string | undefined;
  currentZip1a135: string | undefined;
  currentCountryId1a136: number;
  currentStateId1a134: number;
  currentCityId1a133: number;
  currentYears1a14: number | undefined;
  currentMonths1a15: number | undefined;
  currentHousingTypeId1a141: number;
  currentRent1a142: number | undefined;
  formerStreet1a151: string | undefined;
  formerUnit1a152: string | undefined;
  formerZip1a155: string | undefined;
  formerCountryId1a156: number;
  formerStateId1a154: number;
  formerCityId1a153: number;
  formerYears1a16: number | undefined;
  formerMonths1a161: number | undefined;
  formerHousingTypeId1a161: number;
  formerRent1a162: number | undefined;
  mailingStreet1a171: string | undefined;
  mailingUnit1a172: string | undefined;
  mailingZip1a175: string | undefined;
  mailingCountryId1a176: number;
  mailingStateId1a174: number;
  mailingCityId1a173: number;
  id: number;
}

export class UpdatePreviousEmployementDetailRequest
  implements IUpdatePreviousEmployementDetailRequest {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName1d2: string | undefined;
  street1d31: string | undefined;
  unit1d32: string | undefined;
  zip1d35: string | undefined;
  countryId1d36: number;
  stateId1d34: number;
  cityId1d33: number;
  positionTitle1d4: string | undefined;
  startDate1d5: moment.Moment | undefined;
  endDate1d6: moment.Moment | undefined;
  isSelfEmployed1d7: number | undefined;
  grossMonthlyIncome1d8: number | undefined;
  id: number;

  constructor(data?: IUpdatePreviousEmployementDetailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.employerBusinessName1d2 = _data["employerBusinessName1d2"];
      this.street1d31 = _data["street1d31"];
      this.unit1d32 = _data["unit1d32"];
      this.zip1d35 = _data["zip1d35"];
      this.countryId1d36 = _data["countryId1d36"];
      this.stateId1d34 = _data["stateId1d34"];
      this.cityId1d33 = _data["cityId1d33"];
      this.positionTitle1d4 = _data["positionTitle1d4"];
      this.startDate1d5 = _data["startDate1d5"]
        ? moment(_data["startDate1d5"].toString())
        : <any>undefined;
      this.endDate1d6 = _data["endDate1d6"]
        ? moment(_data["endDate1d6"].toString())
        : <any>undefined;
      this.isSelfEmployed1d7 = _data["isSelfEmployed1d7"];
      this.grossMonthlyIncome1d8 = _data["grossMonthlyIncome1d8"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdatePreviousEmployementDetailRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdatePreviousEmployementDetailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["employerBusinessName1d2"] = this.employerBusinessName1d2;
    data["street1d31"] = this.street1d31;
    data["unit1d32"] = this.unit1d32;
    data["zip1d35"] = this.zip1d35;
    data["countryId1d36"] = this.countryId1d36;
    data["stateId1d34"] = this.stateId1d34;
    data["cityId1d33"] = this.cityId1d33;
    data["positionTitle1d4"] = this.positionTitle1d4;
    data["startDate1d5"] = this.startDate1d5
      ? this.startDate1d5.toISOString()
      : <any>undefined;
    data["endDate1d6"] = this.endDate1d6
      ? this.endDate1d6.toISOString()
      : <any>undefined;
    data["isSelfEmployed1d7"] = this.isSelfEmployed1d7;
    data["grossMonthlyIncome1d8"] = this.grossMonthlyIncome1d8;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdatePreviousEmployementDetailRequest {
    const json = this.toJSON();
    let result = new UpdatePreviousEmployementDetailRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdatePreviousEmployementDetailRequest {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName1d2: string | undefined;
  street1d31: string | undefined;
  unit1d32: string | undefined;
  zip1d35: string | undefined;
  countryId1d36: number;
  stateId1d34: number;
  cityId1d33: number;
  positionTitle1d4: string | undefined;
  startDate1d5: moment.Moment | undefined;
  endDate1d6: moment.Moment | undefined;
  isSelfEmployed1d7: number | undefined;
  grossMonthlyIncome1d8: number | undefined;
  id: number;
}

export class UpdatePropertyIntendedOccupancyRequest
  implements IUpdatePropertyIntendedOccupancyRequest {
  financialPropertyIntendedOccupancy1: string | undefined;
  id: number;

  constructor(data?: IUpdatePropertyIntendedOccupancyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialPropertyIntendedOccupancy1 =
        _data["financialPropertyIntendedOccupancy1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdatePropertyIntendedOccupancyRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdatePropertyIntendedOccupancyRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "financialPropertyIntendedOccupancy1"
    ] = this.financialPropertyIntendedOccupancy1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdatePropertyIntendedOccupancyRequest {
    const json = this.toJSON();
    let result = new UpdatePropertyIntendedOccupancyRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdatePropertyIntendedOccupancyRequest {
  financialPropertyIntendedOccupancy1: string | undefined;
  id: number;
}

export class UpdatePropertyStatusRequest
  implements IUpdatePropertyStatusRequest {
  financialPropertyStatus1: string | undefined;
  id: number;

  constructor(data?: IUpdatePropertyStatusRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialPropertyStatus1 = _data["financialPropertyStatus1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdatePropertyStatusRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdatePropertyStatusRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialPropertyStatus1"] = this.financialPropertyStatus1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdatePropertyStatusRequest {
    const json = this.toJSON();
    let result = new UpdatePropertyStatusRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdatePropertyStatusRequest {
  financialPropertyStatus1: string | undefined;
  id: number;
}

export class UpdateStateRequest implements IUpdateStateRequest {
  countryId: number;
  stateName: string | undefined;
  id: number;

  constructor(data?: IUpdateStateRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.countryId = _data["countryId"];
      this.stateName = _data["stateName"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateStateRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateStateRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["countryId"] = this.countryId;
    data["stateName"] = this.stateName;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateStateRequest {
    const json = this.toJSON();
    let result = new UpdateStateRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateStateRequest {
  countryId: number;
  stateName: string | undefined;
  id: number;
}

export class UserDto implements IUserDto {
  id: number;
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  fullName: string | undefined;
  lastLoginTime: moment.Moment | undefined;
  creationTime: moment.Moment;
  roleNames: string[] | undefined;

  constructor(data?: IUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.userName = _data["userName"];
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.emailAddress = _data["emailAddress"];
      this.isActive = _data["isActive"];
      this.fullName = _data["fullName"];
      this.lastLoginTime = _data["lastLoginTime"]
        ? moment(_data["lastLoginTime"].toString())
        : <any>undefined;
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      if (Array.isArray(_data["roleNames"])) {
        this.roleNames = [] as any;
        for (let item of _data["roleNames"]) this.roleNames.push(item);
      }
    }
  }

  static fromJS(data: any): UserDto {
    data = typeof data === "object" ? data : {};
    let result = new UserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["userName"] = this.userName;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["emailAddress"] = this.emailAddress;
    data["isActive"] = this.isActive;
    data["fullName"] = this.fullName;
    data["lastLoginTime"] = this.lastLoginTime
      ? this.lastLoginTime.toISOString()
      : <any>undefined;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    if (Array.isArray(this.roleNames)) {
      data["roleNames"] = [];
      for (let item of this.roleNames) data["roleNames"].push(item);
    }
    return data;
  }

  clone(): UserDto {
    const json = this.toJSON();
    let result = new UserDto();
    result.init(json);
    return result;
  }
}

export interface IUserDto {
  id: number;
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  fullName: string | undefined;
  lastLoginTime: moment.Moment | undefined;
  creationTime: moment.Moment;
  roleNames: string[] | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
  items: UserDto[] | undefined;
  totalCount: number;

  constructor(data?: IUserDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(UserDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): UserDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new UserDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): UserDtoPagedResultDto {
    const json = this.toJSON();
    let result = new UserDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IUserDtoPagedResultDto {
  items: UserDto[] | undefined;
  totalCount: number;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
  id: number;
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;

  constructor(data?: IUserLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.userName = _data["userName"];
      this.emailAddress = _data["emailAddress"];
    }
  }

  static fromJS(data: any): UserLoginInfoDto {
    data = typeof data === "object" ? data : {};
    let result = new UserLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["userName"] = this.userName;
    data["emailAddress"] = this.emailAddress;
    return data;
  }

  clone(): UserLoginInfoDto {
    const json = this.toJSON();
    let result = new UserLoginInfoDto();
    result.init(json);
    return result;
  }
}

export interface IUserLoginInfoDto {
  id: number;
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(
      new ApiException(message, status, response, headers, null)
    );
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
